"use strict";var e=require("./interceptors/manager.cjs"),t=require("./utils/index.cjs"),r=require("./utils/cache.cjs"),s=require("./utils/cancel.cjs"),o=require("./utils/concurrency.cjs"),n=require("./utils/download.cjs"),i=require("./utils/error.cjs"),a=require("./utils/monitor.cjs"),c=require("./utils/pool.cjs"),u=require("./utils/priority.cjs"),l=require("./utils/upload.cjs");exports.HttpClientImpl=class{constructor(t={},n){if(this.isDestroyed=!1,this.config={timeout:1e4,headers:{"Content-Type":"application/json",...t.headers},...t},!n)throw new Error("HTTP adapter is required");this.adapter=n,this.retryManager=new i.RetryManager(t.retry),this.cancelManager=s.globalCancelManager,this.cacheManager=new r.CacheManager(t.cache),this.concurrencyManager=new o.ConcurrencyManager(t.concurrency),this.monitor=new a.RequestMonitor(t.monitor),this.priorityQueue=new u.PriorityQueue(t.priorityQueue),this.requestPool=new c.RequestPool(t.connectionPool),this.interceptors={request:new e.InterceptorManagerImpl,response:new e.InterceptorManagerImpl,error:new e.InterceptorManagerImpl}}async request(e){this.checkDestroyed();const r=this.optimizedMergeConfig(e),s=t.generateId();this.monitor.startRequest(s,r);const o=u.determinePriority(r);if(void 0!==o&&this.priorityQueue)return this.priorityQueue.enqueue(r,async()=>{try{const e=await this.executeRequestWithRetry(r,s);return this.monitor.endRequest(s,r,e),e}catch(e){throw this.monitor.endRequest(s,r,void 0,e),e}},o);try{const e=await this.executeRequestWithRetry(r,s);return this.monitor.endRequest(s,r,e),e}catch(e){throw this.monitor.endRequest(s,r,void 0,e),e}}async executeRequestWithRetry(e,t){const r=e.retry;return r?.retries&&r.retries>0?this.retryManager.executeWithRetry(()=>(this.monitor.recordRetry(t),this.executeRequest(e)),e):this.executeRequest(e)}async executeRequest(e){return await this.cacheManager.get(e)||this.concurrencyManager.execute(()=>this.performRequest(e),e)}async performRequest(e){let t=null;try{t=await this.processRequestInterceptors(e);let r=await this.adapter.request(t);return r=await this.processResponseInterceptors(r),await this.cacheManager.set(t,r),r}catch(e){throw await this.processErrorInterceptors(e)}}get(e,t={}){return this.request({...t,method:"GET",url:e})}post(e,t,r={}){return this.request({...r,method:"POST",url:e,data:t})}put(e,t,r={}){return this.request({...r,method:"PUT",url:e,data:t})}delete(e,t={}){return this.request({...t,method:"DELETE",url:e})}patch(e,t,r={}){return this.request({...r,method:"PATCH",url:e,data:t})}head(e,t={}){return this.request({...t,method:"HEAD",url:e})}options(e,t={}){return this.request({...t,method:"OPTIONS",url:e})}cancelAll(e){this.cancelManager.cancelAll(e)}getActiveRequestCount(){return this.cancelManager.getActiveRequestCount()}updateRetryConfig(e){this.retryManager.updateConfig(e)}setConfig(e){this.config={...this.config,...e,headers:{...this.config?.headers,...e.headers}}}getConfig(){return{...this.config}}addRequestInterceptor(e,t){return this.interceptors.request.use(e,t)}addResponseInterceptor(e,t){return this.interceptors.response.use(e,t)}removeRequestInterceptor(e){this.interceptors.request.eject(e)}removeResponseInterceptor(e){this.interceptors.response.eject(e)}clearCache(){return this.cacheManager.clear()}getConcurrencyStatus(){return this.concurrencyManager.getStatus()}cancelQueue(e){this.concurrencyManager.cancelQueue(e)}async processRequestInterceptors(e){let t=e;const r=this.interceptors.request.getInterceptors();for(const e of r)try{t=await e.fulfilled(t)}catch(t){throw e.rejected?await e.rejected(t):t}return t}async processResponseInterceptors(e){let t=e;const r=this.interceptors.response.getInterceptors();for(const e of r)try{t=await e.fulfilled(t)}catch(t){throw e.rejected?await e.rejected(t):t}return t}async processErrorInterceptors(e){let t=e;const r=this.interceptors.error.getInterceptors();for(const e of r)try{t=await e.fulfilled(t)}catch(e){t=e}return t}optimizedMergeConfig(e){if(!e||0===Object.keys(e).length)return{...this.config};const t={...this.config,...e};return this.config?.headers&&e.headers&&(t.headers={...this.config.headers,...e.headers}),this.config?.params&&e.params&&(t.params={...this.config.params,...e.params}),t}async upload(e,t,r={}){this.checkDestroyed();const s=Array.isArray(t)?t:[t];return 1===s.length?this.uploadSingleFile(e,s[0],r):this.uploadMultipleFiles(e,s,r)}async uploadSingleFile(e,t,r){l.validateFile(t,r);const s=Date.now(),o=new l.ProgressCalculator,n={method:"POST",url:e,data:l.createUploadFormData(t,r),headers:{...r.headers||{}},...r||{},onUploadProgress:r.onProgress?e=>{const s=o.calculate(e.loaded,e.total||0,t);r.onProgress?.(s)}:void 0};return{...await this.request(n),file:t,duration:Date.now()-s}}async uploadMultipleFiles(e,t,r){t.forEach(e=>l.validateFile(e,r));const s=Date.now(),o=new l.ProgressCalculator,n=new FormData,i=r.fileField||"files";t.forEach((e,t)=>{n.append(`${i}[${t}]`,e)}),r.formData&&Object.entries(r.formData).forEach(([e,t])=>{n.append(e,t)});const a={method:"POST",url:e,data:n,headers:{...r.headers||{}},...r||{},onUploadProgress:r.onProgress?e=>{const t=o.calculate(e.loaded,e.total||0);r.onProgress?.(t)}:void 0};return{...await this.request(a),file:t[0],duration:Date.now()-s}}async download(e,t={}){this.checkDestroyed();const r=Date.now(),s=new n.DownloadProgressCalculator,o={method:"GET",url:e,responseType:"blob",...t||{},onDownloadProgress:t.onProgress?e=>{const r=s.calculate(e.loaded,e.total||0,t.filename);t.onProgress?.(r)}:void 0},i=await this.request(o);let a=t.filename;a||(a=n.getFilenameFromResponse(i.headers)||n.getFilenameFromURL(i.config.url||e)||"download");const c=i.data?.type||n.getMimeTypeFromFilename(a);let u;return!1!==t.autoSave&&typeof window<"u"&&(n.saveFileToLocal(i.data,a),u=URL.createObjectURL(i.data)),{data:i.data,filename:a,size:i.data.size,type:c,duration:Date.now()-r,url:u}}getPerformanceStats(){return this.monitor.getStats()}getRecentMetrics(e){return this.monitor.getRecentMetrics(e)}getSlowRequests(){return this.monitor.getSlowRequests()}getFailedRequests(){return this.monitor.getFailedRequests()}enableMonitoring(){this.monitor.enable()}disableMonitoring(){this.monitor.disable()}getPriorityQueueStats(){return this.priorityQueue.getStats()}getConnectionPoolStats(){return this.requestPool.getStats()}getConnectionDetails(){return this.requestPool.getConnectionDetails()}exportMetrics(){return{performance:this.monitor.exportMetrics(),priorityQueue:this.priorityQueue.getStats(),connectionPool:this.requestPool.getStats(),concurrency:this.concurrencyManager.getStatus(),cache:this.cacheManager.getStats?this.cacheManager.getStats():null}}setPriority(e,t){return{...e,priority:t}}destroy(){if(this.isDestroyed)return;this.isDestroyed=!0,this.cancelManager.cancelAll("Client destroyed"),this.cacheManager.clear(),this.concurrencyManager.cancelQueue("Client destroyed"),this.priorityQueue.destroy(),this.requestPool.destroy(),this.monitor.clear(),this.interceptors.request.clear(),this.interceptors.response.clear(),this.interceptors.error.clear();const e=this.cacheManager;e&&"function"==typeof e.destroy&&e.destroy(),this.adapter=null,this.retryManager=null,this.cancelManager=null,this.cacheManager=null,this.concurrencyManager=null,this.monitor=null,this.priorityQueue=null,this.requestPool=null}checkDestroyed(){if(this.isDestroyed)throw new Error("HttpClient has been destroyed")}};
//# sourceMappingURL=client.cjs.map
