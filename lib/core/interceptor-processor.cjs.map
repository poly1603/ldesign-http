{"version":3,"file":"interceptor-processor.cjs","sources":["../../src/core/interceptor-processor.ts"],"sourcesContent":["/**\r\n * 拦截器处理器模块\r\n * \r\n * 负责处理请求、响应和错误拦截器链\r\n */\r\n\r\nimport type {\r\n  ErrorInterceptor,\r\n  HttpError,\r\n  InterceptorManager,\r\n  RequestConfig,\r\n  RequestInterceptor,\r\n  ResponseData,\r\n  ResponseInterceptor,\r\n} from '../types'\r\nimport { InterceptorManagerImpl } from '../interceptors/manager'\r\n\r\n/**\r\n * 拦截器处理器配置\r\n */\r\nexport interface InterceptorProcessorConfig {\r\n  /** 请求拦截器管理器 */\r\n  requestInterceptors: InterceptorManager<RequestInterceptor>\r\n  /** 响应拦截器管理器 */\r\n  responseInterceptors: InterceptorManager<ResponseInterceptor>\r\n  /** 错误拦截器管理器 */\r\n  errorInterceptors: InterceptorManager<ErrorInterceptor>\r\n}\r\n\r\n/**\r\n * 拦截器处理器\r\n * \r\n * 管理和执行拦截器链\r\n */\r\nexport class InterceptorProcessor {\r\n  private requestInterceptors: InterceptorManager<RequestInterceptor>\r\n  private responseInterceptors: InterceptorManager<ResponseInterceptor>\r\n  private errorInterceptors: InterceptorManager<ErrorInterceptor>\r\n\r\n  constructor(config?: InterceptorProcessorConfig) {\r\n    this.requestInterceptors = config?.requestInterceptors || new InterceptorManagerImpl<RequestInterceptor>()\r\n    this.responseInterceptors = config?.responseInterceptors || new InterceptorManagerImpl<ResponseInterceptor>()\r\n    this.errorInterceptors = config?.errorInterceptors || new InterceptorManagerImpl<ErrorInterceptor>()\r\n  }\r\n\r\n  /**\r\n   * 处理请求拦截器\r\n   */\r\n  async processRequest(config: RequestConfig): Promise<RequestConfig> {\r\n    let processedConfig = config\r\n\r\n    const interceptors = (\r\n      this.requestInterceptors as InterceptorManagerImpl<RequestInterceptor>\r\n    ).getInterceptors()\r\n\r\n    for (const interceptor of interceptors) {\r\n      try {\r\n        processedConfig = await interceptor.fulfilled(processedConfig)\r\n      } catch (error) {\r\n        if (interceptor.rejected) {\r\n          throw await interceptor.rejected(error as HttpError)\r\n        }\r\n        throw error\r\n      }\r\n    }\r\n\r\n    return processedConfig\r\n  }\r\n\r\n  /**\r\n   * 处理响应拦截器\r\n   */\r\n  async processResponse<T>(response: ResponseData<T>): Promise<ResponseData<T>> {\r\n    let processedResponse = response as ResponseData<unknown>\r\n\r\n    const interceptors = (\r\n      this.responseInterceptors as InterceptorManagerImpl<ResponseInterceptor>\r\n    ).getInterceptors()\r\n\r\n    for (const interceptor of interceptors) {\r\n      try {\r\n        processedResponse = await interceptor.fulfilled(processedResponse)\r\n      } catch (error) {\r\n        if (interceptor.rejected) {\r\n          throw await interceptor.rejected(error as HttpError)\r\n        }\r\n        throw error\r\n      }\r\n    }\r\n\r\n    return processedResponse as ResponseData<T>\r\n  }\r\n\r\n  /**\r\n   * 处理错误拦截器\r\n   */\r\n  async processError(error: HttpError): Promise<HttpError> {\r\n    let processedError = error\r\n\r\n    const interceptors = (\r\n      this.errorInterceptors as InterceptorManagerImpl<ErrorInterceptor>\r\n    ).getInterceptors()\r\n\r\n    for (const interceptor of interceptors) {\r\n      try {\r\n        processedError = await interceptor.fulfilled(processedError)\r\n      } catch (err) {\r\n        processedError = err as HttpError\r\n      }\r\n    }\r\n\r\n    return processedError\r\n  }\r\n\r\n  /**\r\n   * 添加请求拦截器\r\n   */\r\n  addRequestInterceptor(\r\n    fulfilled: (config: RequestConfig) => RequestConfig | Promise<RequestConfig>,\r\n    rejected?: (error: HttpError) => HttpError | Promise<HttpError>,\r\n  ): number {\r\n    return this.requestInterceptors.use(fulfilled, rejected)\r\n  }\r\n\r\n  /**\r\n   * 添加响应拦截器\r\n   */\r\n  addResponseInterceptor<T = any>(\r\n    fulfilled: (response: ResponseData<T>) => ResponseData<T> | Promise<ResponseData<T>>,\r\n    rejected?: (error: HttpError) => HttpError | Promise<HttpError>,\r\n  ): number {\r\n    return this.responseInterceptors.use(fulfilled as ResponseInterceptor, rejected)\r\n  }\r\n\r\n  /**\r\n   * 添加错误拦截器\r\n   */\r\n  addErrorInterceptor(\r\n    fulfilled: (error: HttpError) => HttpError | Promise<HttpError>,\r\n    rejected?: (error: HttpError) => HttpError | Promise<HttpError>,\r\n  ): number {\r\n    return this.errorInterceptors.use(fulfilled, rejected)\r\n  }\r\n\r\n  /**\r\n   * 移除请求拦截器\r\n   */\r\n  removeRequestInterceptor(id: number): void {\r\n    this.requestInterceptors.eject(id)\r\n  }\r\n\r\n  /**\r\n   * 移除响应拦截器\r\n   */\r\n  removeResponseInterceptor(id: number): void {\r\n    this.responseInterceptors.eject(id)\r\n  }\r\n\r\n  /**\r\n   * 移除错误拦截器\r\n   */\r\n  removeErrorInterceptor(id: number): void {\r\n    this.errorInterceptors.eject(id)\r\n  }\r\n\r\n  /**\r\n   * 清空所有请求拦截器\r\n   */\r\n  clearRequestInterceptors(): void {\r\n    (this.requestInterceptors as InterceptorManagerImpl<RequestInterceptor>).clear()\r\n  }\r\n\r\n  /**\r\n   * 清空所有响应拦截器\r\n   */\r\n  clearResponseInterceptors(): void {\r\n    (this.responseInterceptors as InterceptorManagerImpl<ResponseInterceptor>).clear()\r\n  }\r\n\r\n  /**\r\n   * 清空所有错误拦截器\r\n   */\r\n  clearErrorInterceptors(): void {\r\n    (this.errorInterceptors as InterceptorManagerImpl<ErrorInterceptor>).clear()\r\n  }\r\n\r\n  /**\r\n   * 清空所有拦截器\r\n   */\r\n  clearAll(): void {\r\n    this.clearRequestInterceptors()\r\n    this.clearResponseInterceptors()\r\n    this.clearErrorInterceptors()\r\n  }\r\n\r\n  /**\r\n   * 获取拦截器管理器\r\n   */\r\n  getInterceptors() {\r\n    return {\r\n      request: this.requestInterceptors,\r\n      response: this.responseInterceptors,\r\n      error: this.errorInterceptors,\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 获取拦截器统计\r\n   */\r\n  getStats() {\r\n    return {\r\n      request: (this.requestInterceptors as InterceptorManagerImpl<RequestInterceptor>).getInterceptors().length,\r\n      response: (this.responseInterceptors as InterceptorManagerImpl<ResponseInterceptor>).getInterceptors().length,\r\n      error: (this.errorInterceptors as InterceptorManagerImpl<ErrorInterceptor>).getInterceptors().length,\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 创建拦截器链\r\n   */\r\n  createChain<T>(\r\n    request: RequestConfig,\r\n    adapter: (config: RequestConfig) => Promise<ResponseData<T>>,\r\n  ): Promise<ResponseData<T>> {\r\n    return new Promise((resolve, reject) => {\r\n      void (async () => {\r\n        try {\r\n          // 处理请求拦截器\r\n          const processedConfig = await this.processRequest(request)\r\n\r\n          // 执行适配器请求\r\n          let response: ResponseData<T>\r\n          try {\r\n            response = await adapter(processedConfig)\r\n          } catch (error) {\r\n            // 处理错误拦截器\r\n            const processedError = await this.processError(error as HttpError)\r\n            reject(processedError)\r\n            return\r\n          }\r\n\r\n          // 处理响应拦截器\r\n          const processedResponse = await this.processResponse(response)\r\n          resolve(processedResponse)\r\n        } catch (error) {\r\n          // 处理任何拦截器中的错误\r\n          const processedError = await this.processError(error as HttpError)\r\n          reject(processedError)\r\n        }\r\n      })()\r\n    })\r\n  }\r\n\r\n  /**\r\n   * 克隆拦截器处理器\r\n   */\r\n  clone(): InterceptorProcessor {\r\n    const cloned = new InterceptorProcessor()\r\n    \r\n    // 复制请求拦截器\r\n    const requestInterceptors = (this.requestInterceptors as InterceptorManagerImpl<RequestInterceptor>).getInterceptors()\r\n    requestInterceptors.forEach(interceptor => {\r\n      cloned.addRequestInterceptor(interceptor.fulfilled, interceptor.rejected)\r\n    })\r\n\r\n    // 复制响应拦截器\r\n    const responseInterceptors = (this.responseInterceptors as InterceptorManagerImpl<ResponseInterceptor>).getInterceptors()\r\n    responseInterceptors.forEach(interceptor => {\r\n      cloned.addResponseInterceptor(interceptor.fulfilled, interceptor.rejected)\r\n    })\r\n\r\n    // 复制错误拦截器\r\n    const errorInterceptors = (this.errorInterceptors as InterceptorManagerImpl<ErrorInterceptor>).getInterceptors()\r\n    errorInterceptors.forEach(interceptor => {\r\n      cloned.addErrorInterceptor(interceptor.fulfilled, interceptor.rejected)\r\n    })\r\n\r\n    return cloned\r\n  }\r\n}\r\n\r\n/**\r\n * 创建拦截器处理器\r\n */\r\nexport function createInterceptorProcessor(\r\n  config?: InterceptorProcessorConfig,\r\n): InterceptorProcessor {\r\n  return new InterceptorProcessor(config)\r\n}\r\n\r\n/**\r\n * 创建组合拦截器\r\n * \r\n * 将多个拦截器组合成一个\r\n */\r\nexport function composeInterceptors<T>(\r\n  ...interceptors: Array<(value: T) => T | Promise<T>>\r\n): (value: T) => Promise<T> {\r\n  return async (value: T): Promise<T> => {\r\n    let result = value\r\n    \r\n    for (const interceptor of interceptors) {\r\n      result = await interceptor(result)\r\n    }\r\n    \r\n    return result\r\n  }\r\n}\r\n\r\n/**\r\n * 创建条件拦截器\r\n * \r\n * 根据条件决定是否执行拦截器\r\n */\r\nexport function conditionalInterceptor<T>(\r\n  condition: (value: T) => boolean | Promise<boolean>,\r\n  interceptor: (value: T) => T | Promise<T>,\r\n): (value: T) => Promise<T> {\r\n  return async (value: T): Promise<T> => {\r\n    const shouldIntercept = await condition(value)\r\n    \r\n    if (shouldIntercept) {\r\n      return interceptor(value)\r\n    }\r\n    \r\n    return value\r\n  }\r\n}\r\n\r\n/**\r\n * 创建缓存拦截器\r\n */\r\nexport function createCacheInterceptor(\r\n  cache: Map<string, any>,\r\n  keyGenerator: (config: RequestConfig) => string,\r\n): {\r\n  request: (config: RequestConfig) => RequestConfig\r\n  response: <T>(response: ResponseData<T>) => ResponseData<T>\r\n} {\r\n  return {\r\n    request: (config: RequestConfig) => {\r\n      const key = keyGenerator(config)\r\n      const cached = cache.get(key)\r\n      \r\n      if (cached) {\r\n        // 标记为从缓存返回\r\n        config.fromCache = true\r\n        config.cachedResponse = cached\r\n      }\r\n      \r\n      return config\r\n    },\r\n    response: <T>(response: ResponseData<T>) => {\r\n      if (!response.config.fromCache) {\r\n        const key = keyGenerator(response.config)\r\n        cache.set(key, response)\r\n      }\r\n      \r\n      return response\r\n    },\r\n  }\r\n}\r\n\r\n/**\r\n * 创建重试拦截器\r\n */\r\nexport function createRetryInterceptor(\r\n  maxRetries: number = 3,\r\n  retryDelay: number = 1000,\r\n  shouldRetry?: (error: HttpError) => boolean,\r\n): (error: HttpError) => Promise<never> {\r\n  return async (error: HttpError): Promise<never> => {\r\n    const config = error.config\r\n    \r\n    if (!config) {\r\n      throw error\r\n    }\r\n    \r\n    // 检查是否应该重试\r\n    if (shouldRetry && !shouldRetry(error)) {\r\n      throw error\r\n    }\r\n    \r\n    // 获取或初始化重试计数\r\n    const retryCount = ((config as any).retryCount ?? 0) + 1\r\n    \r\n    if (retryCount > maxRetries) {\r\n      throw error\r\n    }\r\n    \r\n    // 更新重试计数\r\n    (config as any).retryCount = retryCount\r\n    \r\n    // 等待一段时间后重试\r\n    await new Promise(resolve => setTimeout(resolve, retryDelay * retryCount))\r\n    \r\n    // 重新发起请求\r\n    throw error // 这里实际应该重新发起请求，但需要访问到HTTP客户端\r\n  }\r\n}\r\n\r\n/**\r\n * 创建日志拦截器\r\n */\r\nexport function createLoggingInterceptor(\r\n  logger: {\r\n    log: (message: string, data?: any) => void\r\n    error: (message: string, error?: any) => void\r\n  } = console,\r\n): {\r\n  request: (config: RequestConfig) => RequestConfig\r\n  response: <T>(response: ResponseData<T>) => ResponseData<T>\r\n  error: (error: HttpError) => Promise<never>\r\n} {\r\n  return {\r\n    request: (config: RequestConfig) => {\r\n      logger.log(`[Request] ${config.method} ${config.url}`, config)\r\n      return config\r\n    },\r\n    response: <T>(response: ResponseData<T>) => {\r\n      logger.log(\r\n        `[Response] ${response.config.method} ${response.config.url} - ${response.status}`,\r\n        response,\r\n      )\r\n      return response\r\n    },\r\n    error: async (error: HttpError) => {\r\n      logger.error(\r\n        `[Error] ${error.config?.method} ${error.config?.url} - ${error.message}`,\r\n        error,\r\n      )\r\n      throw error\r\n    },\r\n  }\r\n}"],"names":["InterceptorProcessor","constructor","config","this","requestInterceptors","InterceptorManagerImpl","responseInterceptors","errorInterceptors","processRequest","processedConfig","interceptors","getInterceptors","interceptor","fulfilled","error","rejected","processResponse","response","processedResponse","processError","processedError","err","addRequestInterceptor","use","addResponseInterceptor","addErrorInterceptor","removeRequestInterceptor","id","eject","removeResponseInterceptor","removeErrorInterceptor","clearRequestInterceptors","clear","clearResponseInterceptors","clearErrorInterceptors","clearAll","request","getStats","length","createChain","adapter","Promise","resolve","reject","clone","cloned","forEach","result","value","condition","async","cache","keyGenerator","key","cached","get","fromCache","cachedResponse","set","logger","console","log","method","url","status","message","maxRetries","retryDelay","shouldRetry","retryCount","setTimeout"],"mappings":"gEAkCaA,EAKX,WAAAC,CAAYC,GACVC,KAAKC,oBAAsBF,GAAQE,qBAAuB,IAAIC,EAAAA,uBAC9DF,KAAKG,qBAAuBJ,GAAQI,sBAAwB,IAAID,EAAAA,uBAChEF,KAAKI,kBAAoBL,GAAQK,mBAAqB,IAAIF,EAAAA,sBAC5D,CAKA,oBAAMG,CAAeN,GACnB,IAAIO,EAAkBP,EAEtB,MAAMQ,EACJP,KAAKC,oBACLO,kBAEF,UAAWC,KAAeF,EACxB,IACED,QAAwBG,EAAYC,UAAUJ,EAChD,CAAA,MAASK,GACP,MAAIF,EAAYG,eACFH,EAAYG,SAASD,GAE7BA,CACR,CAGF,OAAOL,CACT,CAKA,qBAAMO,CAAmBC,GACvB,IAAIC,EAAoBD,EAExB,MAAMP,EACJP,KAAKG,qBACLK,kBAEF,IAAA,MAAWC,KAAeF,EACxB,IACEQ,QAA0BN,EAAYC,UAAUK,EAClD,OAASJ,GACP,MAAIF,EAAYG,eACFH,EAAYG,SAASD,GAE7BA,CACR,CAGF,OAAOI,CACT,CAKA,kBAAMC,CAAaL,GACjB,IAAIM,EAAiBN,EAErB,MAAMJ,EACJP,KAAKI,kBACLI,kBAEF,IAAA,MAAWC,KAAeF,EACxB,IACEU,QAAuBR,EAAYC,UAAUO,EAC/C,CAAA,MAASC,GACPD,EAAiBC,CACnB,CAGF,OAAOD,CACT,CAKA,qBAAAE,CACET,EACAE,GAEA,OAAOZ,KAAKC,oBAAoBmB,IAAIV,EAAWE,EACjD,CAKA,sBAAAS,CACEX,EACAE,GAEA,OAAOZ,KAAKG,qBAAqBiB,IAAIV,EAAkCE,EACzE,CAKA,mBAAAU,CACEZ,EACAE,GAEA,OAAOZ,KAAKI,kBAAkBgB,IAAIV,EAAWE,EAC/C,CAKA,wBAAAW,CAAyBC,GACvBxB,KAAKC,oBAAoBwB,MAAMD,EACjC,CAKA,yBAAAE,CAA0BF,GACxBxB,KAAKG,qBAAqBsB,MAAMD,EAClC,CAKA,sBAAAG,CAAuBH,GACrBxB,KAAKI,kBAAkBqB,MAAMD,EAC/B,CAKA,wBAAAI,GACG5B,KAAKC,oBAAmE4B,OAC3E,CAKA,yBAAAC,GACG9B,KAAKG,qBAAqE0B,OAC7E,CAKA,sBAAAE,GACG/B,KAAKI,kBAA+DyB,OACvE,CAKA,QAAAG,GACEhC,KAAK4B,2BACL5B,KAAK8B,4BACL9B,KAAK+B,wBACP,CAKA,eAAAvB,GACE,MAAO,CACLyB,QAASjC,KAAKC,oBACda,SAAUd,KAAKG,qBACfQ,MAAOX,KAAKI,kBAEhB,CAKA,QAAA8B,GACE,MAAO,CACLD,QAAUjC,KAAKC,oBAAmEO,kBAAkB2B,OACpGrB,SAAWd,KAAKG,qBAAqEK,kBAAkB2B,OACvGxB,MAAQX,KAAKI,kBAA+DI,kBAAkB2B,OAElG,CAKA,WAAAC,CACEH,EACAI,GAEA,OAAO,IAAIC,QAAQ,CAACC,EAASC,KAAU,WAEnC,IAEE,MAAMlC,QAAwBN,KAAKK,eAAe4B,GAGlD,IAAInB,EACJ,IACEA,QAAiBuB,EAAQ/B,EAC3B,CAAA,MAASK,GAEP,MAAMM,QAAuBjB,KAAKgB,aAAaL,GAE/C,YADA6B,EAAOvB,EAET,CAGA,MAAMF,QAA0Bf,KAAKa,gBAAgBC,GACrDyB,EAAQxB,EACV,CAAA,MAASJ,GAEP,MAAMM,QAAuBjB,KAAKgB,aAAaL,GAC/C6B,EAAOvB,EACT,CACF,EAzBqC,IA2BzC,CAKA,KAAAwB,GACE,MAAMC,EAAS,IAAI7C,EAInB,OAD6BG,KAAKC,oBAAmEO,kBACjFmC,QAAQlC,IAC1BiC,EAAOvB,sBAAsBV,EAAYC,UAAWD,EAAYG,YAIpCZ,KAAKG,qBAAqEK,kBACnFmC,QAAQlC,IAC3BiC,EAAOrB,uBAAuBZ,EAAYC,UAAWD,EAAYG,YAIxCZ,KAAKI,kBAA+DI,kBAC7EmC,QAAQlC,IACxBiC,EAAOpB,oBAAoBb,EAAYC,UAAWD,EAAYG,YAGzD8B,CACT,yEAkBGnC,GAEH,iBACE,IAAIqC,EAASC,EAEb,IAAA,MAAWpC,KAAeF,EACxBqC,QAAenC,EAAYmC,GAG7B,OAAOA,EAEX,iCAOM,SACJE,EACArC,GAEA,OAAOsC,eACyBD,EAAUD,GAG/BpC,EAAYoC,GAGdA,CAEX,0CAMEG,EACAC,GAKA,MAAO,CACLhB,QAAUlC,IACR,MAAMmD,EAAMD,EAAalD,GACnBoD,EAASH,EAAMI,IAAIF,GAEzB,OAAIC,IAEFpD,EAAOsD,WAAY,EACnBtD,EAAOuD,eAAiBH,GAGnBpD,GAETe,SAAcA,IACZ,IAAKA,EAASf,OAAOsD,UAAW,CAC9B,MAAMH,EAAMD,EAAanC,EAASf,QAClCiD,EAAMO,IAAIL,EAAKpC,EACjB,CAEA,OAAOA,GAGb,8CA5EEf,GAEA,OAAO,IAAIF,EAAqBE,EAClC,mCAoHM,SACJyD,EAGIC,SAMJ,MAAO,CACLxB,QAAUlC,IACRyD,EAAOE,IAAI,aAAa3D,EAAO4D,UAAU5D,EAAO6D,MAAO7D,GAChDA,GAETe,SAAcA,IACZ0C,EAAOE,IACL,cAAc5C,EAASf,OAAO4D,UAAU7C,EAASf,OAAO6D,SAAS9C,EAAS+C,SAC1E/C,GAEKA,GAETH,MAAOoC,UACL,MAAAS,EAAO7C,MACL,WAAWA,EAAMZ,QAAQ4D,UAAUhD,EAAMZ,QAAQ6D,SAASjD,EAAMmD,UAChEnD,GAEIA,GAGZ,iCApEM,SACJoD,EAAqB,EACrBC,EAAqB,IACrBC,GAEA,OAAOlB,UACL,MAAMhD,EAASY,EAAMZ,OAOrB,IALKA,GAKDkE,IAAgBA,EAAYtD,GAC9B,MAAMA,EAIR,MAAMuD,GAAenE,EAAemE,YAAc,GAAK,EAEvD,MAAIA,EAAaH,IAKhBhE,EAAemE,WAAaA,QAGvB,IAAI5B,QAAQC,GAAW4B,WAAW5B,EAASyB,EAAaE,KAGxDvD,EAEV"}