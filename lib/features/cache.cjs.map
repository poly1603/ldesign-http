{"version":3,"file":"cache.cjs","sources":["../../src/features/cache.ts"],"sourcesContent":["/**\r\n * HTTP请求缓存功能 - 中间件层\r\n *\r\n * 注意：此文件提供缓存中间件功能，与 utils/cache.ts 的职责不同：\r\n * - features/cache.ts: 提供 HTTP 缓存中间件（用于拦截器）\r\n * - utils/cache.ts: 提供缓存管理器（用于 HTTP 客户端内部）\r\n *\r\n * 两者的接口定义略有不同，这是设计上的考虑。\r\n */\r\n\r\nexport interface CacheConfig {\r\n  /** 默认TTL(秒) */\r\n  defaultTTL: number\r\n  /** 最大缓存条目数 */\r\n  maxSize: number\r\n  /** 缓存键生成函数 */\r\n  keyGenerator?: (url: string, options: any) => string\r\n  /** 缓存存储适配器 */\r\n  storage?: CacheStorage\r\n  /** 是否启用压缩 */\r\n  enableCompression: boolean\r\n  /** 缓存策略 */\r\n  strategy: CacheStrategy\r\n}\r\n\r\nexport type CacheStrategy =\r\n  | 'memory'\r\n  | 'localStorage'\r\n  | 'sessionStorage'\r\n  | 'indexedDB'\r\n\r\nexport interface CacheItem {\r\n  data: any\r\n  timestamp: number\r\n  ttl: number\r\n  headers?: Record<string, string>\r\n  etag?: string\r\n  lastModified?: string\r\n  size: number\r\n}\r\n\r\nexport interface CacheStorage {\r\n  get: (key: string) => Promise<CacheItem | null>\r\n  set: (key: string, item: CacheItem) => Promise<void>\r\n  delete: (key: string) => Promise<boolean>\r\n  clear: () => Promise<void>\r\n  keys: () => Promise<string[]>\r\n  size: () => Promise<number>\r\n}\r\n\r\nexport interface CacheStats {\r\n  hits: number\r\n  misses: number\r\n  size: number\r\n  hitRate: number\r\n}\r\n\r\n/**\r\n * 内存缓存存储\r\n */\r\nexport class MemoryCacheStorage implements CacheStorage {\r\n  private cache = new Map<string, CacheItem>()\r\n  private maxSize: number\r\n\r\n  constructor(maxSize: number = 100) {\r\n    this.maxSize = maxSize\r\n  }\r\n\r\n  async get(key: string): Promise<CacheItem | null> {\r\n    const item = this.cache.get(key)\r\n    if (!item)\r\n      return null\r\n\r\n    // 检查是否过期\r\n    if (Date.now() > item.timestamp + item.ttl * 1000) {\r\n      this.cache.delete(key)\r\n      return null\r\n    }\r\n\r\n    return item\r\n  }\r\n\r\n  async set(key: string, item: CacheItem): Promise<void> {\r\n    // 如果超过最大大小，删除最旧的条目（LRU）\r\n    if (this.cache.size >= this.maxSize) {\r\n      const firstKey = this.cache.keys().next().value\r\n      if (firstKey) {\r\n        this.cache.delete(firstKey)\r\n      }\r\n    }\r\n\r\n    this.cache.set(key, item)\r\n  }\r\n\r\n  async delete(key: string): Promise<boolean> {\r\n    return this.cache.delete(key)\r\n  }\r\n\r\n  async clear(): Promise<void> {\r\n    this.cache.clear()\r\n  }\r\n\r\n  async keys(): Promise<string[]> {\r\n    return Array.from(this.cache.keys())\r\n  }\r\n\r\n  async size(): Promise<number> {\r\n    return this.cache.size\r\n  }\r\n}\r\n\r\n/**\r\n * LocalStorage 缓存存储\r\n */\r\nexport class LocalStorageCacheStorage implements CacheStorage {\r\n  private prefix: string\r\n\r\n  constructor(prefix: string = 'http_cache_') {\r\n    this.prefix = prefix\r\n  }\r\n\r\n  async get(key: string): Promise<CacheItem | null> {\r\n    try {\r\n      const data = localStorage.getItem(this.prefix + key)\r\n      if (!data)\r\n        return null\r\n\r\n      const item: CacheItem = JSON.parse(data)\r\n\r\n      // 检查是否过期\r\n      if (Date.now() > item.timestamp + item.ttl * 1000) {\r\n        await this.delete(key)\r\n        return null\r\n      }\r\n\r\n      return item\r\n    }\r\n    catch {\r\n      return null\r\n    }\r\n  }\r\n\r\n  async set(key: string, item: CacheItem): Promise<void> {\r\n    try {\r\n      localStorage.setItem(this.prefix + key, JSON.stringify(item))\r\n    }\r\n    catch {\r\n      // 存储空间不足时清理过期条目\r\n      await this.cleanup()\r\n      try {\r\n        localStorage.setItem(this.prefix + key, JSON.stringify(item))\r\n      }\r\n      catch {\r\n        // 仍然失败则忽略\r\n      }\r\n    }\r\n  }\r\n\r\n  async delete(key: string): Promise<boolean> {\r\n    const exists = localStorage.getItem(this.prefix + key) !== null\r\n    localStorage.removeItem(this.prefix + key)\r\n    return exists\r\n  }\r\n\r\n  async clear(): Promise<void> {\r\n    const keys = await this.keys()\r\n    keys.forEach(key => localStorage.removeItem(this.prefix + key))\r\n  }\r\n\r\n  async keys(): Promise<string[]> {\r\n    const keys: string[] = []\r\n    for (let i = 0; i < localStorage.length; i++) {\r\n      const key = localStorage.key(i)\r\n      if (key && key.startsWith(this.prefix)) {\r\n        keys.push(key.substring(this.prefix.length))\r\n      }\r\n    }\r\n    return keys\r\n  }\r\n\r\n  async size(): Promise<number> {\r\n    return (await this.keys()).length\r\n  }\r\n\r\n  private async cleanup(): Promise<void> {\r\n    const keys = await this.keys()\r\n    const now = Date.now()\r\n\r\n    for (const key of keys) {\r\n      const item = await this.get(key)\r\n      if (!item || now > item.timestamp + item.ttl * 1000) {\r\n        await this.delete(key)\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * HTTP缓存管理器\r\n */\r\nexport class HttpCacheManager {\r\n  private config: CacheConfig\r\n  private storage: CacheStorage\r\n  private stats: CacheStats = {\r\n    hits: 0,\r\n    misses: 0,\r\n    size: 0,\r\n    hitRate: 0,\r\n  }\r\n\r\n  constructor(config: Partial<CacheConfig> = {}) {\r\n    this.config = {\r\n      defaultTTL: 300, // 5分钟\r\n      maxSize: 100,\r\n      enableCompression: false,\r\n      strategy: 'memory',\r\n      ...config,\r\n    }\r\n\r\n    this.storage = this.createStorage()\r\n  }\r\n\r\n  private createStorage(): CacheStorage {\r\n    switch (this.config?.strategy) {\r\n      case 'localStorage':\r\n        return new LocalStorageCacheStorage()\r\n      case 'sessionStorage':\r\n        // 类似LocalStorage但使用sessionStorage\r\n        return new LocalStorageCacheStorage('session_http_cache_')\r\n      case 'memory':\r\n      default:\r\n        return new MemoryCacheStorage(this.config?.maxSize)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 生成缓存键\r\n   */\r\n  private generateKey(url: string, options: any): string {\r\n    if (this.config?.keyGenerator) {\r\n      return this.config?.keyGenerator(url, options)\r\n    }\r\n\r\n    // 默认键生成策略\r\n    const method = options.method || 'GET'\r\n    const params = options.params ? JSON.stringify(options.params) : ''\r\n    const headers = options.headers ? JSON.stringify(options.headers) : ''\r\n\r\n    return `${method}:${url}:${params}:${headers}`\r\n  }\r\n\r\n  /**\r\n   * 获取缓存\r\n   */\r\n  async get(url: string, options: any = {}): Promise<any | null> {\r\n    const key = this.generateKey(url, options)\r\n    const item = await this.storage.get(key)\r\n\r\n    if (item) {\r\n      this.stats.hits++\r\n      this.updateStats()\r\n      return item.data\r\n    }\r\n\r\n    this.stats.misses++\r\n    this.updateStats()\r\n    return null\r\n  }\r\n\r\n  /**\r\n   * 设置缓存\r\n   */\r\n  async set(\r\n    url: string,\r\n    options: any,\r\n    data: any,\r\n    ttl?: number,\r\n    headers?: Record<string, string>,\r\n  ): Promise<void> {\r\n    const key = this.generateKey(url, options)\r\n    const item: CacheItem = {\r\n      data,\r\n      timestamp: Date.now(),\r\n      ttl: ttl || this.config?.defaultTTL,\r\n      headers,\r\n      size: this.calculateSize(data),\r\n    }\r\n\r\n    await this.storage.set(key, item)\r\n    this.stats.size = await this.storage.size()\r\n  }\r\n\r\n  /**\r\n   * 删除缓存\r\n   */\r\n  async delete(url: string, options: any = {}): Promise<boolean> {\r\n    const key = this.generateKey(url, options)\r\n    const result = await this.storage.delete(key)\r\n    this.stats.size = await this.storage.size()\r\n    return result\r\n  }\r\n\r\n  /**\r\n   * 清空缓存\r\n   */\r\n  async clear(): Promise<void> {\r\n    await this.storage.clear()\r\n    this.stats.size = 0\r\n    this.stats.hits = 0\r\n    this.stats.misses = 0\r\n    this.stats.hitRate = 0\r\n  }\r\n\r\n  /**\r\n   * 获取缓存统计\r\n   */\r\n  getStats(): CacheStats {\r\n    return { ...this.stats }\r\n  }\r\n\r\n  /**\r\n   * 更新统计信息\r\n   */\r\n  private updateStats(): void {\r\n    const total = this.stats.hits + this.stats.misses\r\n    this.stats.hitRate = total > 0 ? this.stats.hits / total : 0\r\n  }\r\n\r\n  /**\r\n   * 计算数据大小\r\n   */\r\n  private calculateSize(data: any): number {\r\n    try {\r\n      return JSON.stringify(data).length\r\n    }\r\n    catch {\r\n      return 0\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 检查响应是否可缓存\r\n   */\r\n  static isCacheable(\r\n    method: string,\r\n    status: number,\r\n    headers: Record<string, string> = {},\r\n  ): boolean {\r\n    // 只缓存GET请求\r\n    if (method.toUpperCase() !== 'GET') {\r\n      return false\r\n    }\r\n\r\n    // 只缓存成功响应\r\n    if (status < 200 || status >= 300) {\r\n      return false\r\n    }\r\n\r\n    // 检查Cache-Control头\r\n    const cacheControl = headers['cache-control'] || headers['Cache-Control']\r\n    if (cacheControl) {\r\n      if (\r\n        cacheControl.includes('no-cache')\r\n        || cacheControl.includes('no-store')\r\n      ) {\r\n        return false\r\n      }\r\n    }\r\n\r\n    return true\r\n  }\r\n}\r\n\r\n/**\r\n * 创建HTTP缓存管理器\r\n */\r\nexport function createHttpCacheManager(\r\n  config?: Partial<CacheConfig>,\r\n): HttpCacheManager {\r\n  return new HttpCacheManager(config)\r\n}\r\n\r\n/**\r\n * 缓存中间件配置\r\n */\r\nexport interface CacheMiddlewareConfig {\r\n  enabled?: boolean\r\n  ttl?: number\r\n  methods?: string[]\r\n  keyGenerator?: (config: any) => string\r\n  storage?: CacheStorage\r\n}\r\n\r\n/**\r\n * 创建缓存中间件\r\n */\r\nexport function withCache(config: CacheMiddlewareConfig = {}) {\r\n  const cacheConfig = {\r\n    enabled: config.enabled ?? true,\r\n    ttl: config.ttl ?? 300000, // 5分钟\r\n    methods: config.methods ?? ['GET'],\r\n    keyGenerator: config.keyGenerator ?? ((cfg: any) => {\r\n      const method = cfg.method || 'GET'\r\n      const url = cfg.url || ''\r\n      const params = cfg.params ? JSON.stringify(cfg.params) : ''\r\n      return `${method}:${url}:${params}`\r\n    }),\r\n    storage: config.storage ?? new MemoryCacheStorage(),\r\n  }\r\n\r\n  return async function cacheMiddleware(requestConfig: any, next: () => Promise<any>) {\r\n    // 合并请求级别的缓存配置\r\n    const requestCacheConfig = requestConfig?.cache || {}\r\n    const finalConfig = {\r\n      enabled: requestCacheConfig.enabled ?? cacheConfig.enabled,\r\n      ttl: requestCacheConfig.ttl ?? cacheConfig.ttl,\r\n      methods: requestCacheConfig.methods ?? cacheConfig.methods,\r\n      keyGenerator: requestCacheConfig.keyGenerator ?? cacheConfig.keyGenerator,\r\n      storage: requestCacheConfig.storage ?? cacheConfig.storage,\r\n    }\r\n\r\n    if (!finalConfig.enabled || !finalConfig.methods.includes(requestConfig.method || 'GET')) {\r\n      return next()\r\n    }\r\n\r\n    // 生成缓存键\r\n    const key = finalConfig.keyGenerator(requestConfig)\r\n\r\n    try {\r\n      // 尝试从缓存获取\r\n      const cached = await finalConfig.storage.get(key)\r\n      if (cached && Date.now() - cached.timestamp < cached.ttl) {\r\n        return cached.data\r\n      }\r\n    }\r\n    catch (error) {\r\n      // 缓存读取错误，继续执行请求\r\n      console.warn('Cache read error:', error)\r\n    }\r\n\r\n    // 执行请求\r\n    const response = await next()\r\n\r\n    // 缓存响应\r\n    if (response && response.status >= 200 && response.status < 300) {\r\n      try {\r\n        await finalConfig.storage.set(key, {\r\n          data: response,\r\n          timestamp: Date.now(),\r\n          ttl: finalConfig.ttl,\r\n          size: JSON.stringify(response).length,\r\n        })\r\n      }\r\n      catch (error) {\r\n        // 缓存写入错误，不影响响应\r\n        console.warn('Cache write error:', error)\r\n      }\r\n    }\r\n\r\n    return response\r\n  }\r\n}\r\n\r\n/**\r\n * 全局HTTP缓存管理器实例\r\n */\r\nexport const globalHttpCacheManager = createHttpCacheManager()\r\n"],"names":["MemoryCacheStorage","constructor","maxSize","this","cache","Map","get","key","item","Date","now","timestamp","ttl","delete","set","size","firstKey","keys","next","value","clear","Array","from","LocalStorageCacheStorage","prefix","data","localStorage","getItem","JSON","parse","setItem","stringify","cleanup","exists","removeItem","forEach","i","length","startsWith","push","substring","HttpCacheManager","config","stats","hits","misses","hitRate","defaultTTL","enableCompression","strategy","storage","createStorage","generateKey","url","options","keyGenerator","method","params","headers","updateStats","calculateSize","result","getStats","total","isCacheable","status","toUpperCase","cacheControl","includes","createHttpCacheManager","globalHttpCacheManager","cacheConfig","enabled","methods","cfg","async","requestConfig","requestCacheConfig","finalConfig","cached","error","response"],"mappings":"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"}