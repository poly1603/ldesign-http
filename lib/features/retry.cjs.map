{"version":3,"file":"retry.cjs","sources":["../../src/features/retry.ts"],"sourcesContent":["/**\r\n * HTTP请求重试功能\r\n * 提供智能重试机制，支持指数退避、条件重试等\r\n */\r\n\r\nexport interface RetryConfig {\r\n  /** 最大重试次数 */\r\n  maxRetries: number\r\n  /** 初始延迟时间(ms) */\r\n  initialDelay: number\r\n  /** 最大延迟时间(ms) */\r\n  maxDelay: number\r\n  /** 退避倍数 */\r\n  backoffMultiplier: number\r\n  /** 是否启用抖动 */\r\n  enableJitter: boolean\r\n  /** 重试条件函数 */\r\n  shouldRetry?: (error: any, attempt: number) => boolean\r\n  /** 延迟计算函数 */\r\n  delayCalculator?: (attempt: number, config: RetryConfig) => number\r\n}\r\n\r\nexport interface RetryState {\r\n  attempt: number\r\n  totalDelay: number\r\n  errors: any[]\r\n  startTime: number\r\n}\r\n\r\nexport interface RetryResult<T> {\r\n  success: boolean\r\n  data?: T\r\n  error?: any\r\n  retryState: RetryState\r\n}\r\n\r\n/**\r\n * 默认重试配置\r\n */\r\nexport const DEFAULT_RETRY_CONFIG: RetryConfig = {\r\n  maxRetries: 3,\r\n  initialDelay: 1000,\r\n  maxDelay: 30000,\r\n  backoffMultiplier: 2,\r\n  enableJitter: true,\r\n  shouldRetry: (error: any, _attempt: number) => {\r\n    // 默认重试条件：网络错误、超时、5xx错误\r\n    if (error.code === 'NETWORK_ERROR' || error.code === 'TIMEOUT') {\r\n      return true\r\n    }\r\n    if (error.response && error.response.status >= 500) {\r\n      return true\r\n    }\r\n    return false\r\n  },\r\n}\r\n\r\n/**\r\n * 计算重试延迟时间\r\n */\r\nexport function calculateDelay(attempt: number, config: RetryConfig): number {\r\n  if (config.delayCalculator) {\r\n    return config.delayCalculator(attempt, config)\r\n  }\r\n\r\n  // 指数退避算法\r\n  let delay = config.initialDelay * config.backoffMultiplier ** (attempt - 1)\r\n\r\n  // 限制最大延迟\r\n  delay = Math.min(delay, config.maxDelay)\r\n\r\n  // 添加抖动\r\n  if (config.enableJitter) {\r\n    delay = delay * (0.5 + Math.random() * 0.5)\r\n  }\r\n\r\n  return Math.floor(delay)\r\n}\r\n\r\n/**\r\n * 等待指定时间\r\n */\r\nexport function delay(ms: number): Promise<void> {\r\n  return new Promise(resolve => setTimeout(resolve, ms))\r\n}\r\n\r\n/**\r\n * 重试执行器\r\n */\r\nexport class RetryExecutor {\r\n  private config: RetryConfig\r\n\r\n  constructor(config: Partial<RetryConfig> = {}) {\r\n    this.config = { ...DEFAULT_RETRY_CONFIG, ...config }\r\n  }\r\n\r\n  /**\r\n   * 执行带重试的异步操作\r\n   */\r\n  async execute<T>(operation: () => Promise<T>): Promise<RetryResult<T>> {\r\n    const state: RetryState = {\r\n      attempt: 0,\r\n      totalDelay: 0,\r\n      errors: [],\r\n      startTime: Date.now(),\r\n    }\r\n\r\n    while (state.attempt <= this.config?.maxRetries) {\r\n      state.attempt++\r\n\r\n      try {\r\n        const result = await operation()\r\n        return {\r\n          success: true,\r\n          data: result,\r\n          retryState: state,\r\n        }\r\n      }\r\n      catch (error) {\r\n        state.errors.push(error)\r\n\r\n        // 检查是否应该重试\r\n        const shouldRetry\r\n          = this.config?.shouldRetry?.(error, state.attempt) ?? true\r\n\r\n        if (state.attempt > this.config?.maxRetries || !shouldRetry) {\r\n          return {\r\n            success: false,\r\n            error,\r\n            retryState: state,\r\n          }\r\n        }\r\n\r\n        // 计算延迟时间并等待\r\n        const delayTime = calculateDelay(state.attempt, this.config)\r\n        state.totalDelay += delayTime\r\n        await delay(delayTime)\r\n      }\r\n    }\r\n\r\n    return {\r\n      success: false,\r\n      error: state.errors[state.errors.length - 1],\r\n      retryState: state,\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 更新配置\r\n   */\r\n  updateConfig(config: Partial<RetryConfig>): void {\r\n    this.config = { ...this.config, ...config }\r\n  }\r\n\r\n  /**\r\n   * 获取当前配置\r\n   */\r\n  getConfig(): RetryConfig {\r\n    return { ...this.config }\r\n  }\r\n}\r\n\r\n/**\r\n * 创建重试执行器\r\n */\r\nexport function createRetryExecutor(\r\n  config?: Partial<RetryConfig>,\r\n): RetryExecutor {\r\n  return new RetryExecutor(config)\r\n}\r\n\r\n/**\r\n * 重试装饰器\r\n */\r\nexport function retry(config?: Partial<RetryConfig>) {\r\n  return function (\r\n    _target: any,\r\n    _propertyKey: string,\r\n    descriptor: PropertyDescriptor,\r\n  ) {\r\n    const originalMethod = descriptor.value\r\n    const executor = createRetryExecutor(config)\r\n\r\n    descriptor.value = async function (...args: any[]) {\r\n      const result = await executor.execute(() =>\r\n        originalMethod.apply(this, args),\r\n      )\r\n      if (result.success) {\r\n        return result.data\r\n      }\r\n      else {\r\n        throw result.error\r\n      }\r\n    }\r\n\r\n    return descriptor\r\n  }\r\n}\r\n\r\n/**\r\n * 全局重试执行器实例\r\n */\r\nexport const globalRetryExecutor = createRetryExecutor()\r\n\r\n/**\r\n * 便捷的重试函数\r\n */\r\nexport async function retryOperation<T>(\r\n  operation: () => Promise<T>,\r\n  config?: Partial<RetryConfig>,\r\n): Promise<T> {\r\n  const executor = config ? createRetryExecutor(config) : globalRetryExecutor\r\n  const result = await executor.execute(operation)\r\n\r\n  if (result.success) {\r\n    return result.data!\r\n  }\r\n  else {\r\n    throw result.error\r\n  }\r\n}\r\n\r\n/**\r\n * 重试中间件配置\r\n */\r\nexport interface RetryMiddlewareConfig {\r\n  enabled?: boolean\r\n  maxAttempts?: number\r\n  delay?: number\r\n  backoffMultiplier?: number\r\n  shouldRetry?: (error: any, attempt: number) => boolean\r\n  condition?: (error: any) => boolean // 兼容测试中的condition属性\r\n  delayFn?: (attempt: number) => number\r\n}\r\n\r\n/**\r\n * 创建重试中间件\r\n */\r\nexport function withRetry(config: RetryMiddlewareConfig = {}) {\r\n  const retryConfig = {\r\n    enabled: config.enabled ?? true,\r\n    maxAttempts: config.maxAttempts ?? 3,\r\n    delay: config.delay ?? 1000,\r\n    backoffMultiplier: config.backoffMultiplier ?? 2,\r\n    delayFn: config.delayFn,\r\n    shouldRetry: config.shouldRetry ?? config.condition ?? ((error: any) => {\r\n      // 默认重试网络错误、超时错误和5xx服务器错误\r\n      if (error.code === 'NETWORK_ERROR' || error.code === 'TIMEOUT') {\r\n        return true\r\n      }\r\n      if (error.name === 'NetworkError' || error.isNetworkError) {\r\n        return true\r\n      }\r\n      if (error.response?.status >= 500 && error.response?.status < 600) {\r\n        return true\r\n      }\r\n      if (error.status >= 500 && error.status < 600) {\r\n        return true\r\n      }\r\n      // 不重试客户端错误（4xx）\r\n      return false\r\n    }),\r\n  }\r\n\r\n  return async function retryMiddleware(requestConfig: any, next: () => Promise<any>) {\r\n    // 合并请求级别的重试配置\r\n    const requestRetryConfig = requestConfig?.retry || {}\r\n    const finalConfig = {\r\n      enabled: requestRetryConfig.enabled ?? retryConfig.enabled,\r\n      maxAttempts: requestRetryConfig.maxAttempts ?? retryConfig.maxAttempts,\r\n      delay: requestRetryConfig.delay ?? retryConfig.delay,\r\n      backoffMultiplier: requestRetryConfig.backoffMultiplier ?? retryConfig.backoffMultiplier,\r\n      delayFn: requestRetryConfig.delayFn ?? retryConfig.delayFn,\r\n      shouldRetry: requestRetryConfig.shouldRetry ?? retryConfig.shouldRetry,\r\n    }\r\n\r\n    if (!finalConfig.enabled || finalConfig.maxAttempts <= 0) {\r\n      return next()\r\n    }\r\n\r\n    let lastError: any\r\n    let attempt = 0\r\n\r\n    while (attempt < finalConfig.maxAttempts) {\r\n      try {\r\n        attempt++\r\n        return await next()\r\n      }\n      catch (error) {\r\n        lastError = error\r\n\r\n        // 如果已经达到最大尝试次数，或者不应该重试，则抛出错误\r\n        const shouldRetry = finalConfig.shouldRetry.length === 1\r\n          ? finalConfig.shouldRetry(error)\r\n          : finalConfig.shouldRetry(error, attempt)\r\n\r\n        if (attempt >= finalConfig.maxAttempts || !shouldRetry) {\r\n          throw error\r\n        }\r\n\r\n        // 计算延迟时间\r\n        let delayTime: number\r\n        if (finalConfig.delayFn) {\r\n          delayTime = finalConfig.delayFn(attempt)\r\n        }\n        else {\r\n          delayTime = finalConfig.delay * finalConfig.backoffMultiplier ** (attempt - 1)\r\n        }\r\n        await delay(delayTime)\r\n      }\r\n    }\r\n\r\n    throw lastError\r\n  }\r\n}\r\n"],"names":["DEFAULT_RETRY_CONFIG","maxRetries","initialDelay","maxDelay","backoffMultiplier","enableJitter","shouldRetry","error","_attempt","code","response","status","calculateDelay","attempt","config","delayCalculator","delay","Math","min","random","floor","ms","Promise","resolve","setTimeout","RetryExecutor","constructor","this","execute","operation","state","totalDelay","errors","startTime","Date","now","success","data","retryState","push","delayTime","length","updateConfig","getConfig","createRetryExecutor","globalRetryExecutor","_target","_propertyKey","descriptor","originalMethod","value","executor","async","args","result","apply","retryConfig","enabled","maxAttempts","delayFn","condition","name","isNetworkError","requestConfig","next","requestRetryConfig","retry","finalConfig","lastError"],"mappings":"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"}