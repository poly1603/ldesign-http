{"version":3,"file":"websocket.cjs","sources":["../../src/features/websocket.ts"],"sourcesContent":["/**\r\n * WebSocket 连接状态\r\n */\r\nexport enum WebSocketStatus {\r\n  CONNECTING = 'connecting',\r\n  CONNECTED = 'connected',\r\n  DISCONNECTING = 'disconnecting',\r\n  DISCONNECTED = 'disconnected',\r\n  ERROR = 'error',\r\n}\r\n\r\n/**\r\n * WebSocket 消息类型\r\n */\r\nexport interface WebSocketMessage<T = any> {\r\n  type: string\r\n  data: T\r\n  timestamp?: number\r\n  id?: string\r\n}\r\n\r\n/**\r\n * WebSocket 客户端配置\r\n */\r\nexport interface WebSocketClientConfig {\r\n  /** WebSocket URL */\r\n  url: string\r\n  /** 子协议 */\r\n  protocols?: string | string[]\r\n  /** 自动重连 */\r\n  autoReconnect?: boolean\r\n  /** 重连延迟（毫秒） */\r\n  reconnectDelay?: number\r\n  /** 最大重连次数 */\r\n  maxReconnectAttempts?: number\r\n  /** 心跳间隔（毫秒） */\r\n  heartbeatInterval?: number\r\n  /** 心跳消息 */\r\n  heartbeatMessage?: any\r\n  /** 连接超时（毫秒） */\r\n  connectionTimeout?: number\r\n  /** 调试模式 */\r\n  debug?: boolean\r\n  /** 自定义请求头（仅 Node.js 环境） */\r\n  headers?: Record<string, string>\r\n}\r\n\r\n/**\r\n * WebSocket 事件���型\r\n */\r\nexport type WebSocketEventType =\r\n  | 'open'\r\n  | 'close'\r\n  | 'error'\r\n  | 'message'\r\n  | 'reconnect'\r\n  | 'reconnecting'\r\n  | 'reconnect_failed'\r\n\r\n/**\r\n * WebSocket 事件监听器\r\n */\r\nexport type WebSocketEventListener<T = any> = (data?: T) => void\r\n\r\n/**\r\n * WebSocket 客户端\r\n *\r\n * 提供 WebSocket 连接管理，支持自动重连、心跳检测、消息队列等功能\r\n *\r\n * @example\r\n * ```typescript\r\n * const wsClient = new WebSocketClient({\r\n *   url: 'ws://localhost:3000',\r\n *   autoReconnect: true,\r\n *   heartbeatInterval: 30000,\r\n * })\r\n *\r\n * // 监听消息\r\n * wsClient.on('message', (message) => {\r\n *   \r\n * })\r\n *\r\n * // 连接\r\n * await wsClient.connect()\r\n *\r\n * // 发送消息\r\n * wsClient.send({ type: 'chat', data: 'Hello' })\r\n *\r\n * // 断开连接\r\n * wsClient.disconnect()\r\n * ```\r\n */\r\nexport class WebSocketClient {\r\n  private config: Omit<Required<WebSocketClientConfig>, 'protocols'> & { protocols?: string | string[] }\r\n  private ws: WebSocket | null = null\r\n  private status: WebSocketStatus = WebSocketStatus.DISCONNECTED\r\n  private eventListeners: Map<WebSocketEventType, Set<WebSocketEventListener>> = new Map()\r\n  private messageQueue: any[] = []\r\n  private reconnectAttempts = 0\r\n  private reconnectTimer: ReturnType<typeof setTimeout> | null = null\r\n  private heartbeatTimer: ReturnType<typeof setInterval> | null = null\r\n  private connectionTimer: ReturnType<typeof setTimeout> | null = null\r\n\r\n  constructor(config: WebSocketClientConfig) {\r\n    this.config = {\r\n      url: config.url,\r\n      protocols: config.protocols,\r\n      autoReconnect: config.autoReconnect ?? true,\r\n      reconnectDelay: config.reconnectDelay ?? 3000,\r\n      maxReconnectAttempts: config.maxReconnectAttempts ?? 5,\r\n      heartbeatInterval: config.heartbeatInterval ?? 30000,\r\n      heartbeatMessage: config.heartbeatMessage ?? { type: 'ping' },\r\n      connectionTimeout: config.connectionTimeout ?? 10000,\r\n      debug: config.debug ?? false,\r\n      headers: config.headers || {},\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 连接 WebSocket\r\n   */\r\n  async connect(): Promise<void> {\r\n    if (this.status === WebSocketStatus.CONNECTED || this.status === WebSocketStatus.CONNECTING) {\r\n      this.log('Already connected or connecting')\r\n      return\r\n    }\r\n\r\n    return new Promise((resolve, reject) => {\r\n      this.status = WebSocketStatus.CONNECTING\r\n      this.log(`Connecting to ${this.config?.url}`)\r\n\r\n      try {\r\n        this.ws = new WebSocket(this.config?.url, this.config?.protocols)\r\n\r\n        // 连接超时处理\r\n        this.connectionTimer = setTimeout(() => {\r\n          if (this.status === WebSocketStatus.CONNECTING) {\r\n            this.ws?.close()\r\n            reject(new Error('Connection timeout'))\r\n          }\r\n        }, this.config?.connectionTimeout)\r\n\r\n        this.ws.onopen = () => {\r\n          if (this.connectionTimer) {\r\n            clearTimeout(this.connectionTimer)\r\n            this.connectionTimer = null\r\n          }\r\n\r\n          this.status = WebSocketStatus.CONNECTED\r\n          this.reconnectAttempts = 0\r\n          this.log('Connected')\r\n\r\n          // 启动心跳\r\n          this.startHeartbeat()\r\n\r\n          // 发送队列中的消息\r\n          this.flushMessageQueue()\r\n\r\n          // 触发 open 事件\r\n          this.emit('open')\r\n          resolve()\r\n        }\r\n\r\n        this.ws.onclose = (event) => {\r\n          this.log(`Disconnected: ${event.code} ${event.reason}`)\r\n          this.handleDisconnection(event.code, event.reason)\r\n        }\r\n\r\n        this.ws.onerror = (error) => {\r\n          this.log('Error:', error)\r\n          this.status = WebSocketStatus.ERROR\r\n          this.emit('error', error)\r\n          reject(error)\r\n        }\r\n\r\n        this.ws.onmessage = (event) => {\r\n          this.handleMessage(event.data)\r\n        }\r\n      }\r\n      catch (error) {\r\n        this.status = WebSocketStatus.ERROR\r\n        reject(error)\r\n      }\r\n    })\r\n  }\r\n\r\n  /**\r\n   * 断开连接\r\n   */\r\n  disconnect(code = 1000, reason = 'Normal closure'): void {\r\n    this.log(`Disconnecting: ${code} ${reason}`)\r\n\r\n    // 清除定时器\r\n    this.stopHeartbeat()\r\n    if (this.reconnectTimer) {\r\n      clearTimeout(this.reconnectTimer)\r\n      this.reconnectTimer = null\r\n    }\r\n    if (this.connectionTimer) {\r\n      clearTimeout(this.connectionTimer)\r\n      this.connectionTimer = null\r\n    }\r\n\r\n    // 关闭连接\r\n    if (this.ws) {\r\n      this.status = WebSocketStatus.DISCONNECTING\r\n      this.ws.close(code, reason)\r\n      this.ws = null\r\n    }\r\n\r\n    this.status = WebSocketStatus.DISCONNECTED\r\n    this.emit('close', { code, reason })\r\n  }\r\n\r\n  /**\r\n   * 发送消息\r\n   */\r\n  send(data: any): boolean {\r\n    if (this.status !== WebSocketStatus.CONNECTED) {\r\n      // 如果未连接，添加到队列\r\n      this.messageQueue.push(data)\r\n      this.log('Message queued (not connected)')\r\n      return false\r\n    }\r\n\r\n    try {\r\n      const message = typeof data === 'string' ? data : JSON.stringify(data)\r\n      this.ws?.send(message)\r\n      this.log('Message sent:', data)\r\n      return true\r\n    }\r\n    catch (error) {\r\n      this.log('Failed to send message:', error)\r\n      return false\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 监听事件\r\n   */\r\n  on<T = any>(event: WebSocketEventType, listener: WebSocketEventListener<T>): () => void {\r\n    if (!this.eventListeners.has(event)) {\r\n      this.eventListeners.set(event, new Set())\r\n    }\r\n    this.eventListeners.get(event)!.add(listener as WebSocketEventListener)\r\n\r\n    // 返回取消监听函数\r\n    return () => this.off(event, listener)\r\n  }\r\n\r\n  /**\r\n   * 取消监听\r\n   */\r\n  off(event: WebSocketEventType, listener: WebSocketEventListener): void {\r\n    const listeners = this.eventListeners.get(event)\r\n    if (listeners) {\r\n      listeners.delete(listener)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 监听一次事件\r\n   */\r\n  once<T = any>(event: WebSocketEventType, listener: WebSocketEventListener<T>): void {\r\n    const wrappedListener = (data?: T) => {\r\n      listener(data)\r\n      this.off(event, wrappedListener)\r\n    }\r\n    this.on(event, wrappedListener)\r\n  }\r\n\r\n  /**\r\n   * 获取连接状态\r\n   */\r\n  getStatus(): WebSocketStatus {\r\n    return this.status\r\n  }\r\n\r\n  /**\r\n   * 是否已连接\r\n   */\r\n  isConnected(): boolean {\r\n    return this.status === WebSocketStatus.CONNECTED\r\n  }\r\n\r\n  /**\r\n   * 获取队列大小\r\n   */\r\n  getQueueSize(): number {\r\n    return this.messageQueue.length\r\n  }\r\n\r\n  /**\r\n   * 清空消息队列\r\n   */\r\n  clearQueue(): void {\r\n    this.messageQueue = []\r\n  }\r\n\r\n  /**\r\n   * 获取重连次数\r\n   */\r\n  getReconnectAttempts(): number {\r\n    return this.reconnectAttempts\r\n  }\r\n\r\n  /**\r\n   * 更新配置\r\n   */\r\n  updateConfig(config: Partial<WebSocketClientConfig>): void {\r\n    Object.assign(this.config, config)\r\n\r\n    // 如果已连接且修改了心跳配置，重新启动心跳\r\n    if (this.isConnected() && (config.heartbeatInterval || config.heartbeatMessage)) {\r\n      this.stopHeartbeat()\r\n      this.startHeartbeat()\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 获取原生 WebSocket 实例\r\n   */\r\n  getWebSocket(): WebSocket | null {\r\n    return this.ws\r\n  }\r\n\r\n  /**\r\n   * 触发事件\r\n   */\r\n  private emit(event: WebSocketEventType, data?: any): void {\r\n    const listeners = this.eventListeners.get(event)\r\n    if (listeners) {\r\n      listeners.forEach((listener) => {\r\n        try {\r\n          listener(data)\r\n        }\r\n        catch (error) {\r\n          this.log('Error in event listener:', error)\r\n        }\r\n      })\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 处理消息\r\n   */\r\n  private handleMessage(data: string | ArrayBuffer | Blob): void {\r\n    try {\r\n      let message: any\r\n      if (typeof data === 'string') {\r\n        message = JSON.parse(data)\r\n      }\r\n      else {\r\n        // 处理二进制数据\r\n        message = data\r\n      }\r\n\r\n      this.log('Message received:', message)\r\n      this.emit('message', message)\r\n    }\r\n    catch (error) {\r\n      this.log('Failed to parse message:', error)\r\n      this.emit('message', data)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 处理断开连接\r\n   */\r\n  private handleDisconnection(code: number, reason: string): void {\r\n    this.stopHeartbeat()\r\n    this.status = WebSocketStatus.DISCONNECTED\r\n\r\n    // 触发 close 事件\r\n    this.emit('close', { code, reason })\r\n\r\n    // 自动重连\r\n    if (this.config?.autoReconnect && this.reconnectAttempts < this.config?.maxReconnectAttempts) {\r\n      this.reconnect()\r\n    }\r\n    else if (this.reconnectAttempts >= this.config?.maxReconnectAttempts) {\r\n      this.log('Max reconnect attempts reached')\r\n      this.emit('reconnect_failed')\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 重连\r\n   */\r\n  private reconnect(): void {\r\n    this.reconnectAttempts++\r\n    this.log(`Reconnecting... (attempt ${this.reconnectAttempts}/${this.config?.maxReconnectAttempts})`)\r\n\r\n    this.emit('reconnecting', { attempts: this.reconnectAttempts })\r\n\r\n    this.reconnectTimer = setTimeout(async () => {\r\n      try {\r\n        await this.connect()\r\n        this.log('Reconnected successfully')\r\n        this.emit('reconnect')\r\n      }\r\n      catch (error) {\r\n        this.log('Reconnect failed:', error)\r\n        // handleDisconnection 会处理下一次重连\r\n      }\r\n    }, this.config?.reconnectDelay * this.reconnectAttempts)\r\n  }\r\n\r\n  /**\r\n   * 启动心跳\r\n   */\r\n  private startHeartbeat(): void {\r\n    if (this.config?.heartbeatInterval <= 0) {\r\n      return\r\n    }\r\n\r\n    this.heartbeatTimer = setInterval(() => {\r\n      if (this.isConnected()) {\r\n        this.send(this.config?.heartbeatMessage)\r\n        this.log('Heartbeat sent')\r\n      }\r\n    }, this.config?.heartbeatInterval)\r\n  }\r\n\r\n  /**\r\n   * 停止心跳\r\n   */\r\n  private stopHeartbeat(): void {\r\n    if (this.heartbeatTimer) {\r\n      clearInterval(this.heartbeatTimer)\r\n      this.heartbeatTimer = null\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 刷新消息队列\r\n   */\r\n  private flushMessageQueue(): void {\r\n    if (this.messageQueue.length === 0) {\r\n      return\r\n    }\r\n\r\n    this.log(`Flushing ${this.messageQueue.length} queued messages`)\r\n    const queue = [...this.messageQueue]\r\n    this.messageQueue = []\r\n\r\n    queue.forEach((message) => {\r\n      this.send(message)\r\n    })\r\n  }\r\n\r\n  /**\r\n   * 日志输出\r\n   */\r\n  private log(..._args: any[]): void {\r\n    if (this.config?.debug) {\r\n      // console.log('[WebSocket]', ...args)\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * 创建 WebSocket 客户端\r\n */\r\nexport function createWebSocketClient(config: WebSocketClientConfig): WebSocketClient {\r\n  return new WebSocketClient(config)\r\n}\r\n"],"names":["WebSocketStatus","CONNECTING","CONNECTED","DISCONNECTING","DISCONNECTED","ERROR","WebSocketClient","constructor","config","this","ws","status","eventListeners","Map","messageQueue","reconnectAttempts","reconnectTimer","heartbeatTimer","connectionTimer","url","protocols","autoReconnect","reconnectDelay","maxReconnectAttempts","heartbeatInterval","heartbeatMessage","type","connectionTimeout","debug","headers","connect","Promise","resolve","reject","log","WebSocket","setTimeout","close","Error","onopen","clearTimeout","startHeartbeat","flushMessageQueue","emit","onclose","event","code","reason","handleDisconnection","onerror","error","onmessage","handleMessage","data","disconnect","stopHeartbeat","send","push","message","JSON","stringify","on","listener","has","set","Set","get","add","off","listeners","delete","once","wrappedListener","getStatus","isConnected","getQueueSize","length","clearQueue","getReconnectAttempts","updateConfig","Object","assign","getWebSocket","forEach","parse","reconnect","attempts","async","setInterval","clearInterval","queue","_args"],"mappings":"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"}