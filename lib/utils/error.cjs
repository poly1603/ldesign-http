"use strict";var r,e=require("./index.cjs");exports.ErrorType=void 0,(r=exports.ErrorType||(exports.ErrorType={})).NETWORK="NETWORK_ERROR",r.TIMEOUT="TIMEOUT_ERROR",r.CANCEL="CANCEL_ERROR",r.HTTP="HTTP_ERROR",r.PARSE="PARSE_ERROR",r.UNKNOWN="UNKNOWN_ERROR";class t{static createNetworkError(r,t){const o=e.createHttpError(this.ERROR_TEMPLATES[exports.ErrorType.NETWORK],r,exports.ErrorType.NETWORK);return o.isNetworkError=!0,o.cause=t,o}static createTimeoutError(r,t){const o="function"==typeof this.ERROR_TEMPLATES[exports.ErrorType.TIMEOUT]?this.ERROR_TEMPLATES[exports.ErrorType.TIMEOUT](t):`Timeout Error: Request timed out after ${t}ms`,s=e.createHttpError(o,r,exports.ErrorType.TIMEOUT);return s.isTimeoutError=!0,s}static createCancelError(r){const t=e.createHttpError(this.ERROR_TEMPLATES[exports.ErrorType.CANCEL],r,exports.ErrorType.CANCEL);return t.isCancelError=!0,t}static createHttpError(r,t,o,s){return e.createHttpError(`HTTP Error: ${r} ${t}`,o,exports.ErrorType.HTTP,s)}static createParseError(r,t){const o=e.createHttpError("Parse Error: Failed to parse response data",r,exports.ErrorType.PARSE);return o.cause=t,o}static isRetryableError(r){if(r.isNetworkError||r.isTimeoutError)return!0;if(r.response?.status){const e=r.response.status;return e>=500||429===e||408===e}return!1}static getUserFriendlyMessage(r){if(r.isNetworkError)return"网络连接失败，请检查网络设置";if(r.isTimeoutError)return"请求超时，请稍后重试";if(r.isCancelError)return"请求已取消";if(r.response?.status){const e=r.response.status;switch(e){case 400:return"请求参数错误";case 401:return"未授权，请重新登录";case 403:return"权限不足";case 404:return"请求的资源不存在";case 429:return"请求过于频繁，请稍后重试";case 500:return"服务器内部错误";case 502:return"网关错误";case 503:return"服务暂时不可用";default:return`请求失败 (${e})`}}return r.message||"未知错误"}static recordError(r){const e=Date.now();this.errorStats.total++;const t=this.getErrorType(r);if(this.errorStats.byType[t]++,r.response?.status){const e=r.response.status;this.errorStats.byStatus[e]=(this.errorStats.byStatus[e]||0)+1}this.errorStats.recent.unshift(r),this.errorStats.recent.length>10&&(this.errorStats.recent=this.errorStats.recent.slice(0,10)),this.errorHistory.unshift({error:r,timestamp:e,recovered:!1}),this.errorHistory.length>100&&(this.errorHistory=this.errorHistory.slice(0,100)),this.updateErrorRate(),this.updateMostCommonError()}static async tryRecover(r){for(const e of this.recoveryStrategies)if(e.canHandle(r))try{if(await e.recover(r)){const e=this.errorHistory.find(e=>e.error===r);return e&&(e.recovered=!0),!0}}catch(r){}return!1}static addRecoveryStrategy(r){this.recoveryStrategies.push(r),this.recoveryStrategies.sort((r,e)=>(e.priority||0)-(r.priority||0))}static removeRecoveryStrategy(r){const e=this.recoveryStrategies.findIndex(e=>e.name===r);return e>-1&&(this.recoveryStrategies.splice(e,1),!0)}static getRecoveryStrategies(){return[...this.recoveryStrategies]}static getErrorType(r){return r.isNetworkError?exports.ErrorType.NETWORK:r.isTimeoutError?exports.ErrorType.TIMEOUT:r.isCancelError?exports.ErrorType.CANCEL:r.response?exports.ErrorType.HTTP:r.code===exports.ErrorType.PARSE?exports.ErrorType.PARSE:exports.ErrorType.UNKNOWN}static updateErrorRate(){const r=Date.now()-36e5,e=this.errorHistory.filter(e=>e.timestamp>r);this.errorStats.errorRate=e.length}static updateMostCommonError(){let r=0,e=null;for(const[t,o]of Object.entries(this.errorStats.byType))o>r&&(r=o,e=t);this.errorStats.mostCommon=e?{type:e,count:r}:null}static getStats(){return{...this.errorStats}}static getErrorHistory(){return[...this.errorHistory]}static resetStats(){this.errorStats={total:0,byType:{[exports.ErrorType.NETWORK]:0,[exports.ErrorType.TIMEOUT]:0,[exports.ErrorType.CANCEL]:0,[exports.ErrorType.HTTP]:0,[exports.ErrorType.PARSE]:0,[exports.ErrorType.UNKNOWN]:0},byStatus:{},recent:[],errorRate:0,mostCommon:null},this.errorHistory=[]}static cleanupOldErrors(r=864e5){const e=Date.now()-r,t=this.errorHistory.length;return this.errorHistory=this.errorHistory.filter(r=>r.timestamp>e),t-this.errorHistory.length}}t.ERROR_TEMPLATES={[exports.ErrorType.NETWORK]:"Network Error: Unable to connect to the server",[exports.ErrorType.TIMEOUT]:r=>`Timeout Error: Request timed out after ${r}ms`,[exports.ErrorType.CANCEL]:"Cancel Error: Request was cancelled",[exports.ErrorType.HTTP]:(r,e)=>`HTTP Error ${r}: ${e}`,[exports.ErrorType.PARSE]:"Parse Error: Failed to parse response data",[exports.ErrorType.UNKNOWN]:"Unknown Error: An unexpected error occurred"},t.errorStats={total:0,byType:{[exports.ErrorType.NETWORK]:0,[exports.ErrorType.TIMEOUT]:0,[exports.ErrorType.CANCEL]:0,[exports.ErrorType.HTTP]:0,[exports.ErrorType.PARSE]:0,[exports.ErrorType.UNKNOWN]:0},byStatus:{},recent:[],errorRate:0,mostCommon:null},t.recoveryStrategies=[],t.errorHistory=[];const o={networkReconnect:{name:"network-reconnect",priority:10,canHandle:r=>r.isNetworkError,recover:async r=>{try{return(await fetch("/ping",{method:"HEAD",cache:"no-cache",signal:AbortSignal.timeout(5e3)})).ok}catch{return!1}}},authRefresh:{name:"auth-refresh",priority:20,canHandle:r=>401===r.response?.status,recover:async r=>{try{const r=localStorage.getItem("refreshToken");if(!r)return!1;const e=await fetch("/auth/refresh",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({refreshToken:r})});if(e.ok){const r=await e.json();return localStorage.setItem("accessToken",r.accessToken),localStorage.setItem("refreshToken",r.refreshToken),!0}}catch{localStorage.removeItem("accessToken"),localStorage.removeItem("refreshToken")}return!1}},serviceFallback:{name:"service-fallback",priority:5,canHandle:r=>{const e=r.response?.status;return 503===e||502===e||504===e},recover:async r=>{const e=r.config?.url?.replace("/api/","/api-fallback/");if(e&&e!==r.config?.url)try{return(await fetch(e,{method:"HEAD",signal:AbortSignal.timeout(3e3)})).ok}catch{return!1}return!1}},cacheFailback:{name:"cache-fallback",priority:1,canHandle:r=>"GET"===r.config?.method?.toUpperCase(),recover:async r=>{try{const e=`http_cache_${r.config?.url}`,t=localStorage.getItem(e);if(t){const r=JSON.parse(t);if(Date.now()-r.timestamp<864e5)return!0}}catch{}return!1}}};exports.ErrorAnalyzer=class{static analyzeErrorPatterns(r){const e={},t=r.length;r.forEach(r=>{r.isNetworkError&&(e.network_errors=(e.network_errors||0)+1),r.isTimeoutError&&(e.timeout_errors=(e.timeout_errors||0)+1),401===r.response?.status&&(e.auth_errors=(e.auth_errors||0)+1),r.response?.status&&r.response.status>=500&&(e.server_errors=(e.server_errors||0)+1),r.response?.status&&r.response.status>=400&&r.response.status<500&&(e.client_errors=(e.client_errors||0)+1)});return{patterns:Object.entries(e).map(([r,e])=>({type:r,count:e,percentage:Math.round(e/t*100),description:this.getPatternDescription(r)})),recommendations:this.generateRecommendations(e,t)}}static getPatternDescription(r){return{network_errors:"网络连接问题，可能是网络不稳定或服务器不可达",timeout_errors:"请求超时，可能是网络延迟高或服务器响应慢",auth_errors:"认证失败，可能是令牌过期或权限不足",server_errors:"服务器内部错误，可能是服务器故障或过载",client_errors:"客户端请求错误，可能是参数错误或请求格式不正确"}[r]||"未知错误模式"}static generateRecommendations(r,e){const t=[];return r.network_errors&&r.network_errors/e>.3&&t.push("考虑添加网络重连机制和离线模式支持"),r.timeout_errors&&r.timeout_errors/e>.2&&t.push("考虑增加请求超时时间或优化服务器响应速度"),r.auth_errors&&r.auth_errors/e>.1&&t.push("考虑实现自动令牌刷新机制"),r.server_errors&&r.server_errors/e>.15&&t.push("考虑添加服务降级和熔断机制"),r.client_errors&&r.client_errors/e>.25&&t.push("考虑加强客户端参数验证和错误提示"),t}},exports.ErrorHandler=t,exports.RetryManager=class{constructor(r={}){this.config={retries:r.retries??3,retryDelay:r.retryDelay??1e3,retryCondition:r.retryCondition??t.isRetryableError,retryDelayFunction:r.retryDelayFunction??this.defaultRetryDelayFunction}}async executeWithRetry(r,t){let o,s=0;for(;s<=this.config?.retries;)try{return await r()}catch(r){if(o=r,s>=this.config?.retries||!this.config?.retryCondition(o))throw o;const t=this.config?.retryDelayFunction(s,o);await e.delay(t),s++}throw o||e.createHttpError("Retry failed",{url:""})}defaultRetryDelayFunction(r,e){const t=this.config?.retryDelay*2**r,o=.1*Math.random()*t;return Math.min(t+o,3e4)}updateConfig(r){Object.assign(this.config,r)}getConfig(){return{...this.config}}},exports.TimeoutManager=class{constructor(){this.timeouts=new Map}createTimeoutController(r,e){const t=new AbortController,o=e||this.generateId(),s=setTimeout(()=>{t.abort(),this.timeouts.delete(o)},r);return this.timeouts.set(o,s),{signal:t.signal,cleanup:()=>{const r=this.timeouts.get(o);r&&(clearTimeout(r),this.timeouts.delete(o))}}}clearAll(){this.timeouts.forEach(r=>{clearTimeout(r)}),this.timeouts.clear()}generateId(){return Math.random().toString(36).substring(2,15)}},exports.builtinRecoveryStrategies=o;
//# sourceMappingURL=error.cjs.map
