"use strict";class e{constructor(e={}){this.pendingRequests=new Map,this.stats={executions:0,duplications:0,savedRequests:0},this.config={maxPendingRequests:e.maxPendingRequests??1e3,cleanupInterval:e.cleanupInterval??3e4,requestTimeout:e.requestTimeout??6e4,autoCleanup:e.autoCleanup??!0},this.config.autoCleanup&&this.startAutoCleanup()}async execute(e,t){if(this.pendingRequests.has(e)){const t=this.pendingRequests.get(e);return t.refCount++,this.stats.duplications++,this.stats.savedRequests++,t.promise}this.pendingRequests.size>=this.config.maxPendingRequests&&this.cleanupOldestRequest();const s=t().finally(()=>{this.pendingRequests.delete(e)}),n={promise:s,createdAt:Date.now(),refCount:1,key:e};return this.pendingRequests.set(e,n),this.stats.executions++,s}startAutoCleanup(){this.cleanupTimer=setInterval(()=>{this.cleanupTimeoutTasks(this.config.requestTimeout)},this.config.cleanupInterval)}stopAutoCleanup(){this.cleanupTimer&&(clearInterval(this.cleanupTimer),this.cleanupTimer=void 0)}cleanupOldestRequest(){let e=null,t=Number.POSITIVE_INFINITY;for(const[s,n]of this.pendingRequests)n.createdAt<t&&(t=n.createdAt,e=s);e&&this.pendingRequests.delete(e)}cleanupTimeoutTasks(e){const t=Date.now();let s=0;for(const[n,i]of this.pendingRequests)t-i.createdAt>e&&(this.pendingRequests.delete(n),s++);return s}cancel(e){return this.pendingRequests.delete(e)}cancelAll(){this.pendingRequests.clear()}isRunning(e){return this.pendingRequests.has(e)}async waitFor(e){const t=this.pendingRequests.get(e);if(!t)return null;try{return await t.promise}catch{return null}}async waitForAll(){const e=Array.from(this.pendingRequests.values()).map(e=>e.promise.catch(()=>{}));await Promise.all(e)}getTaskInfo(e){const t=this.pendingRequests.get(e);return t?{key:t.key,createdAt:t.createdAt,refCount:t.refCount,duration:Date.now()-t.createdAt}:null}getAllTaskInfo(){return Array.from(this.pendingRequests.values()).map(e=>({key:e.key,createdAt:e.createdAt,refCount:e.refCount,duration:Date.now()-e.createdAt}))}getStats(){const e=this.stats.executions+this.stats.duplications;return{executions:this.stats.executions,duplications:this.stats.duplications,savedRequests:this.stats.savedRequests,deduplicationRate:e>0?this.stats.duplications/e:0,pendingCount:this.pendingRequests.size}}resetStats(){this.stats={executions:0,duplications:0,savedRequests:0}}getPendingCount(){return this.pendingRequests.size}getPendingKeys(){return Array.from(this.pendingRequests.keys())}getMostReferencedTask(){let e=0,t="";for(const[s,n]of this.pendingRequests)n.refCount>e&&(e=n.refCount,t=s);return e>0?{key:t,refCount:e}:null}getLongestRunningTask(){let e=0,t="";const s=Date.now();for(const[n,i]of this.pendingRequests){const u=s-i.createdAt;u>e&&(e=u,t=n)}return e>0?{key:t,duration:e}:null}updateConfig(e){Object.assign(this.config,e),void 0!==e.autoCleanup&&(e.autoCleanup&&!this.cleanupTimer?this.startAutoCleanup():!e.autoCleanup&&this.cleanupTimer&&this.stopAutoCleanup())}destroy(){this.stopAutoCleanup(),this.pendingRequests.clear(),this.resetStats()}}const t=new e;exports.DeduplicationManager=e,exports.createDeduplicationManager=function(t){return new e(t)},exports.globalDeduplicationManager=t;
//# sourceMappingURL=dedup-manager.cjs.map
