{"version":3,"file":"function-utils.cjs","sources":["../../src/utils/function-utils.ts"],"sourcesContent":["/**\r\n * 函数工具模块\r\n * \r\n * 提供内存化、重试、一次性函数等功能\r\n */\r\n\r\n/**\r\n * 创建一次性函数\r\n * \r\n * 确保函数只被执行一次，后续调用返回第一次的结果\r\n * \r\n * @param fn - 要执行的函数\r\n * @returns 只执行一次的函数\r\n * \r\n * @example\r\n * ```typescript\r\n * const initialize = once(() => {\r\n *   console.log('Initializing...')\r\n *   return { initialized: true }\r\n * })\r\n * \r\n * initialize() // 输出: \"Initializing...\"\r\n * initialize() // 不输出，返回缓存的结果\r\n * ```\r\n */\r\nexport function once<T extends (...args: any[]) => any>(\r\n  fn: T,\r\n): T & { \r\n  called: boolean\r\n  clear: () => void \r\n} {\r\n  let called = false\r\n  let result: ReturnType<T>\r\n\r\n  function onceFunc(this: any, ...args: Parameters<T>): ReturnType<T> {\r\n    if (!called) {\r\n      called = true\r\n      result = fn.apply(this, args)\r\n    }\r\n    return result\r\n  }\r\n\r\n  function clear(): void {\r\n    called = false\r\n    result = undefined as any\r\n  }\r\n\r\n  const enhanced = onceFunc as T & {\r\n    called: boolean\r\n    clear: () => void\r\n  }\r\n\r\n  Object.defineProperty(enhanced, 'called', {\r\n    get: () => called,\r\n  })\r\n\r\n  enhanced.clear = clear\r\n\r\n  return enhanced\r\n}\r\n\r\n/**\r\n * 内存化配置\r\n */\r\nexport interface MemoizeOptions {\r\n  /** 最大缓存数量 */\r\n  maxSize?: number\r\n  /** 缓存过期时间（毫秒） */\r\n  ttl?: number\r\n  /** 是否使用WeakMap（仅对象类型参数） */\r\n  weak?: boolean\r\n  /** 自定义键生成函数 */\r\n  keyFn?: (...args: any[]) => string\r\n  /** 自定义相等比较函数 */\r\n  equalFn?: (a: any, b: any) => boolean\r\n}\r\n\r\n/**\r\n * 内存化函数\r\n * \r\n * 缓存函数的执行结果，相同输入返回缓存值\r\n * \r\n * @param fn - 要内存化的函数\r\n * @param options - 内存化选项\r\n * @returns 内存化后的函数\r\n * \r\n * @example\r\n * ```typescript\r\n * const expensiveCalculation = memoize((a: number, b: number) => {\r\n *   console.log('Calculating...')\r\n *   return a * b\r\n * })\r\n * \r\n * expensiveCalculation(2, 3) // 输出: \"Calculating...\" 返回: 6\r\n * expensiveCalculation(2, 3) // 不输出，直接返回: 6\r\n * ```\r\n */\r\nexport function memoize<T extends (...args: any[]) => any>(\r\n  fn: T,\r\n  options: MemoizeOptions = {},\r\n): T & { \r\n  cache: Map<string, any>\r\n  clear: () => void\r\n  delete: (key: string) => boolean\r\n  has: (key: string) => boolean\r\n} {\r\n  const {\r\n    maxSize = Infinity,\r\n    ttl,\r\n    keyFn = (...args) => JSON.stringify(args),\r\n  } = options\r\n\r\n  const cache = new Map<string, { value: ReturnType<T>, timestamp?: number }>()\r\n\r\n  function isExpired(timestamp?: number): boolean {\r\n    if (!ttl || !timestamp) return false\r\n    return Date.now() - timestamp > ttl\r\n  }\r\n\r\n  function memoized(this: any, ...args: Parameters<T>): ReturnType<T> {\r\n    const key = keyFn(...args)\r\n\r\n    if (cache.has(key)) {\r\n      const cached = cache.get(key)!\r\n      if (!isExpired(cached.timestamp)) {\r\n        // 移到最前面（LRU）\r\n        cache.delete(key)\r\n        cache.set(key, cached)\r\n        return cached.value\r\n      } else {\r\n        cache.delete(key)\r\n      }\r\n    }\r\n\r\n    const result = fn.apply(this, args)\r\n    \r\n    // 限制缓存大小\r\n    if (cache.size >= maxSize) {\r\n      // 删除最旧的（第一个）\r\n      const firstKey = cache.keys().next().value as string | undefined\r\n      if (firstKey !== undefined) {\r\n        cache.delete(firstKey)\r\n      }\r\n    }\r\n\r\n    cache.set(key, {\r\n      value: result,\r\n      timestamp: ttl ? Date.now() : undefined,\r\n    })\r\n\r\n    return result\r\n  }\r\n\r\n  const enhanced = memoized as T & {\r\n    cache: Map<string, any>\r\n    clear: () => void\r\n    delete: (key: string) => boolean\r\n    has: (key: string) => boolean\r\n  }\r\n\r\n  enhanced.cache = cache as any\r\n  enhanced.clear = () => cache.clear()\r\n  enhanced.delete = (key: string) => cache.delete(key)\r\n  enhanced.has = (key: string) => {\r\n    if (!cache.has(key)) return false\r\n    const cached = cache.get(key)!\r\n    if (isExpired(cached.timestamp)) {\r\n      cache.delete(key)\r\n      return false\r\n    }\r\n    return true\r\n  }\r\n\r\n  return enhanced\r\n}\r\n\r\n/**\r\n * 重试配置\r\n */\r\nexport interface RetryOptions {\r\n  /** 最大重试次数 */\r\n  maxAttempts?: number\r\n  /** 初始延迟（毫秒） */\r\n  delay?: number\r\n  /** 延迟增长因子 */\r\n  factor?: number\r\n  /** 最大延迟（毫秒） */\r\n  maxDelay?: number\r\n  /** 抖动 */\r\n  jitter?: boolean\r\n  /** 重试条件 */\r\n  retryCondition?: (error: any) => boolean\r\n  /** 重试回调 */\r\n  onRetry?: (attempt: number, error: any) => void\r\n}\r\n\r\n/**\r\n * 重试函数\r\n * \r\n * 在失败时自动重试函数执行\r\n * \r\n * @param fn - 要执行的函数\r\n * @param options - 重试选项\r\n * @returns Promise\r\n * \r\n * @example\r\n * ```typescript\r\n * const result = await retry(\r\n *   () => fetch('/api/data'),\r\n *   { maxAttempts: 3, delay: 1000 }\r\n * )\r\n * ```\r\n */\r\nexport async function retry<T>(\r\n  fn: () => Promise<T>,\r\n  options: RetryOptions = {},\r\n): Promise<T> {\r\n  const {\r\n    maxAttempts = 3,\r\n    delay = 1000,\r\n    factor = 2,\r\n    maxDelay = 30000,\r\n    jitter = true,\r\n    retryCondition = () => true,\r\n    onRetry,\r\n  } = options\r\n\r\n  let lastError: any\r\n  let currentDelay = delay\r\n\r\n  for (let attempt = 1; attempt <= maxAttempts; attempt++) {\r\n    try {\r\n      return await fn()\r\n    } catch (error) {\r\n      lastError = error\r\n\r\n      if (attempt < maxAttempts && retryCondition(error)) {\r\n        onRetry?.(attempt, error)\r\n        \r\n        // 计算延迟\r\n        if (jitter) {\r\n          // 添加随机抖动（±25%）\r\n          const jitterFactor = 0.75 + Math.random() * 0.5\r\n          currentDelay = Math.min(currentDelay * jitterFactor, maxDelay)\r\n        }\r\n        \r\n        await new Promise(resolve => setTimeout(resolve, currentDelay))\r\n        \r\n        // 增加延迟\r\n        currentDelay = Math.min(currentDelay * factor, maxDelay)\r\n      } else {\r\n        break\r\n      }\r\n    }\r\n  }\r\n\r\n  throw lastError\r\n}\r\n\r\n/**\r\n * 创建可重试函数\r\n */\r\nexport function createRetryableFunction<T extends (...args: any[]) => Promise<any>>(\r\n  fn: T,\r\n  options: RetryOptions = {},\r\n): T {\r\n  function retryable(this: any, ...args: Parameters<T>): ReturnType<T> {\r\n    return retry(() => fn.apply(this, args), options) as ReturnType<T>\r\n  }\r\n\r\n  return retryable as unknown as T\r\n}\r\n\r\n/**\r\n * 延迟执行\r\n * \r\n * @param ms - 延迟时间（毫秒）\r\n * @returns Promise\r\n */\r\nexport function sleep(ms: number): Promise<void> {\r\n  return new Promise(resolve => setTimeout(resolve, ms))\r\n}\r\n\r\n/**\r\n * 超时配置\r\n */\r\nexport interface TimeoutOptions {\r\n  /** 超时错误信息 */\r\n  message?: string\r\n  /** 超时错误 */\r\n  error?: Error\r\n  /** 是否可取消 */\r\n  cancellable?: boolean\r\n}\r\n\r\n/**\r\n * 超时Promise包装器\r\n * \r\n * 为Promise添加超时限制\r\n * \r\n * @param promise - 原始Promise\r\n * @param ms - 超时时间（毫秒）\r\n * @param options - 超时选项\r\n * @returns 带超时的Promise\r\n * \r\n * @example\r\n * ```typescript\r\n * const result = await timeout(\r\n *   fetch('/api/data'),\r\n *   5000,\r\n *   { message: 'Request timeout' }\r\n * )\r\n * ```\r\n */\r\nexport function timeout<T>(\r\n  promise: Promise<T>,\r\n  ms: number,\r\n  options: TimeoutOptions = {},\r\n): Promise<T> & { cancel?: () => void } {\r\n  const {\r\n    message = 'Timeout',\r\n    error = new Error(message),\r\n    cancellable = false,\r\n  } = options\r\n\r\n  let timeoutId: ReturnType<typeof setTimeout>\r\n  let cancelled = false\r\n\r\n  const timeoutPromise = new Promise<never>((_, reject) => {\r\n    timeoutId = setTimeout(() => {\r\n      if (!cancelled) {\r\n        reject(error)\r\n      }\r\n    }, ms)\r\n  })\r\n\r\n  const result = Promise.race([\r\n    promise,\r\n    timeoutPromise,\r\n  ]).finally(() => {\r\n    clearTimeout(timeoutId)\r\n  }) as Promise<T> & { cancel?: () => void }\r\n\r\n  if (cancellable) {\r\n    result.cancel = () => {\r\n      cancelled = true\r\n      clearTimeout(timeoutId)\r\n    }\r\n  }\r\n\r\n  return result\r\n}\r\n\r\n/**\r\n * 并发控制器\r\n */\r\nexport class ConcurrencyController {\r\n  private running = 0\r\n  private queue: Array<() => void> = []\r\n\r\n  constructor(private maxConcurrency: number) {}\r\n\r\n  /**\r\n   * 执行任务\r\n   */\r\n  async execute<T>(fn: () => Promise<T>): Promise<T> {\r\n    while (this.running >= this.maxConcurrency) {\r\n      await new Promise<void>(resolve => {\r\n        this.queue.push(resolve)\r\n      })\r\n    }\r\n\r\n    this.running++\r\n    \r\n    try {\r\n      return await fn()\r\n    } finally {\r\n      this.running--\r\n      const next = this.queue.shift()\r\n      if (next) {\r\n        next()\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 并发执行多个任务\r\n   */\r\n  async executeAll<T>(\r\n    tasks: Array<() => Promise<T>>,\r\n  ): Promise<T[]> {\r\n    return Promise.all(\r\n      tasks.map(task => this.execute(task)),\r\n    )\r\n  }\r\n\r\n  /**\r\n   * 获取当前运行数量\r\n   */\r\n  getRunning(): number {\r\n    return this.running\r\n  }\r\n\r\n  /**\r\n   * 获取队列长度\r\n   */\r\n  getQueueLength(): number {\r\n    return this.queue.length\r\n  }\r\n}\r\n\r\n/**\r\n * 并发执行\r\n * \r\n * 限制并发执行的任务数量\r\n * \r\n * @param tasks - 任务列表\r\n * @param limit - 并发限制\r\n * @returns 结果数组\r\n * \r\n * @example\r\n * ```typescript\r\n * const results = await concurrent(\r\n *   urls.map(url => () => fetch(url)),\r\n *   3 // 最多3个并发请求\r\n * )\r\n * ```\r\n */\r\nexport async function concurrent<T>(\r\n  tasks: Array<() => Promise<T>>,\r\n  limit: number,\r\n): Promise<T[]> {\r\n  const controller = new ConcurrencyController(limit)\r\n  return controller.executeAll(tasks)\r\n}\r\n\r\n/**\r\n * 创建串行执行器\r\n * \r\n * 确保异步函数按顺序执行\r\n */\r\nexport function createSerialExecutor<T extends (...args: any[]) => Promise<any>>(): \r\n  (fn: T, ...args: Parameters<T>) => ReturnType<T> {\r\n  let queue = Promise.resolve()\r\n\r\n  return function execute(fn: T, ...args: Parameters<T>): ReturnType<T> {\r\n    const result = queue.then(() => fn(...args))\r\n    queue = result.catch(() => {}) // 忽略错误，继续队列\r\n    return result as ReturnType<T>\r\n  }\r\n}\r\n\r\n/**\r\n * 创建并行执行器\r\n * \r\n * 批量并行执行函数\r\n */\r\nexport function createParallelExecutor(\r\n  maxConcurrency = 10,\r\n): <T>(tasks: Array<() => Promise<T>>) => Promise<T[]> {\r\n  const controller = new ConcurrencyController(maxConcurrency)\r\n  \r\n  return function execute<T>(tasks: Array<() => Promise<T>>): Promise<T[]> {\r\n    return controller.executeAll(tasks)\r\n  }\r\n}\r\n\r\n/**\r\n * 创建延迟执行器\r\n */\r\nexport function defer<T extends (...args: any[]) => any>(\r\n  fn: T,\r\n  delay = 0,\r\n): (...args: Parameters<T>) => Promise<ReturnType<T>> {\r\n  return async function(...args: Parameters<T>): Promise<ReturnType<T>> {\r\n    await sleep(delay)\r\n    return fn(...args)\r\n  }\r\n}\r\n\r\n/**\r\n * 创建条件执行器\r\n */\r\nexport function conditional<T extends (...args: any[]) => any>(\r\n  condition: (...args: Parameters<T>) => boolean,\r\n  trueFn: T,\r\n  falseFn?: T,\r\n): T {\r\n  return function(this: any, ...args: Parameters<T>): ReturnType<T> {\r\n    if (condition(...args)) {\r\n      return trueFn.apply(this, args)\r\n    } else if (falseFn) {\r\n      return falseFn.apply(this, args)\r\n    }\r\n    return undefined as any\r\n  } as T\r\n}"],"names":["async","retry","fn","options","maxAttempts","delay","factor","maxDelay","jitter","retryCondition","onRetry","lastError","currentDelay","attempt","error","jitterFactor","Math","random","min","Promise","resolve","setTimeout","sleep","ms","ConcurrencyController","constructor","maxConcurrency","this","running","queue","execute","push","next","shift","executeAll","tasks","all","map","task","getRunning","getQueueLength","length","limit","condition","trueFn","falseFn","args","apply","controller","result","then","catch","maxSize","ttl","keyFn","JSON","stringify","cache","Map","isExpired","timestamp","Date","now","enhanced","key","has","cached","get","delete","set","value","size","firstKey","keys","clear","called","Object","defineProperty","promise","message","Error","cancellable","timeoutId","cancelled","timeoutPromise","_","reject","race","finally","clearTimeout","cancel"],"mappings":"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"}