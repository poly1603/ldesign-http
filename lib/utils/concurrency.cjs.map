{"version":3,"file":"concurrency.cjs","sources":["../../src/utils/concurrency.ts"],"sourcesContent":["/**\n * 并发控制管理器\n * \n * 管理HTTP请求的并发数量和队列处理\n */\n\nimport type { ConcurrencyConfig, RequestConfig, ResponseData } from '../types'\nimport type { DeduplicationStats } from './dedup-manager'\nimport type { DeduplicationKeyConfig } from './request-dedup'\nimport { DeduplicationManager } from './dedup-manager'\nimport { DeduplicationKeyGenerator } from './request-dedup'\n\n/**\n * 请求任务接口\n */\ninterface RequestTask<T = any> {\n  id: string\n  execute: () => Promise<ResponseData<T>>\n  resolve: (value: ResponseData<T>) => void\n  reject: (error: any) => void\n  config: RequestConfig\n}\n\n/**\n * 并发控制管理器\n */\nexport class ConcurrencyManager {\n  private config: Required<ConcurrencyConfig>\n  private activeRequests = new Set<string>()\n  private requestQueue: RequestTask[] = []\n  private requestCounter = 0\n  private processingQueue = false // 防止重复处理队列\n  private deduplicationManager: DeduplicationManager\n  private keyGenerator: DeduplicationKeyGenerator\n\n  constructor(config: ConcurrencyConfig = {}) {\n    this.config = {\n      maxConcurrent: config.maxConcurrent ?? 10,\n      maxQueueSize: config.maxQueueSize ?? 100,\n      deduplication: config.deduplication ?? true,\n    }\n\n    // 初始化去重管理器\n    this.deduplicationManager = new DeduplicationManager()\n    this.keyGenerator = new DeduplicationKeyGenerator({\n      includeMethod: true,\n      includeUrl: true,\n      includeParams: true,\n      includeData: false, // 默认不包含请求体，避免大数据影响性能\n    })\n  }\n\n  /**\n   * 执行请求（带并发控制和去重）\n   */\n  async execute<T = unknown>(\n    requestFn: () => Promise<ResponseData<T>>,\n    config: RequestConfig,\n  ): Promise<ResponseData<T>> {\n    // 如果启用了去重功能\n    if (this.config?.deduplication) {\n      const deduplicationKey = this.keyGenerator.generate(config)\n\n      // 使用去重管理器执行请求\n      return this.deduplicationManager.execute(\n        deduplicationKey,\n        () => this.executeWithConcurrencyControl(requestFn, config),\n      )\n    }\n\n    // 否则直接使用并发控制\n    return this.executeWithConcurrencyControl(requestFn, config)\n  }\n\n  /**\n   * 带并发控制的请求执行\n   */\n  private async executeWithConcurrencyControl<T = unknown>(\n    requestFn: () => Promise<ResponseData<T>>,\n    config: RequestConfig,\n  ): Promise<ResponseData<T>> {\n    return new Promise<ResponseData<T>>((resolve, reject) => {\n      const taskId = this.generateTaskId()\n\n      const task: RequestTask<T> = {\n        id: taskId,\n        execute: requestFn,\n        resolve,\n        reject,\n        config,\n      }\n\n      // 检查队列大小限制\n      if (this.requestQueue.length >= this.config?.maxQueueSize) {\n        reject(new Error('Request queue is full'))\n        return\n      }\n\n      // 如果当前并发数未达到限制，直接执行\n      if (this.activeRequests.size < this.config?.maxConcurrent) {\n        void this.executeTask(task)\n      }\n      else {\n        // 否则加入队列\n        this.requestQueue.push(task)\n      }\n    })\n  }\n\n  /**\n   * 执行任务\n   */\n  private async executeTask<T = unknown>(task: RequestTask<T>): Promise<void> {\n    this.activeRequests.add(task.id)\n\n    try {\n      const result = await task.execute()\n      task.resolve(result)\n    }\n    catch (error) {\n      task.reject(error)\n    }\n    finally {\n      this.activeRequests.delete(task.id)\n      this.processQueue()\n    }\n  }\n\n  /**\n   * 处理队列中的下一个任务（优化版）\n   */\n  private processQueue(): void {\n    // 防止重复处理\n    if (this.processingQueue) {\n      return\n    }\n\n    this.processingQueue = true\n\n    try {\n      // 批量处理多个任务，直到达到并发限制\n      while (\n        this.requestQueue.length > 0\n        && this.activeRequests.size < this.config?.maxConcurrent\n      ) {\n        const nextTask = this.requestQueue.shift()\n        if (nextTask) {\n          void this.executeTask(nextTask)\n        }\n      }\n    }\n    finally {\n      this.processingQueue = false\n    }\n  }\n\n  /**\n   * 取消所有排队的请求\n   */\n  cancelQueue(reason = 'Queue cancelled'): void {\n    const queuedTasks = this.requestQueue.splice(0)\n    queuedTasks.forEach((task) => {\n      task.reject(new Error(reason))\n    })\n  }\n\n  /**\n   * 获取状态信息\n   */\n  getStatus(): {\n    activeCount: number\n    queuedCount: number\n    maxConcurrent: number\n    maxQueueSize: number\n    deduplication: DeduplicationStats\n  } {\n    return {\n      activeCount: this.activeRequests.size,\n      queuedCount: this.requestQueue.length,\n      maxConcurrent: this.config?.maxConcurrent,\n      maxQueueSize: this.config?.maxQueueSize,\n      deduplication: this.deduplicationManager.getStats(),\n    }\n  }\n\n  /**\n   * 更新配置\n   */\n  updateConfig(config: Partial<ConcurrencyConfig>): void {\n    Object.assign(this.config, config)\n\n    // 如果降低了最大并发数，需要处理队列\n    this.processQueue()\n  }\n\n  /**\n   * 获取当前配置\n   */\n  getConfig(): Required<ConcurrencyConfig> {\n    return { ...this.config }\n  }\n\n  /**\n   * 获取去重统计信息\n   */\n  getDeduplicationStats(): DeduplicationStats {\n    return this.deduplicationManager.getStats()\n  }\n\n  /**\n   * 重置去重统计信息\n   */\n  resetDeduplicationStats(): void {\n    this.deduplicationManager.resetStats()\n  }\n\n  /**\n   * 检查请求是否正在去重处理中\n   */\n  isRequestDeduplicating(config: RequestConfig): boolean {\n    const key = this.keyGenerator.generate(config)\n    return this.deduplicationManager.isRunning(key)\n  }\n\n  /**\n   * 取消特定的去重请求\n   */\n  cancelDeduplicatedRequest(config: RequestConfig): void {\n    const key = this.keyGenerator.generate(config)\n    this.deduplicationManager.cancel(key)\n  }\n\n  /**\n   * 等待特定去重请求完成\n   */\n  async waitForDeduplicatedRequest<T = unknown>(config: RequestConfig): Promise<ResponseData<T> | null> {\n    const key = this.keyGenerator.generate(config)\n    return this.deduplicationManager.waitFor<T>(key)\n  }\n\n  /**\n   * 获取所有去重任务信息\n   */\n  getDeduplicationTasksInfo(): Array<{\n    key: string\n    createdAt: number\n    refCount: number\n    duration: number\n  }> {\n    return this.deduplicationManager.getAllTaskInfo()\n  }\n\n  /**\n   * 清理超时的去重任务\n   */\n  cleanupTimeoutDeduplicationTasks(timeoutMs: number = 30000): number {\n    return this.deduplicationManager.cleanupTimeoutTasks(timeoutMs)\n  }\n\n  /**\n   * 配置去重键生成器\n   */\n  configureDeduplicationKeyGenerator(config: DeduplicationKeyConfig): void {\n    this.keyGenerator = new DeduplicationKeyGenerator(config)\n  }\n\n  /**\n   * 生成任务 ID\n   */\n  private generateTaskId(): string {\n    return `task_${++this.requestCounter}_${Date.now()}`\n  }\n}\n\n/**\n * 创建并发管理器\n */\nexport function createConcurrencyManager(\n  config?: ConcurrencyConfig,\n): ConcurrencyManager {\n  return new ConcurrencyManager(config)\n}\n\n// 导出拆分出去的模块\nexport { createDeduplicationManager, DeduplicationManager } from './dedup-manager'\nexport type { DeduplicationStats } from './dedup-manager'\nexport { createRateLimitManager, RateLimitManager } from './rate-limit'\nexport { createDeduplicationKeyGenerator, DeduplicationKeyGenerator } from './request-dedup'\nexport type { DeduplicationKeyConfig } from './request-dedup'\n"],"names":["ConcurrencyManager","constructor","config","this","activeRequests","Set","requestQueue","requestCounter","processingQueue","maxConcurrent","maxQueueSize","deduplication","deduplicationManager","DeduplicationManager","keyGenerator","DeduplicationKeyGenerator","includeMethod","includeUrl","includeParams","includeData","execute","requestFn","deduplicationKey","generate","executeWithConcurrencyControl","Promise","resolve","reject","task","id","generateTaskId","length","Error","size","executeTask","push","add","result","error","delete","processQueue","nextTask","shift","cancelQueue","reason","splice","forEach","getStatus","activeCount","queuedCount","getStats","updateConfig","Object","assign","getConfig","getDeduplicationStats","resetDeduplicationStats","resetStats","isRequestDeduplicating","key","isRunning","cancelDeduplicatedRequest","cancel","waitForDeduplicatedRequest","waitFor","getDeduplicationTasksInfo","getAllTaskInfo","cleanupTimeoutDeduplicationTasks","timeoutMs","cleanupTimeoutTasks","configureDeduplicationKeyGenerator","Date","now"],"mappings":"uHA0BaA,EASX,WAAAC,CAAYC,EAA4B,CAAA,GAPhCC,KAAAC,eAAiB,IAAIC,IACrBF,KAAAG,aAA8B,GAC9BH,KAAAI,eAAiB,EACjBJ,KAAAK,iBAAkB,EAKxBL,KAAKD,OAAS,CACZO,cAAeP,EAAOO,eAAiB,GACvCC,aAAcR,EAAOQ,cAAgB,IACrCC,cAAeT,EAAOS,gBAAiB,GAIzCR,KAAKS,qBAAuB,IAAIC,uBAChCV,KAAKW,aAAe,IAAIC,EAAAA,0BAA0B,CAChDC,eAAe,EACfC,YAAY,EACZC,eAAe,EACfC,aAAa,GAEjB,CAKA,aAAMC,CACJC,EACAnB,GAGA,GAAIC,KAAKD,QAAQS,cAAe,CAC9B,MAAMW,EAAmBnB,KAAKW,aAAaS,SAASrB,GAGpD,OAAOC,KAAKS,qBAAqBQ,QAC/BE,EACA,IAAMnB,KAAKqB,8BAA8BH,EAAWnB,GAExD,CAGA,OAAOC,KAAKqB,8BAA8BH,EAAWnB,EACvD,CAKQ,mCAAMsB,CACZH,EACAnB,GAEA,OAAO,IAAIuB,QAAyB,CAACC,EAASC,KAG5C,MAAMC,EAAuB,CAC3BC,GAHa1B,KAAK2B,iBAIlBV,QAASC,EACTK,QAAAA,EACAC,OAAAA,EACAzB,OAAAA,GAIEC,KAAKG,aAAayB,QAAU5B,KAAKD,QAAQQ,aAC3CiB,EAAO,IAAIK,MAAM,0BAKf7B,KAAKC,eAAe6B,KAAO9B,KAAKD,QAAQO,cACrCN,KAAK+B,YAAYN,GAItBzB,KAAKG,aAAa6B,KAAKP,IAG7B,CAKQ,iBAAMM,CAAyBN,GACrCzB,KAAKC,eAAegC,IAAIR,EAAKC,IAE7B,IACE,MAAMQ,QAAeT,EAAKR,UAC1BQ,EAAKF,QAAQW,EACf,CAAA,MACOC,GACLV,EAAKD,OAAOW,EACd,CAAA,QAEEnC,KAAKC,eAAemC,OAAOX,EAAKC,IAChC1B,KAAKqC,cACP,CACF,CAKQ,YAAAA,GAEN,IAAIrC,KAAKK,gBAIT,CAAAL,KAAKK,iBAAkB,EAEvB,IAEE,KACEL,KAAKG,aAAayB,OAAS,GACxB5B,KAAKC,eAAe6B,KAAO9B,KAAKD,QAAQO,eAC3C,CACA,MAAMgC,EAAWtC,KAAKG,aAAaoC,QAC/BD,GACGtC,KAAK+B,YAAYO,EAE1B,CACF,CAAA,QAEEtC,KAAKK,iBAAkB,CACzB,CAAA,CACF,CAKA,WAAAmC,CAAYC,EAAS,mBACCzC,KAAKG,aAAauC,OAAO,GACjCC,QAASlB,IACnBA,EAAKD,OAAO,IAAIK,MAAMY,KAE1B,CAKA,SAAAG,GAOE,MAAO,CACLC,YAAa7C,KAAKC,eAAe6B,KACjCgB,YAAa9C,KAAKG,aAAayB,OAC/BtB,cAAeN,KAAKD,QAAQO,cAC5BC,aAAcP,KAAKD,QAAQQ,aAC3BC,cAAeR,KAAKS,qBAAqBsC,WAE7C,CAKA,YAAAC,CAAajD,GACXkD,OAAOC,OAAOlD,KAAKD,OAAQA,GAG3BC,KAAKqC,cACP,CAKA,SAAAc,GACE,MAAO,IAAKnD,KAAKD,OACnB,CAKA,qBAAAqD,GACE,OAAOpD,KAAKS,qBAAqBsC,UACnC,CAKA,uBAAAM,GACErD,KAAKS,qBAAqB6C,YAC5B,CAKA,sBAAAC,CAAuBxD,GACrB,MAAMyD,EAAMxD,KAAKW,aAAaS,SAASrB,GACvC,OAAOC,KAAKS,qBAAqBgD,UAAUD,EAC7C,CAKA,yBAAAE,CAA0B3D,GACxB,MAAMyD,EAAMxD,KAAKW,aAAaS,SAASrB,GACvCC,KAAKS,qBAAqBkD,OAAOH,EACnC,CAKA,gCAAMI,CAAwC7D,GAC5C,MAAMyD,EAAMxD,KAAKW,aAAaS,SAASrB,GACvC,OAAOC,KAAKS,qBAAqBoD,QAAWL,EAC9C,CAKA,yBAAAM,GAME,OAAO9D,KAAKS,qBAAqBsD,gBACnC,CAKA,gCAAAC,CAAiCC,EAAoB,KACnD,OAAOjE,KAAKS,qBAAqByD,oBAAoBD,EACvD,CAKA,kCAAAE,CAAmCpE,GACjCC,KAAKW,aAAe,IAAIC,EAAAA,0BAA0Bb,EACpD,CAKQ,cAAA4B,GACN,MAAO,UAAU3B,KAAKI,kBAAkBgE,KAAKC,OAC/C,yaAOAtE,GAEA,OAAO,IAAIF,EAAmBE,EAChC"}