{"version":3,"file":"warmup.cjs","sources":["../../src/utils/warmup.ts"],"sourcesContent":["/**\n * 连接预热和 Keep-Alive 管理器\n * \n * 提供连接预热、DNS预解析、TCP连接复用等功能\n * 提升首次请求性能和整体吞吐量\n */\n\nimport type { HttpClient } from '../types'\n\n/**\n * 预热配置\n */\nexport interface WarmupConfig {\n  /** 要预热的URL列表 */\n  urls: string[]\n  /** 预热方法，默认为 HEAD */\n  method?: 'HEAD' | 'OPTIONS' | 'GET'\n  /** 并发预热数量 */\n  concurrency?: number\n  /** 预热超时时间（毫秒） */\n  timeout?: number\n  /** 是否启用DNS预解析 */\n  dnsPrefetch?: boolean\n  /** 是否启用预连接 */\n  preconnect?: boolean\n  /** 失败时是否静默（不抛出错误） */\n  silent?: boolean\n}\n\n/**\n * 预热结果\n */\nexport interface WarmupResult {\n  /** 成功预热的URL */\n  succeeded: string[]\n  /** 失败的URL */\n  failed: Array<{ url: string, error: Error }>\n  /** 总耗时 */\n  duration: number\n  /** 统计信息 */\n  stats: {\n    total: number\n    success: number\n    failed: number\n    averageTime: number\n  }\n}\n\n/**\n * Keep-Alive 配置\n */\nexport interface KeepAliveConfig {\n  /** 是否启用 Keep-Alive */\n  enabled?: boolean\n  /** 最大空闲时间（毫秒） */\n  maxIdleTime?: number\n  /** 最大连接数 */\n  maxConnections?: number\n  /** 每个主机的最大连接数 */\n  maxConnectionsPerHost?: number\n}\n\n/**\n * 连接预热管理器\n * \n * @example\n * ```typescript\n * const warmupManager = new WarmupManager(client)\n * \n * // 预热关键API端点\n * await warmupManager.warmup({\n *   urls: [\n *     'https://api.example.com/users',\n *     'https://api.example.com/posts',\n *     'https://api.example.com/comments'\n *   ],\n *   concurrency: 3\n * })\n * \n * // 预连接到多个域名\n * warmupManager.preconnect([\n *   'https://api.example.com',\n *   'https://cdn.example.com',\n *   'https://static.example.com'\n * ])\n * ```\n */\nexport class WarmupManager {\n  private client: HttpClient\n  private preconnectedDomains = new Set<string>()\n\n  constructor(client: HttpClient) {\n    this.client = client\n  }\n\n  /**\n   * 预热连接\n   * \n   * 通过发送轻量级请求（HEAD/OPTIONS）来建立连接，\n   * 使后续请求可以复用连接，减少延迟\n   * \n   * @param config - 预热配置\n   * @returns 预热结果\n   */\n  async warmup(config: WarmupConfig): Promise<WarmupResult> {\n    const {\n      urls,\n      method = 'HEAD',\n      concurrency = 5,\n      timeout = 5000,\n      dnsPrefetch = true,\n      preconnect = true,\n      silent = true,\n    } = config\n\n    const startTime = Date.now()\n    const succeeded: string[] = []\n    const failed: Array<{ url: string, error: Error }> = []\n    const timings: number[] = []\n\n    // DNS 预解析\n    if (dnsPrefetch && typeof document !== 'undefined') {\n      this.dnsPrefetch(urls)\n    }\n\n    // 预连接\n    if (preconnect && typeof document !== 'undefined') {\n      const origins = [...new Set(urls.map(url => new URL(url).origin))]\n      this.preconnect(origins)\n    }\n\n    // 分批并发预热\n    const batches = this.createBatches(urls, concurrency)\n\n    for (const batch of batches) {\n      await Promise.all(\n        batch.map(async (url) => {\n          const requestStartTime = Date.now()\n\n          try {\n            await this.client.request({\n              url,\n              method,\n              timeout,\n              // 标记为预热请求，避免触发某些拦截器\n              metadata: { isWarmup: true },\n            })\n\n            const requestTime = Date.now() - requestStartTime\n            timings.push(requestTime)\n            succeeded.push(url)\n          }\n          catch (error) {\n            if (!silent) {\n              console.warn(`预热失败 ${url}:`, error)\n            }\n            failed.push({\n              url,\n              error: error as Error,\n            })\n          }\n        }),\n      )\n    }\n\n    const duration = Date.now() - startTime\n    const averageTime = timings.length > 0\n      ? timings.reduce((a, b) => a + b, 0) / timings.length\n      : 0\n\n    return {\n      succeeded,\n      failed,\n      duration,\n      stats: {\n        total: urls.length,\n        success: succeeded.length,\n        failed: failed.length,\n        averageTime,\n      },\n    }\n  }\n\n  /**\n   * DNS 预解析\n   * \n   * 在浏览器中添加 dns-prefetch link 标签\n   * \n   * @param urls - URL列表\n   */\n  dnsPrefetch(urls: string[]): void {\n    if (typeof document === 'undefined') {\n      return\n    }\n\n    const domains = [...new Set(\n      urls.map((url) => {\n        try {\n          return new URL(url).origin\n        }\n        catch {\n          return null\n        }\n      }).filter(Boolean) as string[],\n    )]\n\n    domains.forEach((domain) => {\n      if (!this.hasLinkTag(domain, 'dns-prefetch')) {\n        const link = document.createElement('link')\n        link.rel = 'dns-prefetch'\n        link.href = domain\n        document.head.appendChild(link)\n      }\n    })\n  }\n\n  /**\n   * 预连接\n   * \n   * 在浏览器中添加 preconnect link 标签\n   * 建立早期连接（DNS + TCP + TLS）\n   * \n   * @param origins - 源地址列表\n   */\n  preconnect(origins: string[]): void {\n    if (typeof document === 'undefined') {\n      return\n    }\n\n    origins.forEach((origin) => {\n      if (this.preconnectedDomains.has(origin)) {\n        return\n      }\n\n      if (!this.hasLinkTag(origin, 'preconnect')) {\n        const link = document.createElement('link')\n        link.rel = 'preconnect'\n        link.href = origin\n        link.crossOrigin = 'anonymous'\n        document.head.appendChild(link)\n\n        this.preconnectedDomains.add(origin)\n      }\n    })\n  }\n\n  /**\n   * 预加载资源\n   * \n   * @param url - 资源URL\n   * @param as - 资源类型\n   */\n  preload(url: string, as: 'fetch' | 'script' | 'style' | 'image' = 'fetch'): void {\n    if (typeof document === 'undefined') {\n      return\n    }\n\n    if (!this.hasLinkTag(url, 'preload')) {\n      const link = document.createElement('link')\n      link.rel = 'preload'\n      link.href = url\n      link.as = as\n      document.head.appendChild(link)\n    }\n  }\n\n  /**\n   * 批量预热（自动重试失败的URL）\n   * \n   * @param config - 预热配置\n   * @param maxRetries - 最大重试次数\n   * @returns 预热结果\n   */\n  async warmupWithRetry(\n    config: WarmupConfig,\n    maxRetries = 2,\n  ): Promise<WarmupResult> {\n    let result = await this.warmup(config)\n\n    for (let retry = 0; retry < maxRetries && result.failed.length > 0; retry++) {\n      const failedUrls = result.failed.map(f => f.url)\n\n      console.info(`Retrying ${failedUrls.length} failed URLs...`)\n\n      const retryResult = await this.warmup({\n        ...config,\n        urls: failedUrls,\n      })\n\n      // 合并结果\n      result = {\n        succeeded: [...result.succeeded, ...retryResult.succeeded],\n        failed: retryResult.failed,\n        duration: result.duration + retryResult.duration,\n        stats: {\n          total: config.urls.length,\n          success: result.succeeded.length + retryResult.succeeded.length,\n          failed: retryResult.failed.length,\n          averageTime: (result.stats.averageTime + retryResult.stats.averageTime) / 2,\n        },\n      }\n    }\n\n    return result\n  }\n\n  /**\n   * 智能预热\n   * \n   * 根据访问频率自动预热常用端点\n   * \n   * @param urlPatterns - URL模式列表\n   * @param threshold - 预热阈值（访问次数）\n   */\n  async smartWarmup(\n    urlPatterns: string[],\n    threshold = 5,\n  ): Promise<WarmupResult> {\n    // 这里可以集成访问统计，实际应用中可以从本地存储读取\n    const accessCounts = this.getAccessCounts()\n    const frequentUrls = urlPatterns.filter(\n      url => (accessCounts.get(url) || 0) >= threshold,\n    )\n\n    if (frequentUrls.length === 0) {\n      return {\n        succeeded: [],\n        failed: [],\n        duration: 0,\n        stats: { total: 0, success: 0, failed: 0, averageTime: 0 },\n      }\n    }\n\n    return this.warmup({\n      urls: frequentUrls,\n      silent: true,\n    })\n  }\n\n  /**\n   * 清理预热资源\n   */\n  cleanup(): void {\n    if (typeof document === 'undefined') {\n      return\n    }\n\n    // 移除预热相关的 link 标签\n    const links = document.querySelectorAll(\n      'link[rel=\"dns-prefetch\"], link[rel=\"preconnect\"], link[rel=\"preload\"]',\n    )\n\n    links.forEach(link => link.remove())\n\n    this.preconnectedDomains.clear()\n  }\n\n  /**\n   * 创建批次\n   */\n  private createBatches<T>(items: T[], batchSize: number): T[][] {\n    const batches: T[][] = []\n\n    for (let i = 0; i < items.length; i += batchSize) {\n      batches.push(items.slice(i, i + batchSize))\n    }\n\n    return batches\n  }\n\n  /**\n   * 检查是否已存在 link 标签\n   */\n  private hasLinkTag(href: string, rel: string): boolean {\n    if (typeof document === 'undefined') {\n      return false\n    }\n\n    return !!document.querySelector(`link[rel=\"${rel}\"][href=\"${href}\"]`)\n  }\n\n  /**\n   * 获取访问计数（模拟，实际应该从本地存储读取）\n   */\n  private getAccessCounts(): Map<string, number> {\n    // 实际应用中，这应该从 localStorage 或其他持久化存储中读取\n    return new Map()\n  }\n}\n\n/**\n * 创建预热管理器\n * \n * @param client - HTTP 客户端实例\n * @returns 预热管理器实例\n */\nexport function createWarmupManager(client: HttpClient): WarmupManager {\n  return new WarmupManager(client)\n}\n\n/**\n * Keep-Alive 管理器\n * \n * 管理长连接，优化连接复用\n */\nexport class KeepAliveManager {\n  private config: KeepAliveConfig\n  private connections = new Map<string, {\n    count: number\n    lastUsed: number\n    timer?: ReturnType<typeof setTimeout>\n  }>()\n\n  constructor(config: KeepAliveConfig = {}) {\n    this.config = {\n      enabled: true,\n      maxIdleTime: 60000, // 60秒\n      maxConnections: 100,\n      maxConnectionsPerHost: 6,\n      ...config,\n    }\n  }\n\n  /**\n   * 获取或创建连接\n   */\n  acquire(host: string): void {\n    if (!this.config?.enabled) {\n      return\n    }\n\n    let connection = this.connections.get(host)\n\n    if (!connection) {\n      connection = { count: 0, lastUsed: Date.now() }\n      this.connections.set(host, connection)\n    }\n\n    connection.count++\n    connection.lastUsed = Date.now()\n\n    // 清除现有定时器\n    if (connection.timer) {\n      clearTimeout(connection.timer)\n    }\n\n    // 设置空闲超时\n    connection.timer = setTimeout(() => {\n      this.release(host)\n    }, this.config?.maxIdleTime)\n  }\n\n  /**\n   * 释放连接\n   */\n  release(host: string): void {\n    const connection = this.connections.get(host)\n\n    if (!connection) {\n      return\n    }\n\n    connection.count--\n\n    if (connection.count <= 0) {\n      if (connection.timer) {\n        clearTimeout(connection.timer)\n      }\n      this.connections.delete(host)\n    }\n  }\n\n  /**\n   * 获取连接统计\n   */\n  getStats() {\n    const stats = {\n      totalConnections: this.connections.size,\n      activeConnections: 0,\n      idleConnections: 0,\n      connectionsByHost: {} as Record<string, number>,\n    }\n\n    const now = Date.now()\n\n    this.connections.forEach((connection, host) => {\n      const idle = now - connection.lastUsed\n\n      const halfIdle = (this.config?.maxIdleTime ?? 0) / 2\n      if (idle > halfIdle) {\n        stats.idleConnections++\n      }\n      else {\n        stats.activeConnections++\n      }\n\n      stats.connectionsByHost[host] = connection.count\n    })\n\n    return stats\n  }\n\n  /**\n   * 清理所有连接\n   */\n  cleanup(): void {\n    this.connections.forEach((connection) => {\n      if (connection.timer) {\n        clearTimeout(connection.timer)\n      }\n    })\n\n    this.connections.clear()\n  }\n\n  /**\n   * 更新配置\n   */\n  updateConfig(config: Partial<KeepAliveConfig>): void {\n    this.config = { ...this.config, ...config }\n  }\n}\n\n/**\n * 创建 Keep-Alive 管理器\n */\nexport function createKeepAliveManager(config?: KeepAliveConfig): KeepAliveManager {\n  return new KeepAliveManager(config)\n}\n\n/**\n * 全局预热工具函数\n * \n * @param client - HTTP 客户端\n * @param urls - 要预热的URL列表\n * @param options - 预热选项\n */\nexport async function warmupConnections(\n  client: HttpClient,\n  urls: string[],\n  options?: Partial<WarmupConfig>,\n): Promise<WarmupResult> {\n  const manager = new WarmupManager(client)\n  return manager.warmup({ urls, ...options })\n}\n"],"names":["WarmupManager","constructor","client","this","preconnectedDomains","Set","warmup","config","urls","method","concurrency","timeout","dnsPrefetch","preconnect","silent","startTime","Date","now","succeeded","failed","timings","document","origins","map","url","URL","origin","batches","createBatches","batch","Promise","all","async","requestStartTime","request","metadata","isWarmup","requestTime","push","error","duration","averageTime","length","reduce","a","b","stats","total","success","filter","Boolean","forEach","domain","hasLinkTag","link","createElement","rel","href","head","appendChild","has","crossOrigin","add","preload","as","warmupWithRetry","maxRetries","result","retry","failedUrls","f","retryResult","smartWarmup","urlPatterns","threshold","accessCounts","getAccessCounts","frequentUrls","get","cleanup","querySelectorAll","remove","clear","items","batchSize","i","slice","querySelector","Map","KeepAliveManager","connections","enabled","maxIdleTime","maxConnections","maxConnectionsPerHost","acquire","host","connection","count","lastUsed","set","timer","clearTimeout","setTimeout","release","delete","getStats","totalConnections","size","activeConnections","idleConnections","connectionsByHost","updateConfig","options"],"mappings":"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"}