{"version":3,"file":"smartRetry.cjs","sources":["../../src/utils/smartRetry.ts"],"sourcesContent":["/**\r\n * 智能重试策略\r\n *\r\n * 根据错误类型、HTTP状态码、网络状况等智能决定是否重试\r\n */\r\n\r\nimport type { HttpError } from '../types'\r\n\r\n/**\r\n * 重试策略类型\r\n */\r\nexport enum RetryStrategy {\r\n /** 立即重试 */\r\n IMMEDIATE = 'immediate',\r\n /** 指数退避 */\r\n EXPONENTIAL = 'exponential',\r\n /** 线性退避 */\r\n LINEAR = 'linear',\r\n /** 固定延迟 */\r\n FIXED = 'fixed',\r\n /** 不重试 */\r\n NONE = 'none',\r\n}\r\n\r\n/**\r\n * 重试决策结果\r\n */\r\nexport interface RetryDecision {\r\n /** 是否应该重试 */\r\n shouldRetry: boolean\r\n /** 重试延迟(ms) */\r\n delay: number\r\n /** 建议的策略 */\r\n strategy: RetryStrategy\r\n /** 决策原因 */\r\n reason: string\r\n}\r\n\r\n/**\r\n * 智能重试配置\r\n */\r\nexport interface SmartRetryConfig {\r\n /** 最大重试次数 */\r\n maxRetries?: number\r\n /** 基础延迟(ms) */\r\n baseDelay?: number\r\n /** 最大延迟(ms) */\r\n maxDelay?: number\r\n /** 是否启用网络状态检测 */\r\n checkNetworkStatus?: boolean\r\n /** 可重试的HTTP状态码 */\r\n retryableStatusCodes?: number[]\r\n /** 不可重试的HTTP状态码 */\r\n nonRetryableStatusCodes?: number[]\r\n /** 自定义重试决策函数 */\r\n customDecision?: (error: HttpError, attempt: number) => RetryDecision | null\r\n}\r\n\r\n/**\r\n * 智能重试管理器\r\n *\r\n * @example\r\n * ```typescript\r\n * const retryManager = new SmartRetryManager({\r\n *  maxRetries: 3,\r\n *  checkNetworkStatus: true,\r\n * })\r\n *\r\n * const decision = retryManager.shouldRetry(error, 1)\r\n * if (decision.shouldRetry) {\r\n *  await delay(decision.delay)\r\n *  // 重试请求\r\n * }\r\n * ```\r\n */\r\nexport class SmartRetryManager {\r\n private config: Required<Omit<SmartRetryConfig, 'customDecision'>> & { customDecision?: SmartRetryConfig['customDecision'] }\r\n\r\n // 默认可重试的状态码（服务器错误、网关错误等）\r\n private static readonly DEFAULT_RETRYABLE_STATUS_CODES = [\r\n  408, // Request Timeout\r\n  429, // Too Many Requests\r\n  500, // Internal Server Error\r\n  502, // Bad Gateway\r\n  503, // Service Unavailable\r\n  504, // Gateway Timeout\r\n ]\r\n\r\n // 绝对不可重试的状态码（客户端错误）\r\n private static readonly DEFAULT_NON_RETRYABLE_STATUS_CODES = [\r\n  400, // Bad Request\r\n  401, // Unauthorized\r\n  403, // Forbidden\r\n  404, // Not Found\r\n  405, // Method Not Allowed\r\n  422, // Unprocessable Entity\r\n ]\r\n\r\n constructor(config: SmartRetryConfig = {}) {\r\n  this.config = {\r\n   maxRetries: config.maxRetries ?? 3,\r\n   baseDelay: config.baseDelay ?? 1000,\r\n   maxDelay: config.maxDelay ?? 30000,\r\n   checkNetworkStatus: config.checkNetworkStatus ?? true,\r\n   retryableStatusCodes: config.retryableStatusCodes ?? SmartRetryManager.DEFAULT_RETRYABLE_STATUS_CODES,\r\n   nonRetryableStatusCodes: config.nonRetryableStatusCodes ?? SmartRetryManager.DEFAULT_NON_RETRYABLE_STATUS_CODES,\r\n   customDecision: config.customDecision,\r\n  }\r\n }\r\n\r\n /**\r\n  * 判断是否应该重试\r\n  */\r\n shouldRetry(error: HttpError, attempt: number): RetryDecision {\r\n  // 超过最大重试次数\r\n  if (attempt >= this.config?.maxRetries) {\r\n   return {\r\n    shouldRetry: false,\r\n    delay: 0,\r\n    strategy: RetryStrategy.NONE,\r\n    reason: `已达到最大重试次数 ${this.config?.maxRetries}`,\r\n   }\r\n  }\r\n\r\n  // 使用自定义决策函数\r\n  if (this.config?.customDecision) {\r\n   const customDecision = this.config?.customDecision(error, attempt)\r\n   if (customDecision) {\r\n    return customDecision\r\n   }\r\n  }\r\n\r\n  // 检查网络状态\r\n  if (this.config?.checkNetworkStatus && this.isOffline()) {\r\n   return {\r\n    shouldRetry: false,\r\n    delay: 0,\r\n    strategy: RetryStrategy.NONE,\r\n    reason: '当前网络离线',\r\n   }\r\n  }\r\n\r\n  // 根据错误类型判断\r\n  const statusCode = error.response?.status\r\n\r\n  // 没有状态码，可能是网络错误\r\n  if (!statusCode) {\r\n   return this.createRetryDecision(\r\n    true,\r\n    attempt,\r\n    RetryStrategy.EXPONENTIAL,\r\n    '网络错误，使用指数退避重试',\r\n   )\r\n  }\r\n\r\n  // 检查是否在不可重试列表中\r\n  if (this.config?.nonRetryableStatusCodes.includes(statusCode)) {\r\n   return {\r\n    shouldRetry: false,\r\n    delay: 0,\r\n    strategy: RetryStrategy.NONE,\r\n    reason: `状态码 ${statusCode} 不可重试（客户端错误）`,\r\n   }\r\n  }\r\n\r\n  // 检查是否在可重试列表中\r\n  if (this.config?.retryableStatusCodes.includes(statusCode)) {\r\n   return this.createRetryDecision(\r\n    true,\r\n    attempt,\r\n    this.getStrategyForStatusCode(statusCode),\r\n    `状态码 ${statusCode} 可重试`,\r\n   )\r\n  }\r\n\r\n  // 5xx错误默认重试\r\n  if (statusCode >= 500 && statusCode < 600) {\r\n   return this.createRetryDecision(\r\n    true,\r\n    attempt,\r\n    RetryStrategy.EXPONENTIAL,\r\n    `服务器错误 ${statusCode}，使用指数退避重试`,\r\n   )\r\n  }\r\n\r\n  // 其他情况不重试\r\n  return {\r\n   shouldRetry: false,\r\n   delay: 0,\r\n   strategy: RetryStrategy.NONE,\r\n   reason: `状态码 ${statusCode} 不在重试范围内`,\r\n  }\r\n }\r\n\r\n /**\r\n  * 创建重试决策\r\n  */\r\n private createRetryDecision(\r\n  shouldRetry: boolean,\r\n  attempt: number,\r\n  strategy: RetryStrategy,\r\n  reason: string,\r\n ): RetryDecision {\r\n  return {\r\n   shouldRetry,\r\n   delay: this.calculateDelay(attempt, strategy),\r\n   strategy,\r\n   reason,\r\n  }\r\n }\r\n\r\n /**\r\n  * 根据状态码获取建议的重试策略\r\n  */\r\n private getStrategyForStatusCode(statusCode: number): RetryStrategy {\r\n  switch (statusCode) {\r\n   case 429: // Too Many Requests - 使用指数退避\r\n    return RetryStrategy.EXPONENTIAL\r\n   case 503: // Service Unavailable - 使用线性退避\r\n    return RetryStrategy.LINEAR\r\n   case 504: // Gateway Timeout - 使用固定延迟\r\n    return RetryStrategy.FIXED\r\n   default:\r\n    return RetryStrategy.EXPONENTIAL\r\n  }\r\n }\r\n\r\n /**\r\n  * 计算重试延迟\r\n  */\r\n private calculateDelay(attempt: number, strategy: RetryStrategy): number {\r\n  let delay: number\r\n\r\n  switch (strategy) {\r\n   case RetryStrategy.IMMEDIATE:\r\n    delay = 0\r\n    break\r\n\r\n   case RetryStrategy.EXPONENTIAL:\r\n    // 指数退避: baseDelay * 2^attempt\r\n    delay = this.config?.baseDelay * 2**attempt\r\n    break\r\n\r\n   case RetryStrategy.LINEAR:\r\n    // 线性退避: baseDelay * attempt\r\n    delay = this.config?.baseDelay * attempt\r\n    break\r\n\r\n   case RetryStrategy.FIXED:\r\n    // 固定延迟\r\n    delay = this.config?.baseDelay\r\n    break\r\n\r\n   default:\r\n    delay = 0\r\n  }\r\n\r\n  // 添加随机抖动，避免雷鸣效应\r\n  delay = this.addJitter(delay)\r\n\r\n  // 限制最大延迟\r\n  return Math.min(delay, this.config?.maxDelay)\r\n }\r\n\r\n /**\r\n  * 添加随机抖动（±25%）\r\n  */\r\n private addJitter(delay: number): number {\r\n  const jitter = delay * 0.25\r\n  return delay + (Math.random() * jitter * 2 - jitter)\r\n }\r\n\r\n /**\r\n  * 检查是否离线\r\n  */\r\n private isOffline(): boolean {\r\n  if (typeof navigator !== 'undefined' && 'onLine' in navigator) {\r\n   return !navigator.onLine\r\n  }\r\n  return false\r\n }\r\n\r\n /**\r\n  * 获取重试建议\r\n  */\r\n getRetryAdvice(error: HttpError): string {\r\n  const statusCode = error.response?.status\r\n\r\n  if (!statusCode) {\r\n   return '网络连接失败，请检查网络设置后重试'\r\n  }\r\n\r\n  if (statusCode === 429) {\r\n   return '请求过于频繁，请稍后再试'\r\n  }\r\n\r\n  if (statusCode >= 500) {\r\n   return '服务器暂时不可用，请稍后重试'\r\n  }\r\n\r\n  if (statusCode >= 400 && statusCode < 500) {\r\n   return '请求参数有误，请检查后重试'\r\n  }\r\n\r\n  return '请求失败，请重试'\r\n }\r\n}\r\n\r\n/**\r\n * 创建智能重试管理器\r\n */\r\nexport function createSmartRetryManager(config?: SmartRetryConfig): SmartRetryManager {\r\n return new SmartRetryManager(config)\r\n}\r\n\r\n/**\r\n * 全局智能重试管理器\r\n */\r\nexport const globalSmartRetryManager = new SmartRetryManager()\r\n\r\n/**\r\n * 智能重试拦截器\r\n *\r\n * 自动为失败的请求应用智能重试策略\r\n */\r\nexport function createSmartRetryInterceptor(config?: SmartRetryConfig) {\r\n const retryManager = new SmartRetryManager(config)\r\n const pendingRetries = new Map<string, number>()\r\n\r\n return {\r\n  onRejected: async (error: HttpError): Promise<any> => {\r\n   const requestKey = `${error.config?.method}:${error.config?.url}`\r\n   const attempt = pendingRetries.get(requestKey) ?? 0\r\n\r\n   const decision = retryManager.shouldRetry(error, attempt)\r\n\r\n   if (decision.shouldRetry) {\r\n    pendingRetries.set(requestKey, attempt + 1)\r\n\r\n    // 等待延迟\r\n    await new Promise(resolve => setTimeout(resolve, decision.delay))\r\n\r\n    // 这里需要返回一个重试的promise\r\n    // 实际使用时应该通过拦截器系统重新发起请求\r\n    throw error // 暂时抛出错误，实际应该重试\r\n   }\r\n\r\n   // 清理重试记录\r\n   pendingRetries.delete(requestKey)\r\n\r\n   throw error\r\n  },\r\n }\r\n}\r\n"],"names":["RetryStrategy","IMMEDIATE","EXPONENTIAL","LINEAR","FIXED","NONE","SmartRetryManager","constructor","config","this","maxRetries","baseDelay","maxDelay","checkNetworkStatus","retryableStatusCodes","DEFAULT_RETRYABLE_STATUS_CODES","nonRetryableStatusCodes","DEFAULT_NON_RETRYABLE_STATUS_CODES","customDecision","shouldRetry","error","attempt","delay","strategy","reason","isOffline","statusCode","response","status","includes","createRetryDecision","getStrategyForStatusCode","calculateDelay","addJitter","Math","min","jitter","random","navigator","onLine","getRetryAdvice","globalSmartRetryManager","retryManager","pendingRetries","Map","onRejected","async","requestKey","method","url","get","decision","set","Promise","resolve","setTimeout","delete"],"mappings":"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"}