"use strict";class t{constructor(){this.cache=new Map,this.cleanupInterval=6e4,this.startCleanup()}async get(t){const e=this.cache.get(t);return e?Date.now()-e.timestamp>e.ttl?(this.cache.delete(t),null):(e.metadata&&(e.metadata.lastAccessed=Date.now(),e.metadata.accessCount++),e.data):null}async set(t,e,s=3e5){const a=Date.now();this.cache.set(t,{data:e,timestamp:a,ttl:s,metadata:{createdAt:a,lastAccessed:a,accessCount:0,size:this.calculateSize(e)}})}async delete(t){this.cache.delete(t)}async clear(){this.cache.clear()}async has(t){const e=this.cache.get(t);return!!e&&(!(Date.now()-e.timestamp>e.ttl)||(this.cache.delete(t),!1))}async deleteBatch(t){for(const e of t)this.cache.delete(e)}size(){return this.cache.size}keys(){return Array.from(this.cache.keys())}getMetadata(t){return this.cache.get(t)?.metadata||null}startCleanup(){this.cleanupTimer=setInterval(()=>{this.cleanupExpired()},this.cleanupInterval)}cleanupExpired(){const t=Date.now(),e=[];for(const[s,a]of this.cache.entries())t-a.timestamp>a.ttl&&e.push(s);for(const t of e)this.cache.delete(t)}calculateSize(t){try{return 2*JSON.stringify(t).length}catch{return 0}}destroy(){this.cleanupTimer&&(clearInterval(this.cleanupTimer),this.cleanupTimer=void 0),this.cache.clear()}}class e{constructor(t="http_cache_"){this.prefix=t}async get(t){if(typeof localStorage>"u")return null;try{const e=localStorage.getItem(this.prefix+t);if(!e)return null;const s=JSON.parse(e);return Date.now()-s.timestamp>s.ttl?(await this.delete(t),null):s.data}catch{return null}}async set(t,e,s=3e5){if(!(typeof localStorage>"u"))try{const a={data:e,timestamp:Date.now(),ttl:s};localStorage.setItem(this.prefix+t,JSON.stringify(a))}catch{this.handleStorageQuotaExceeded()}}async delete(t){typeof localStorage>"u"||localStorage.removeItem(this.prefix+t)}async clear(){if(typeof localStorage>"u")return;const t=[];for(let e=0;e<localStorage.length;e++){const s=localStorage.key(e);s?.startsWith(this.prefix)&&t.push(s)}for(const e of t)localStorage.removeItem(e)}async has(t){return!(typeof localStorage>"u")&&null!==localStorage.getItem(this.prefix+t)}handleStorageQuotaExceeded(){const t=[];for(let e=0;e<localStorage.length;e++){const s=localStorage.key(e);if(s?.startsWith(this.prefix))try{const e=JSON.parse(localStorage.getItem(s));t.push({key:s,timestamp:e.timestamp})}catch{}}t.sort((t,e)=>t.timestamp-e.timestamp);const e=Math.ceil(.1*t.length);for(let s=0;s<e;s++)localStorage.removeItem(t[s].key)}}class s extends e{constructor(t="http_session_cache_"){super(t)}async get(t){if(typeof sessionStorage>"u")return null;try{const e=sessionStorage.getItem(this.prefix+t);if(!e)return null;const s=JSON.parse(e);return Date.now()-s.timestamp>s.ttl?(await this.delete(t),null):s.data}catch{return null}}async set(t,e,s=3e5){if(!(typeof sessionStorage>"u"))try{const a={data:e,timestamp:Date.now(),ttl:s};sessionStorage.setItem(this.prefix+t,JSON.stringify(a))}catch{}}async delete(t){typeof sessionStorage>"u"||sessionStorage.removeItem(this.prefix+t)}async clear(){if(typeof sessionStorage>"u")return;const t=[];for(let e=0;e<sessionStorage.length;e++){const s=sessionStorage.key(e);s?.startsWith(this.prefix)&&t.push(s)}for(const e of t)sessionStorage.removeItem(e)}}class a{constructor(t="http_cache_db"){this.storeName="cache",this.db=null,this.dbName=t,this.init()}async init(){if(!(typeof indexedDB>"u"))return new Promise((t,e)=>{const s=indexedDB.open(this.dbName,1);s.onerror=()=>e(s.error),s.onsuccess=()=>{this.db=s.result,t()},s.onupgradeneeded=t=>{const e=t.target.result;e.objectStoreNames.contains(this.storeName)||e.createObjectStore(this.storeName,{keyPath:"key"})}})}async get(t){return this.db||await this.init(),this.db?new Promise((e,s)=>{const a=this.db.transaction([this.storeName],"readonly").objectStore(this.storeName).get(t);a.onerror=()=>s(a.error),a.onsuccess=()=>{const s=a.result;if(s)return Date.now()-s.timestamp>s.ttl?(this.delete(t),void e(null)):void e(s.data);e(null)}}):null}async set(t,e,s=3e5){if(this.db||await this.init(),this.db)return new Promise((a,r)=>{const o=this.db.transaction([this.storeName],"readwrite").objectStore(this.storeName),n={key:t,data:e,timestamp:Date.now(),ttl:s},c=o.put(n);c.onerror=()=>r(c.error),c.onsuccess=()=>a()})}async delete(t){if(this.db||await this.init(),this.db)return new Promise((e,s)=>{const a=this.db.transaction([this.storeName],"readwrite").objectStore(this.storeName).delete(t);a.onerror=()=>s(a.error),a.onsuccess=()=>e()})}async clear(){if(this.db||await this.init(),this.db)return new Promise((t,e)=>{const s=this.db.transaction([this.storeName],"readwrite").objectStore(this.storeName).clear();s.onerror=()=>e(s.error),s.onsuccess=()=>t()})}async has(t){return null!==await this.get(t)}destroy(){this.db&&(this.db.close(),this.db=null)}}exports.IndexedDBCacheStorage=a,exports.LocalStorageCacheStorage=e,exports.MemoryCacheStorage=t,exports.SessionStorageCacheStorage=s,exports.createCacheStorage=function(r="memory"){switch(r){case"local":return new e;case"session":return new s;case"indexeddb":return new a;default:return new t}};
//# sourceMappingURL=cache-storage.cjs.map
