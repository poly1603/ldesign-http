{"version":3,"file":"rate-limit.cjs","sources":["../../src/utils/rate-limit.ts"],"sourcesContent":["/**\r\n * 速率限制管理器\r\n * \r\n * 控制在指定时间窗口内的请求数量\r\n */\r\n\r\n/**\r\n * 速率限制配置\r\n */\r\nexport interface RateLimitConfig {\r\n  /** 最大请求数 */\r\n  maxRequests?: number\r\n  /** 时间窗口（毫秒） */\r\n  timeWindow?: number\r\n  /** 是否启用突发请求 */\r\n  allowBurst?: boolean\r\n  /** 突发请求数量 */\r\n  burstSize?: number\r\n}\r\n\r\n/**\r\n * 速率限制状态\r\n */\r\nexport interface RateLimitStatus {\r\n  /** 当前请求数 */\r\n  currentRequests: number\r\n  /** 最大请求数 */\r\n  maxRequests: number\r\n  /** 时间窗口 */\r\n  timeWindow: number\r\n  /** 下次可用时间 */\r\n  nextAvailableTime: number\r\n  /** 是否已达限制 */\r\n  isLimited: boolean\r\n}\r\n\r\n/**\r\n * 速率限制管理器\r\n */\r\nexport class RateLimitManager {\r\n  private requests: number[] = []\r\n  private config: Required<RateLimitConfig>\r\n  private burstTokens: number\r\n\r\n  constructor(config: RateLimitConfig = {}) {\r\n    this.config = {\r\n      maxRequests: config.maxRequests ?? 100,\r\n      timeWindow: config.timeWindow ?? 60000,\r\n      allowBurst: config.allowBurst ?? false,\r\n      burstSize: config.burstSize ?? 10,\r\n    }\r\n    this.burstTokens = this.config.burstSize\r\n  }\r\n\r\n  /**\r\n   * 检查是否可以发送请求\r\n   */\r\n  canMakeRequest(): boolean {\r\n    const now = Date.now()\r\n\r\n    // 清理过期的请求记录\r\n    this.requests = this.requests.filter(\r\n      timestamp => now - timestamp < this.config.timeWindow,\r\n    )\r\n\r\n    // 检查是否在限制内\r\n    if (this.requests.length < this.config.maxRequests) {\r\n      return true\r\n    }\r\n\r\n    // 检查突发令牌\r\n    if (this.config.allowBurst && this.burstTokens > 0) {\r\n      return true\r\n    }\r\n\r\n    return false\r\n  }\r\n\r\n  /**\r\n   * 记录请求\r\n   */\r\n  recordRequest(): void {\r\n    const now = Date.now()\r\n    \r\n    // 清理过期记录\r\n    this.requests = this.requests.filter(\r\n      timestamp => now - timestamp < this.config.timeWindow,\r\n    )\r\n\r\n    // 如果使用突发令牌\r\n    if (this.requests.length >= this.config.maxRequests && this.config.allowBurst && this.burstTokens > 0) {\r\n      this.burstTokens--\r\n    }\r\n\r\n    this.requests.push(now)\r\n\r\n    // 恢复突发令牌\r\n    this.scheduleBurstTokenRestore()\r\n  }\r\n\r\n  /**\r\n   * 恢复突发令牌\r\n   */\r\n  private scheduleBurstTokenRestore(): void {\r\n    if (!this.config.allowBurst) return\r\n\r\n    // 每秒恢复一个令牌\r\n    const restoreInterval = 1000\r\n    if (this.burstTokens < this.config.burstSize) {\r\n      setTimeout(() => {\r\n        this.burstTokens = Math.min(this.burstTokens + 1, this.config.burstSize)\r\n      }, restoreInterval)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 获取下次可以请求的时间\r\n   */\r\n  getNextAvailableTime(): number {\r\n    if (this.canMakeRequest()) {\r\n      return 0\r\n    }\r\n\r\n    if (this.requests.length === 0) {\r\n      return 0\r\n    }\r\n\r\n    const oldestRequest = Math.min(...this.requests)\r\n    return oldestRequest + this.config.timeWindow - Date.now()\r\n  }\r\n\r\n  /**\r\n   * 等待直到可以发送请求\r\n   */\r\n  async waitForAvailability(): Promise<void> {\r\n    const waitTime = this.getNextAvailableTime()\r\n    if (waitTime > 0) {\r\n      await new Promise(resolve => setTimeout(resolve, waitTime))\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 使用退避策略等待\r\n   */\r\n  async waitWithBackoff(attempt: number = 0): Promise<void> {\r\n    const baseWaitTime = this.getNextAvailableTime()\r\n    if (baseWaitTime <= 0) return\r\n\r\n    // 指数退避\r\n    const backoffTime = Math.min(baseWaitTime * 2**attempt, 30000)\r\n    await new Promise(resolve => setTimeout(resolve, backoffTime))\r\n  }\r\n\r\n  /**\r\n   * 重置计数器\r\n   */\r\n  reset(): void {\r\n    this.requests = []\r\n    this.burstTokens = this.config.burstSize\r\n  }\r\n\r\n  /**\r\n   * 获取当前状态\r\n   */\r\n  getStatus(): RateLimitStatus {\r\n    const now = Date.now()\r\n    this.requests = this.requests.filter(\r\n      timestamp => now - timestamp < this.config.timeWindow,\r\n    )\r\n\r\n    return {\r\n      currentRequests: this.requests.length,\r\n      maxRequests: this.config.maxRequests,\r\n      timeWindow: this.config.timeWindow,\r\n      nextAvailableTime: this.getNextAvailableTime(),\r\n      isLimited: !this.canMakeRequest(),\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 更新配置\r\n   */\r\n  updateConfig(config: Partial<RateLimitConfig>): void {\r\n    Object.assign(this.config, config)\r\n    \r\n    // 更新突发令牌\r\n    if (config.burstSize !== undefined) {\r\n      this.burstTokens = Math.min(this.burstTokens, config.burstSize)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 获取请求历史\r\n   */\r\n  getRequestHistory(): number[] {\r\n    const now = Date.now()\r\n    return this.requests.filter(\r\n      timestamp => now - timestamp < this.config.timeWindow,\r\n    )\r\n  }\r\n\r\n  /**\r\n   * 计算当前速率\r\n   */\r\n  getCurrentRate(): number {\r\n    const now = Date.now()\r\n    const recentRequests = this.requests.filter(\r\n      timestamp => now - timestamp < 1000, // 最近1秒\r\n    )\r\n    return recentRequests.length\r\n  }\r\n\r\n  /**\r\n   * 预测何时可以发送N个请求\r\n   */\r\n  predictAvailabilityForBatch(batchSize: number): number {\r\n    const currentCount = this.requests.length\r\n    const available = this.config.maxRequests - currentCount\r\n\r\n    if (available >= batchSize) {\r\n      return 0 // 立即可用\r\n    }\r\n\r\n    // 计算需要等待多少请求过期\r\n    const needToExpire = batchSize - available\r\n    if (needToExpire > this.requests.length) {\r\n      // 需要等待所有请求过期还不够\r\n      return this.config.timeWindow\r\n    }\r\n\r\n    // 找到第N个请求的时间\r\n    const sortedRequests = [...this.requests].sort()\r\n    const targetRequest = sortedRequests[needToExpire - 1]\r\n    return targetRequest + this.config.timeWindow - Date.now()\r\n  }\r\n}\r\n\r\n/**\r\n * 创建速率限制管理器\r\n */\r\nexport function createRateLimitManager(\r\n  config?: RateLimitConfig,\r\n): RateLimitManager {\r\n  return new RateLimitManager(config)\r\n}\r\n\r\n/**\r\n * 速率限制装饰器\r\n */\r\nexport function rateLimit(config?: RateLimitConfig) {\r\n  const manager = new RateLimitManager(config)\r\n\r\n  return function <T extends (...args: any[]) => Promise<any>>(\r\n    target: T,\r\n  ): T {\r\n    return (async (...args: Parameters<T>) => {\r\n      await manager.waitForAvailability()\r\n      manager.recordRequest()\r\n      return target(...args)\r\n    }) as T\r\n  }\r\n}\r\n\r\n/**\r\n * 全局速率限制管理器实例\r\n */\r\nexport const globalRateLimitManager = new RateLimitManager()"],"names":["RateLimitManager","constructor","config","this","requests","maxRequests","timeWindow","allowBurst","burstSize","burstTokens","canMakeRequest","now","Date","filter","timestamp","length","recordRequest","push","scheduleBurstTokenRestore","setTimeout","Math","min","getNextAvailableTime","waitForAvailability","waitTime","Promise","resolve","waitWithBackoff","attempt","baseWaitTime","backoffTime","reset","getStatus","currentRequests","nextAvailableTime","isLimited","updateConfig","Object","assign","getRequestHistory","getCurrentRate","predictAvailabilityForBatch","batchSize","currentCount","available","needToExpire","sort","globalRateLimitManager","manager","target","args"],"mappings":"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"}