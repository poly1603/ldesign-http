{"version":3,"file":"offline.cjs","sources":["../../src/utils/offline.ts"],"sourcesContent":["/**\n * 离线请求队列功能\n * 在网络离线时缓存请求，网络恢复后自动重试\n */\n\nimport type { RequestConfig, ResponseData } from '../types'\n\n/**\n * 离线队列配置\n */\nexport interface OfflineQueueConfig {\n  /** 是否启用离线队列 */\n  enabled?: boolean\n  /** 最大队列大小 */\n  maxQueueSize?: number\n  /** 持久化存储键 */\n  storageKey?: string\n  /** 是否使用持久化存储 */\n  persistent?: boolean\n  /** 自动重试间隔（毫秒） */\n  retryInterval?: number\n  /** 最大重试次数 */\n  maxRetries?: number\n}\n\n/**\n * 离线请求项\n */\ninterface OfflineRequestItem {\n  id: string\n  config: RequestConfig\n  timestamp: number\n  retries: number\n  resolve: (value: ResponseData) => void\n  reject: (error: any) => void\n}\n\n/**\n * 离线队列统计\n */\nexport interface OfflineQueueStats {\n  /** 队列中的请求数 */\n  queuedCount: number\n  /** 已处理的请求数 */\n  processedCount: number\n  /** 失败的请求数 */\n  failedCount: number\n  /** 成功率 */\n  successRate: number\n}\n\n/**\n * 离线请求队列管理器\n * \n * 功能：\n * 1. 自动检测网络状态\n * 2. 离线时缓存请求\n * 3. 网络恢复后自动重试\n * 4. 支持持久化存储\n * 5. 智能重试策略\n */\nexport class OfflineQueueManager {\n  private config: Required<OfflineQueueConfig>\n  private queue: Map<string, OfflineRequestItem> = new Map()\n  private isOnline: boolean = typeof navigator !== 'undefined' ? navigator.onLine : true\n  private retryTimer?: ReturnType<typeof setTimeout>\n  private stats: OfflineQueueStats = {\n    queuedCount: 0,\n    processedCount: 0,\n    failedCount: 0,\n    successRate: 1,\n  }\n\n  constructor(config: OfflineQueueConfig = {}) {\n    this.config = {\n      enabled: config.enabled ?? true,\n      maxQueueSize: config.maxQueueSize ?? 100,\n      storageKey: config.storageKey ?? 'http_offline_queue',\n      persistent: config.persistent ?? true,\n      retryInterval: config.retryInterval ?? 5000,\n      maxRetries: config.maxRetries ?? 3,\n    }\n\n    // 监听网络状态变化\n    if (typeof window !== 'undefined') {\n      window.addEventListener('online', this.handleOnline.bind(this))\n      window.addEventListener('offline', this.handleOffline.bind(this))\n    }\n\n    // 从持久化存储恢复队列\n    if (this.config?.persistent) {\n      this.loadQueue()\n    }\n  }\n\n  /**\n   * 添加请求到离线队列\n   */\n  async enqueue<T = any>(config: RequestConfig): Promise<ResponseData<T>> {\n    if (!this.config?.enabled) {\n      throw new Error('Offline queue is disabled')\n    }\n\n    if (this.queue.size >= this.config?.maxQueueSize) {\n      throw new Error('Offline queue is full')\n    }\n\n    return new Promise((resolve, reject) => {\n      const id = this.generateId()\n      const item: OfflineRequestItem = {\n        id,\n        config,\n        timestamp: Date.now(),\n        retries: 0,\n        resolve: resolve as any,\n        reject,\n      }\n\n      this.queue.set(id, item)\n      this.stats.queuedCount++\n\n      // 持久化队列\n      if (this.config?.persistent) {\n        this.saveQueue()\n      }\n\n      // 如果在线，立即尝试处理\n      if (this.isOnline) {\n        this.processQueue()\n      }\n    })\n  }\n\n  /**\n   * 处理队列中的请求\n   */\n  private async processQueue(): Promise<void> {\n    if (!this.isOnline || this.queue.size === 0) {\n      return\n    }\n\n    const items = Array.from(this.queue.values())\n\n    for (const item of items) {\n      try {\n        // 这里需要实际的 HTTP 客户端来执行请求\n        // 为了避免循环依赖，这里只是模拟\n        const response = await this.executeRequest(item.config)\n        \n        item.resolve(response)\n        this.queue.delete(item.id)\n        this.stats.processedCount++\n      }\n      catch (error) {\n        item.retries++\n\n        if (item.retries >= this.config?.maxRetries) {\n          item.reject(error)\n          this.queue.delete(item.id)\n          this.stats.failedCount++\n        }\n      }\n    }\n\n    this.updateStats()\n\n    // 持久化队列\n    if (this.config?.persistent) {\n      this.saveQueue()\n    }\n\n    // 如果还有请求，继续重试\n    if (this.queue.size > 0) {\n      this.scheduleRetry()\n    }\n  }\n\n  /**\n   * 执行请求（需要注入实际的 HTTP 客户端）\n   */\n  private async executeRequest(_config: RequestConfig): Promise<ResponseData> {\n    // 这里应该使用实际的 HTTP 客户端\n    throw new Error('Request executor not configured')\n  }\n\n  /**\n   * 调度重试\n   */\n  private scheduleRetry(): void {\n    if (this.retryTimer) {\n      return\n    }\n\n    this.retryTimer = setTimeout(() => {\n      this.retryTimer = undefined\n      this.processQueue()\n    }, this.config?.retryInterval)\n  }\n\n  /**\n   * 处理网络上线事件\n   */\n  private handleOnline(): void {\n    this.isOnline = true\n    this.processQueue()\n  }\n\n  /**\n   * 处理网络离线事件\n   */\n  private handleOffline(): void {\n    this.isOnline = false\n  }\n\n  /**\n   * 保存队列到持久化存储\n   */\n  private saveQueue(): void {\n    if (typeof localStorage === 'undefined') {\n      return\n    }\n\n    try {\n      const data = Array.from(this.queue.values()).map(item => ({\n        id: item.id,\n        config: item.config,\n        timestamp: item.timestamp,\n        retries: item.retries,\n      }))\n\n      localStorage.setItem(this.config?.storageKey, JSON.stringify(data))\n    }\n    catch (error) {\n      console.warn('Failed to save offline queue:', error)\n    }\n  }\n\n  /**\n   * 从持久化存储加载队列\n   */\n  private loadQueue(): void {\n    if (typeof localStorage === 'undefined') {\n      return\n    }\n\n    try {\n      const data = localStorage.getItem(this.config?.storageKey)\n      if (!data) {\n        // 没有存储的队列数据\n      }\n\n      // 注意：这里无法恢复 resolve 和 reject 函数\n      // 实际使用时需要重新创建 Promise\n      // const items = JSON.parse(data)\n    }\n    catch (error) {\n      console.warn('Failed to load offline queue:', error)\n    }\n  }\n\n  /**\n   * 生成唯一 ID\n   */\n  private generateId(): string {\n    return `offline_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`\n  }\n\n  /**\n   * 更新统计信息\n   */\n  private updateStats(): void {\n    const total = this.stats.processedCount + this.stats.failedCount\n    this.stats.successRate = total > 0\n      ? this.stats.processedCount / total\n      : 1\n  }\n\n  /**\n   * 获取统计信息\n   */\n  getStats(): OfflineQueueStats {\n    return {\n      ...this.stats,\n      queuedCount: this.queue.size,\n    }\n  }\n\n  /**\n   * 清空队列\n   */\n  clear(): void {\n    if (this.retryTimer) {\n      clearTimeout(this.retryTimer)\n      this.retryTimer = undefined\n    }\n\n    this.queue.forEach((item) => {\n      item.reject(new Error('Queue cleared'))\n    })\n\n    this.queue.clear()\n\n    if (this.config?.persistent && typeof localStorage !== 'undefined') {\n      localStorage.removeItem(this.config?.storageKey)\n    }\n  }\n\n  /**\n   * 获取网络状态\n   */\n  isNetworkOnline(): boolean {\n    return this.isOnline\n  }\n\n  /**\n   * 销毁离线队列管理器\n   */\n  destroy(): void {\n    if (typeof window !== 'undefined') {\n      window.removeEventListener('online', this.handleOnline.bind(this))\n      window.removeEventListener('offline', this.handleOffline.bind(this))\n    }\n\n    this.clear()\n  }\n}\n\n/**\n * 创建离线队列管理器\n */\nexport function createOfflineQueueManager(config?: OfflineQueueConfig): OfflineQueueManager {\n  return new OfflineQueueManager(config)\n}\n\n"],"names":["OfflineQueueManager","constructor","config","this","queue","Map","isOnline","navigator","onLine","stats","queuedCount","processedCount","failedCount","successRate","enabled","maxQueueSize","storageKey","persistent","retryInterval","maxRetries","window","addEventListener","handleOnline","bind","handleOffline","loadQueue","enqueue","Error","size","Promise","resolve","reject","id","generateId","item","timestamp","Date","now","retries","set","saveQueue","processQueue","items","Array","from","values","response","executeRequest","delete","error","updateStats","scheduleRetry","_config","retryTimer","setTimeout","localStorage","data","map","setItem","JSON","stringify","getItem","Math","random","toString","substring","total","getStats","clear","clearTimeout","forEach","removeItem","isNetworkOnline","destroy","removeEventListener"],"mappings":"mBA6DaA,EAYX,WAAAC,CAAYC,EAA6B,CAAA,GAVjCC,KAAAC,MAAyC,IAAIC,IAC7CF,KAAAG,kBAA2BC,UAAc,MAAcA,UAAUC,OAEjEL,KAAAM,MAA2B,CACjCC,YAAa,EACbC,eAAgB,EAChBC,YAAa,EACbC,YAAa,GAIbV,KAAKD,OAAS,CACZY,QAASZ,EAAOY,UAAW,EAC3BC,aAAcb,EAAOa,cAAgB,IACrCC,WAAYd,EAAOc,YAAc,qBACjCC,WAAYf,EAAOe,aAAc,EACjCC,cAAehB,EAAOgB,eAAiB,IACvCC,WAAYjB,EAAOiB,YAAc,UAIxBC,OAAW,MACpBA,OAAOC,iBAAiB,SAAUlB,KAAKmB,aAAaC,KAAKpB,OACzDiB,OAAOC,iBAAiB,UAAWlB,KAAKqB,cAAcD,KAAKpB,QAIzDA,KAAKD,QAAQe,YACfd,KAAKsB,WAET,CAKA,aAAMC,CAAiBxB,GACrB,IAAKC,KAAKD,QAAQY,QAChB,MAAM,IAAIa,MAAM,6BAGlB,GAAIxB,KAAKC,MAAMwB,MAAQzB,KAAKD,QAAQa,aAClC,MAAM,IAAIY,MAAM,yBAGlB,OAAO,IAAIE,QAAQ,CAACC,EAASC,KAC3B,MAAMC,EAAK7B,KAAK8B,aACVC,EAA2B,CAC/BF,GAAAA,EACA9B,OAAAA,EACAiC,UAAWC,KAAKC,MAChBC,QAAS,EACTR,QAASA,EACTC,OAAAA,GAGF5B,KAAKC,MAAMmC,IAAIP,EAAIE,GACnB/B,KAAKM,MAAMC,cAGPP,KAAKD,QAAQe,YACfd,KAAKqC,YAIHrC,KAAKG,UACPH,KAAKsC,gBAGX,CAKQ,kBAAMA,GACZ,IAAKtC,KAAKG,UAAgC,IAApBH,KAAKC,MAAMwB,KAC/B,OAGF,MAAMc,EAAQC,MAAMC,KAAKzC,KAAKC,MAAMyC,UAEpC,IAAA,MAAWX,KAAQQ,EACjB,IAGE,MAAMI,QAAiB3C,KAAK4C,eAAeb,EAAKhC,QAEhDgC,EAAKJ,QAAQgB,GACb3C,KAAKC,MAAM4C,OAAOd,EAAKF,IACvB7B,KAAKM,MAAME,gBACb,CAAA,MACOsC,GACLf,EAAKI,UAEDJ,EAAKI,SAAWnC,KAAKD,QAAQiB,aAC/Be,EAAKH,OAAOkB,GACZ9C,KAAKC,MAAM4C,OAAOd,EAAKF,IACvB7B,KAAKM,MAAMG,cAEf,CAGFT,KAAK+C,cAGD/C,KAAKD,QAAQe,YACfd,KAAKqC,YAIHrC,KAAKC,MAAMwB,KAAO,GACpBzB,KAAKgD,eAET,CAKQ,oBAAMJ,CAAeK,GAE3B,MAAM,IAAIzB,MAAM,kCAClB,CAKQ,aAAAwB,GACFhD,KAAKkD,aAITlD,KAAKkD,WAAaC,WAAW,KAC3BnD,KAAKkD,gBAAa,EAClBlD,KAAKsC,gBACJtC,KAAKD,QAAQgB,eAClB,CAKQ,YAAAI,GACNnB,KAAKG,UAAW,EAChBH,KAAKsC,cACP,CAKQ,aAAAjB,GACNrB,KAAKG,UAAW,CAClB,CAKQ,SAAAkC,GACN,YAAWe,aAAiB,KAI5B,IACE,MAAMC,EAAOb,MAAMC,KAAKzC,KAAKC,MAAMyC,UAAUY,IAAIvB,IAAAA,CAC/CF,GAAIE,EAAKF,GACT9B,OAAQgC,EAAKhC,OACbiC,UAAWD,EAAKC,UAChBG,QAASJ,EAAKI,WAGhBiB,aAAaG,QAAQvD,KAAKD,QAAQc,WAAY2C,KAAKC,UAAUJ,GAC/D,CAAA,MACOP,GAEP,CACF,CAKQ,SAAAxB,GACN,YAAW8B,aAAiB,KAI5B,IACeA,aAAaM,QAAQ1D,KAAKD,QAAQc,WAQjD,CAAA,MACOiC,GAEP,CACF,CAKQ,UAAAhB,GACN,MAAO,WAAWG,KAAKC,SAASyB,KAAKC,SAASC,SAAS,IAAIC,UAAU,EAAG,IAC1E,CAKQ,WAAAf,GACN,MAAMgB,EAAQ/D,KAAKM,MAAME,eAAiBR,KAAKM,MAAMG,YACrDT,KAAKM,MAAMI,YAAcqD,EAAQ,EAC7B/D,KAAKM,MAAME,eAAiBuD,EAC5B,CACN,CAKA,QAAAC,GACE,MAAO,IACFhE,KAAKM,MACRC,YAAaP,KAAKC,MAAMwB,KAE5B,CAKA,KAAAwC,GACMjE,KAAKkD,aACPgB,aAAalE,KAAKkD,YAClBlD,KAAKkD,gBAAa,GAGpBlD,KAAKC,MAAMkE,QAASpC,IAClBA,EAAKH,OAAO,IAAIJ,MAAM,oBAGxBxB,KAAKC,MAAMgE,QAEPjE,KAAKD,QAAQe,mBAAqBsC,aAAiB,KACrDA,aAAagB,WAAWpE,KAAKD,QAAQc,WAEzC,CAKA,eAAAwD,GACE,OAAOrE,KAAKG,QACd,CAKA,OAAAmE,UACarD,OAAW,MACpBA,OAAOsD,oBAAoB,SAAUvE,KAAKmB,aAAaC,KAAKpB,OAC5DiB,OAAOsD,oBAAoB,UAAWvE,KAAKqB,cAAcD,KAAKpB,QAGhEA,KAAKiE,OACP,kEAMI,SAAoClE,GACxC,OAAO,IAAIF,EAAoBE,EACjC"}