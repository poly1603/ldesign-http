"use strict";const e={networkReconnect:{name:"network-reconnect",priority:10,canHandle:e=>!0===e.isNetworkError,recover:async e=>{try{return(await fetch("/ping",{method:"HEAD",cache:"no-cache",signal:AbortSignal.timeout(5e3)})).ok}catch{return!1}}},authRefresh:{name:"auth-refresh",priority:20,canHandle:e=>401===e.response?.status,recover:async e=>{try{const e=localStorage.getItem("refreshToken");if(!e)return!1;const t=await fetch("/auth/refresh",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({refreshToken:e})});if(t.ok){const e=await t.json();return localStorage.setItem("accessToken",e.accessToken),localStorage.setItem("refreshToken",e.refreshToken),!0}}catch{localStorage.removeItem("accessToken"),localStorage.removeItem("refreshToken")}return!1}},serviceFallback:{name:"service-fallback",priority:5,canHandle:e=>{const t=e.response?.status;return 503===t||502===t||504===t},recover:async e=>{const t=e.config?.url?.replace("/api/","/api-fallback/");if(t&&t!==e.config?.url)try{return(await fetch(t,{method:"HEAD",signal:AbortSignal.timeout(3e3)})).ok}catch{return!1}return!1}},cacheFailback:{name:"cache-fallback",priority:1,canHandle:e=>"GET"===e.config?.method?.toUpperCase(),recover:async e=>{try{const t=`http_cache_${e.config?.url}`,r=localStorage.getItem(t);if(r){const e=JSON.parse(r);if(Date.now()-e.timestamp<864e5)return!0}}catch{}return!1}}};exports.ErrorRecoveryManager=class{constructor(){this.strategies=[],this.addStrategy(e.authRefresh),this.addStrategy(e.networkReconnect),this.addStrategy(e.serviceFallback),this.addStrategy(e.cacheFailback)}addStrategy(e){this.strategies.push(e),this.strategies.sort((e,t)=>(t.priority||0)-(e.priority||0))}removeStrategy(e){this.strategies=this.strategies.filter(t=>t.name!==e)}async attemptRecovery(e){for(const t of this.strategies)if(t.canHandle(e))try{if(await t.recover(e))return{recovered:!0,strategy:t.name}}catch{continue}return{recovered:!1}}getStrategies(){return[...this.strategies]}clearStrategies(){this.strategies=[]}async attemptBatchRecovery(e){const t=new Map;return await Promise.all(e.map(async e=>{const r=await this.attemptRecovery(e);t.set(e,r)})),t}},exports.builtInStrategies=e;
//# sourceMappingURL=error-recovery.cjs.map
