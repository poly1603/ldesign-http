{"version":3,"file":"helpers.cjs","sources":["../../src/utils/helpers.ts"],"sourcesContent":["/**\n * 实用工具函数模块\n * \n * 提供防抖、节流、请求合并等常用功能\n */\n\n/**\n * 防抖函数\n * \n * 在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时\n * \n * @param fn - 要防抖的函数\n * @param delay - 延迟时间（毫秒）\n * @returns 防抖后的函数\n * \n * @example\n * ```typescript\n * const debouncedSearch = debounce((query: string) => {\n *   \n * }, 300)\n * \n * // 只有最后一次调用会执行\n * debouncedSearch('a')\n * debouncedSearch('ab')\n * debouncedSearch('abc') // 300ms后执行\n * ```\n */\nexport function debounce<T extends (...args: any[]) => any>(\n  fn: T,\n  delay: number,\n): (...args: Parameters<T>) => void {\n  let timeoutId: ReturnType<typeof setTimeout> | null = null\n\n  return function (this: unknown, ...args: Parameters<T>) {\n    if (timeoutId !== null) {\n      clearTimeout(timeoutId)\n    }\n\n    timeoutId = setTimeout(() => {\n      fn.apply(this, args)\n      timeoutId = null\n    }, delay)\n  }\n}\n\n/**\n * 节流函数\n * \n * 规定时间内只触发一次函数，适用于高频事件\n * \n * @param fn - 要节流的函数\n * @param limit - 时间间隔（毫秒）\n * @returns 节流后的函数\n * \n * @example\n * ```typescript\n * const throttledScroll = throttle(() => {\n *   \n * }, 100)\n * \n * window.addEventListener('scroll', throttledScroll)\n * ```\n */\nexport function throttle<T extends (...args: any[]) => any>(\n  fn: T,\n  limit: number,\n): (...args: Parameters<T>) => void {\n  let inThrottle = false\n  let lastResult: ReturnType<T>\n\n  return function (this: unknown, ...args: Parameters<T>) {\n    if (!inThrottle) {\n      inThrottle = true\n      lastResult = fn.apply(this, args)\n\n      setTimeout(() => {\n        inThrottle = false\n      }, limit)\n    }\n\n    return lastResult\n  }\n}\n\n/**\n * 请求合并器配置\n */\nexport interface BatchRequestConfig<TInput = unknown, TOutput = unknown> {\n  /** 最大批量大小 */\n  maxBatchSize?: number\n  /** 等待时间（毫秒） */\n  delay?: number\n  /** 批量请求执行器 */\n  batchFn: (items: TInput[]) => Promise<TOutput[]>\n}\n\n/**\n * 创建请求合并器\n * \n * 将多个单独的请求合并为一个批量请求，减少网络往返\n * \n * @param config - 批量请求配置\n * @returns 合并后的请求函数\n * \n * @example\n * ```typescript\n * const getUsersBatch = createBatchRequest({\n *   maxBatchSize: 100,\n *   delay: 10,\n *   batchFn: async (userIds) => {\n *     return fetch('/api/users/batch', {\n *       method: 'POST',\n *       body: JSON.stringify({ ids: userIds })\n *     }).then(r => r.json())\n *   }\n * })\n * \n * // 这些调用会被合并成一个批量请求\n * const user1 = await getUsersBatch(1)\n * const user2 = await getUsersBatch(2)\n * const user3 = await getUsersBatch(3)\n * ```\n */\nexport function createBatchRequest<TInput, TOutput>(\n  config: BatchRequestConfig<TInput, TOutput>,\n): (input: TInput) => Promise<TOutput> {\n  const {\n    maxBatchSize = 100,\n    delay = 10,\n    batchFn,\n  } = config\n\n  const queue: Array<{\n    input: TInput\n    resolve: (value: TOutput) => void\n    reject: (error: any) => void\n  }> = []\n  let timeoutId: ReturnType<typeof setTimeout> | null = null\n\n  async function processBatch() {\n    if (queue.length === 0) return\n\n    const batch = queue.splice(0, maxBatchSize)\n    const inputs = batch.map(item => item.input)\n\n    try {\n      const results = await batchFn(inputs)\n\n      batch.forEach((item, index) => {\n        item.resolve(results[index])\n      })\n    }\n    catch (error) {\n      batch.forEach((item) => {\n        item.reject(error)\n      })\n    }\n\n    // 如果还有剩余项，继续处理\n    if (queue.length > 0) {\n      timeoutId = setTimeout(processBatch, 0)\n    }\n    else {\n      timeoutId = null\n    }\n  }\n\n  function scheduleBatch() {\n    if (timeoutId !== null) return\n\n    timeoutId = setTimeout(processBatch, delay)\n  }\n\n  return function (input: TInput): Promise<TOutput> {\n    return new Promise((resolve, reject) => {\n      queue.push({ input, resolve, reject })\n\n      if (queue.length >= maxBatchSize) {\n        if (timeoutId !== null) {\n          clearTimeout(timeoutId)\n          timeoutId = null\n        }\n        processBatch()\n      }\n      else {\n        scheduleBatch()\n      }\n    })\n  }\n}\n\n/**\n * 创建一次性函数\n * \n * 确保函数只被执行一次，后续调用返回第一次的结果\n * \n * @param fn - 要执行的函数\n * @returns 只执行一次的函数\n * \n * @example\n * ```typescript\n * const initialize = once(() => {\n *   \n *   return { initialized: true }\n * })\n * \n * initialize() // 输出: \"Initializing...\"\n * initialize() // 不输出，返回缓存的结果\n * ```\n */\nexport function once<T extends (...args: any[]) => any>(\n  fn: T,\n): (...args: Parameters<T>) => ReturnType<T> {\n  let called = false\n  let result: ReturnType<T>\n\n  return function (this: unknown, ...args: Parameters<T>): ReturnType<T> {\n    if (!called) {\n      called = true\n      result = fn.apply(this, args)\n    }\n    return result\n  }\n}\n\n/**\n * 内存化函数\n * \n * 缓存函数的执行结果，相同输入返回缓存值\n * \n * @param fn - 要内存化的函数\n * @param keyFn - 生成缓存键的函数，默认使用JSON.stringify\n * @returns 内存化后的函数\n * \n * @example\n * ```typescript\n * const expensiveCalculation = memoize((a: number, b: number) => {\n *   \n *   return a * b\n * })\n * \n * expensiveCalculation(2, 3) // 输出: \"Calculating...\" 返回: 6\n * expensiveCalculation(2, 3) // 不输出，直接返回: 6\n * ```\n */\nexport function memoize<T extends (...args: any[]) => any>(\n  fn: T,\n  keyFn?: (...args: Parameters<T>) => string,\n): T & { cache: Map<string, ReturnType<T>>, clear: () => void } {\n  const cache = new Map<string, ReturnType<T>>()\n\n  const memoized = function (this: unknown, ...args: Parameters<T>): ReturnType<T> {\n    const key = keyFn ? keyFn(...args) : JSON.stringify(args)\n\n    if (cache.has(key)) {\n      return cache.get(key)!\n    }\n\n    const result = fn.apply(this, args)\n    cache.set(key, result)\n    return result\n  } as T & { cache: Map<string, ReturnType<T>>, clear: () => void }\n\n  memoized.cache = cache\n  memoized.clear = () => cache.clear()\n\n  return memoized\n}\n\n/**\n * 重试函数\n * \n * 在失败时自动重试函数执行\n * \n * @param fn - 要执行的函数\n * @param options - 重试选项\n * @param options.maxAttempts - 最大尝试次数，默认3\n * @param options.delay - 重试延迟基数（毫秒），默认1000\n * @param options.onRetry - 重试回调函数\n * @returns Promise\n * \n * @example\n * ```typescript\n * const result = await retry(\n *   () => fetch('/api/data'),\n *   { maxAttempts: 3, delay: 1000 }\n * )\n * ```\n */\nexport async function retry<T>(\n  fn: () => Promise<T>,\n  options: {\n    maxAttempts?: number\n    delay?: number\n    onRetry?: (attempt: number, error: Error) => void\n  } = {},\n): Promise<T> {\n  const { maxAttempts = 3, delay = 1000, onRetry } = options\n  let lastError: Error | undefined\n\n  for (let attempt = 1; attempt <= maxAttempts; attempt++) {\n    try {\n      return await fn()\n    }\n    catch (error) {\n      lastError = error instanceof Error ? error : new Error(String(error))\n\n      if (attempt < maxAttempts) {\n        onRetry?.(attempt, lastError)\n        await new Promise(resolve => setTimeout(resolve, delay * attempt))\n      }\n    }\n  }\n\n  throw lastError || new Error('Unknown error')\n}\n\n/**\n * 链式调用构建器\n * \n * 创建支持链式调用的配置构建器\n * \n * @example\n * ```typescript\n * interface Config {\n *   url: string\n *   method: string\n *   headers: Record<string, string>\n * }\n * \n * const builder = createChainBuilder<Config>({\n *   url: '',\n *   method: 'GET',\n *   headers: {}\n * })\n * \n * const config = builder\n *   .set('url', '/api/users')\n *   .set('method', 'POST')\n *   .merge('headers', { 'Content-Type': 'application/json' })\n *   .build()\n * ```\n */\nexport function createChainBuilder<T extends Record<string, unknown>>(\n  initial: T,\n) {\n  let config = { ...initial }\n\n  return {\n    set<K extends keyof T>(key: K, value: T[K]) {\n      config[key] = value\n      return this\n    },\n    merge<K extends keyof T>(key: K, value: Partial<T[K]>) {\n      if (typeof config[key] === 'object' && typeof value === 'object') {\n        config[key] = { ...config[key], ...value }\n      }\n      return this\n    },\n    reset() {\n      config = { ...initial }\n      return this\n    },\n    build(): T {\n      return { ...config }\n    },\n    get current(): Readonly<T> {\n      return config\n    },\n  }\n}\n\n/**\n * 对象键值对安全访问\n * \n * 安全获取嵌套对象的值，避免 undefined 错误\n * \n * @param obj - 目标对象\n * @param path - 属性路径\n * @param defaultValue - 默认值\n * @returns 属性值或默认值\n * \n * @example\n * ```typescript\n * const obj = { user: { profile: { name: 'John' } } }\n * \n * get(obj, 'user.profile.name') // 'John'\n * get(obj, 'user.profile.age', 18) // 18\n * get(obj, 'user.settings.theme') // undefined\n * ```\n */\nexport function get<T = unknown>(\n  obj: unknown,\n  path: string,\n  defaultValue?: T,\n): T | undefined {\n  const keys = path.split('.')\n  let result: any = obj\n\n  for (const key of keys) {\n    if (result === null || result === undefined) {\n      return defaultValue\n    }\n    result = result[key]\n  }\n\n  return result !== undefined ? result : defaultValue\n}\n\n/**\n * 安全地设置嵌套对象的值\n * \n * @param obj - 目标对象\n * @param path - 属性路径\n * @param value - 要设置的值\n * \n * @example\n * ```typescript\n * const obj = {}\n * set(obj, 'user.profile.name', 'John')\n * // obj 变为: { user: { profile: { name: 'John' } } }\n * ```\n */\nexport function set(obj: Record<string, any>, path: string, value: unknown): void {\n  const keys = path.split('.')\n  const lastKey = keys.pop()!\n  let current = obj\n\n  for (const key of keys) {\n    if (!(key in current) || typeof current[key] !== 'object') {\n      current[key] = {}\n    }\n    current = current[key]\n  }\n\n  current[lastKey] = value\n}\n\n/**\n * 深度冻结对象\n * \n * 递归冻结对象及其所有嵌套对象\n * \n * @param obj - 要冻结的对象\n * @returns 冻结后的对象\n */\nexport function deepFreeze<T>(obj: T): Readonly<T> {\n  Object.freeze(obj)\n\n  Object.values(obj as any).forEach((value) => {\n    if (typeof value === 'object' && value !== null && !Object.isFrozen(value)) {\n      deepFreeze(value)\n    }\n  })\n\n  return obj\n}\n\n/**\n * 延迟执行\n * \n * @param ms - 延迟时间（毫秒）\n * @returns Promise\n */\nexport function sleep(ms: number): Promise<void> {\n  return new Promise(resolve => setTimeout(resolve, ms))\n}\n\n/**\n * 超时Promise包装器\n * \n * 为Promise添加超时限制\n * \n * @param promise - 原始Promise\n * @param ms - 超时时间（毫秒）\n * @param timeoutError - 超时错误\n * @returns 带超时的Promise\n * \n * @example\n * ```typescript\n * const result = await timeout(\n *   fetch('/api/data'),\n *   5000,\n *   new Error('Request timeout')\n * )\n * ```\n */\nexport function timeout<T>(\n  promise: Promise<T>,\n  ms: number,\n  timeoutError: Error = new Error('Timeout'),\n): Promise<T> {\n  let timeoutId: ReturnType<typeof setTimeout>\n\n  const timeoutPromise = new Promise<never>((_, reject) => {\n    timeoutId = setTimeout(() => reject(timeoutError), ms)\n  })\n\n  return Promise.race([promise, timeoutPromise]).finally(() => {\n    clearTimeout(timeoutId)\n  })\n}\n\n/**\n * 批量并行执行Promise（带并发控制）\n * \n * @param tasks - 任务数组\n * @param limit - 并发限制\n * @returns Promise数组结果\n * \n * @example\n * ```typescript\n * const tasks = urls.map(url => () => fetch(url))\n * const results = await parallelLimit(tasks, 3) // 最多3个并发\n * ```\n */\nexport async function parallelLimit<T>(\n  tasks: Array<() => Promise<T>>,\n  limit: number,\n): Promise<T[]> {\n  const results: T[] = []\n  const executing: Promise<void>[] = []\n\n  for (let i = 0; i < tasks.length; i++) {\n    const task = tasks[i]!\n    const promise = task().then(result => {\n      results[i] = result\n    })\n\n    executing.push(promise)\n\n    if (executing.length >= limit) {\n      await Promise.race(executing)\n      executing.splice(\n        executing.findIndex(p => p === promise),\n        1,\n      )\n    }\n  }\n\n  await Promise.all(executing)\n  return results\n}\n"],"names":["config","maxBatchSize","delay","batchFn","queue","timeoutId","async","processBatch","length","batch","splice","inputs","map","item","input","results","forEach","index","resolve","error","reject","setTimeout","Promise","push","clearTimeout","initial","set","key","value","this","merge","reset","build","current","fn","args","apply","deepFreeze","obj","Object","freeze","values","isFrozen","path","defaultValue","keys","split","result","keyFn","cache","Map","memoized","JSON","stringify","has","get","clear","called","tasks","limit","executing","i","promise","task","then","race","findIndex","p","all","options","maxAttempts","onRetry","lastError","attempt","Error","String","lastKey","pop","ms","lastResult","inThrottle","timeoutError","timeoutPromise","_","finally"],"mappings":"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"}