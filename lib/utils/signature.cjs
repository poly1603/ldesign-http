"use strict";Object.create,Object.defineProperty,Object.getOwnPropertyDescriptor,Object.getOwnPropertyNames,Object.getPrototypeOf,Object.prototype.hasOwnProperty;class e{constructor(e){this.usedNonces=new Set,this.config={secret:e.secret,algorithm:e.algorithm??"sha256",headerName:e.headerName??"X-Signature",timestampHeaderName:e.timestampHeaderName??"X-Timestamp",nonceHeaderName:e.nonceHeaderName??"X-Nonce",expiresIn:e.expiresIn??300,includeBody:e.includeBody??!0,includeParams:e.includeParams??!0,customGenerator:e.customGenerator},this.startNonceCleanup()}async sign(e){const t=Date.now(),r=this.generateNonce(),n=this.buildSignData(e,t,r),a=await this.generateSignature(n),s={...e.headers,[this.config?.headerName]:a,[this.config?.timestampHeaderName]:t.toString(),[this.config?.nonceHeaderName]:r};return{...e,headers:s}}async verify(e){const t=e.headers?.[this.config?.headerName],r=e.headers?.[this.config?.timestampHeaderName],n=e.headers?.[this.config?.nonceHeaderName];if(!t||!r||!n)return!1;const a=Date.now(),s=Number.parseInt(r,10);if(a-s>1e3*this.config?.expiresIn||this.usedNonces.has(n))return!1;const i=this.buildSignData(e,s,n),o=t===await this.generateSignature(i);return o&&this.usedNonces.add(n),o}buildSignData(e,t,r){const n=[e.method||"GET",e.url||"",t.toString(),r];if(this.config?.includeParams&&e.params){const t=this.sortObject(e.params);n.push(JSON.stringify(t))}return this.config?.includeBody&&e.data&&("string"==typeof e.data?n.push(e.data):n.push(JSON.stringify(e.data))),n.join("&")}async generateSignature(e){return this.config?.customGenerator?this.config?.customGenerator(e,this.config?.secret):this.hash(e+this.config?.secret,this.config?.algorithm)}async hash(e,t){if(typeof crypto<"u"&&crypto.subtle){const r=(new TextEncoder).encode(e);let n;switch(t){case"sha256":n="SHA-256";break;case"sha1":n="SHA-1";break;default:throw new Error(`Unsupported algorithm: ${t}`)}const a=await crypto.subtle.digest(n,r);return Array.from(new Uint8Array(a)).map(e=>e.toString(16).padStart(2,"0")).join("")}try{const{createHash:r}=await import("node:crypto");return r(t).update(e).digest("hex")}catch{}return this.simpleHash(e)}simpleHash(e){let t=0;for(let r=0;r<e.length;r++){t=(t<<5)-t+e.charCodeAt(r),t&=t}return Math.abs(t).toString(16)}generateNonce(){return`${Date.now().toString(36)}${Math.random().toString(36).substring(2,15)}`}sortObject(e){const t={};return Object.keys(e).sort().forEach(r=>{t[r]=e[r]}),t}startNonceCleanup(){this.nonceCleanupTimer=setInterval(()=>{this.usedNonces.clear()},6e4)}clearNonces(){this.usedNonces.clear()}destroy(){this.nonceCleanupTimer&&(clearInterval(this.nonceCleanupTimer),this.nonceCleanupTimer=void 0),this.usedNonces.clear()}}exports.SignatureManager=e,exports.createSignatureInterceptor=function(t){const r=new e(t);return async e=>r.sign(e)},exports.createSignatureManager=function(t){return new e(t)};
//# sourceMappingURL=signature.cjs.map
