{"version":3,"file":"cache.cjs","sources":["../../src/utils/cache.ts"],"sourcesContent":["import type {\n  CacheConfig,\n  CacheStorage,\n  RequestConfig,\n  ResponseData,\n} from '../types'\n\n/**\n * 缓存项接口\n *\n * 定义缓存中存储的数据项结构\n */\ninterface CacheItem<T = unknown> {\n  /** 缓存的响应数据 */\n  data: ResponseData<T>\n  /** 缓存创建时间戳 */\n  timestamp: number\n  /** 生存时间（毫秒） */\n  ttl: number\n}\n\n/**\n * 内存缓存存储实现（优化版）\n *\n * 优化点：\n * 1. 使用单个定时器替代多个定时器，减少内存占用\n * 2. 延迟过期检查，只在访问时检查\n * 3. 批量清理过期项\n * 4. 添加 LRU 淘汰策略\n * 5. 使用 WeakRef 减少内存占用\n *\n * @example\n * ```typescript\n * const storage = new MemoryCacheStorage()\n *\n * // 存储数据，5分钟后过期\n * await storage.set('user:123', userData, 5 * 60 * 1000)\n *\n * // 获取数据\n * const cached = await storage.get('user:123')\n *\n * // 删除数据\n * await storage.delete('user:123')\n * ```\n */\nexport class MemoryCacheStorage implements CacheStorage {\n  private cache = new Map<string, CacheItem>()\n  private accessOrder = new Map<string, number>() // LRU 访问顺序\n  private maxSize = 1000 // 最大缓存项数\n  // 优化：使用单个定时器进行批量清理\n  private cleanupTimer?: NodeJS.Timeout\n  private cleanupInterval = 60000 // 每分钟清理一次\n  private isDestroyed = false\n\n  constructor(maxSize: number = 1000) {\n    this.maxSize = maxSize\n    // 启动定期清理\n    this.startCleanup()\n  }\n\n  async get(key: string): Promise<any> {\n    const item = this.cache.get(key)\n\n    if (!item) {\n      return null\n    }\n\n    // 检查是否过期（延迟过期检查）\n    if (Date.now() - item.timestamp > item.ttl) {\n      this.cache.delete(key)\n      this.accessOrder.delete(key)\n      return null\n    }\n\n    // 更新 LRU 访问顺序\n    this.accessOrder.set(key, Date.now())\n\n    return item.data\n  }\n\n  async set(key: string, value: any, ttl = 300000): Promise<void> {\n    // LRU 淘汰：如果超过最大大小，移除最旧的项\n    if (this.cache.size >= this.maxSize) {\n      this.evictLRU()\n    }\n\n    // 存储数据（不再为每个项设置定时器）\n    this.cache.set(key, {\n      data: value,\n      timestamp: Date.now(),\n      ttl,\n    })\n    \n    // 更新访问顺序\n    this.accessOrder.set(key, Date.now())\n  }\n\n  async delete(key: string): Promise<void> {\n    this.cache.delete(key)\n    this.accessOrder.delete(key)\n  }\n\n  async clear(): Promise<void> {\n    this.cache.clear()\n    this.accessOrder.clear()\n  }\n\n  /**\n   * 启动定期清理（优化：单个定时器）\n   */\n  private startCleanup(): void {\n    if (this.isDestroyed) return\n    \n    this.cleanupTimer = setInterval(() => {\n      if (!this.isDestroyed) {\n        this.cleanupExpired()\n      }\n    }, this.cleanupInterval)\n\n    // 确保 Node.js 不会因为这个定时器而保持进程运行\n    if (this.cleanupTimer.unref) {\n      this.cleanupTimer.unref()\n    }\n  }\n\n  /**\n   * 批量清理过期项\n   */\n  private cleanupExpired(): void {\n    if (this.isDestroyed) return\n    \n    const now = Date.now()\n    const keysToDelete: string[] = []\n\n    // 优化：限制每次清理的数量，避免阻塞\n    let cleanupCount = 0\n    const maxCleanupPerCycle = 100\n\n    // 收集过期的键\n    for (const [key, item] of this.cache.entries()) {\n      if (now - item.timestamp > item.ttl) {\n        keysToDelete.push(key)\n        cleanupCount++\n        if (cleanupCount >= maxCleanupPerCycle) {\n          break\n        }\n      }\n    }\n\n    // 批量删除\n    for (const key of keysToDelete) {\n      this.cache.delete(key)\n      this.accessOrder.delete(key)\n    }\n  }\n\n  /**\n   * LRU 淘汰策略\n   */\n  private evictLRU(): void {\n    if (this.accessOrder.size === 0) return\n\n    // 找到最久未访问的键\n    let oldestKey: string | null = null\n    let oldestTime = Infinity\n\n    for (const [key, time] of this.accessOrder.entries()) {\n      if (time < oldestTime) {\n        oldestTime = time\n        oldestKey = key\n      }\n    }\n\n    if (oldestKey) {\n      this.cache.delete(oldestKey)\n      this.accessOrder.delete(oldestKey)\n    }\n  }\n\n  /**\n   * 获取缓存大小\n   */\n  size(): number {\n    return this.cache.size\n  }\n\n  /**\n   * 获取所有缓存键\n   */\n  keys(): string[] {\n    return Array.from(this.cache.keys())\n  }\n\n  /**\n   * 销毁缓存\n   */\n  destroy(): void {\n    this.isDestroyed = true\n    \n    if (this.cleanupTimer) {\n      clearInterval(this.cleanupTimer)\n      this.cleanupTimer = undefined\n    }\n    \n    this.cache.clear()\n    this.accessOrder.clear()\n  }\n}\n\n/**\n * LocalStorage 缓存存储实现\n */\nexport class LocalStorageCacheStorage implements CacheStorage {\n  private prefix: string\n\n  constructor(prefix = 'http_cache_') {\n    this.prefix = prefix\n  }\n\n  async get(key: string): Promise<unknown> {\n    if (typeof localStorage === 'undefined') {\n      return null\n    }\n\n    try {\n      const item = localStorage.getItem(this.prefix + key)\n      if (!item) {\n        return null\n      }\n\n      const parsed = JSON.parse(item) as CacheItem\n\n      // 检查是否过期\n      if (Date.now() - parsed.timestamp > parsed.ttl) {\n        this.delete(key)\n        return null\n      }\n\n      return parsed.data\n    }\n    catch {\n      return null\n    }\n  }\n\n  async set(key: string, value: unknown, ttl = 300000): Promise<void> {\n    if (typeof localStorage === 'undefined') {\n      return\n    }\n\n    try {\n      const item: CacheItem = {\n        data: value as ResponseData<unknown>,\n        timestamp: Date.now(),\n        ttl,\n      }\n\n      localStorage.setItem(this.prefix + key, JSON.stringify(item))\n    }\n    catch {\n      // 存储失败，可能是空间不足\n    }\n  }\n\n  async delete(key: string): Promise<void> {\n    if (typeof localStorage === 'undefined') {\n      return\n    }\n\n    localStorage.removeItem(this.prefix + key)\n  }\n\n  async clear(): Promise<void> {\n    if (typeof localStorage === 'undefined') {\n      return\n    }\n\n    const keys = Object.keys(localStorage)\n    keys.forEach((key) => {\n      if (key.startsWith(this.prefix)) {\n        localStorage.removeItem(key)\n      }\n    })\n  }\n}\n\n/**\n * 缓存管理器\n */\nexport class CacheManager {\n  protected config: Required<CacheConfig>\n  protected storage: CacheStorage\n  private keyCache = new Map<string, string>() // 缓存生成的键，避免重复计算\n  protected stats: CacheStats = {\n    hits: 0,\n    misses: 0,\n    hitRate: 0,\n    size: 0,\n    memoryUsage: 0,\n    recentKeys: [],\n    hotKeys: [],\n  }\n\n  constructor(config: CacheConfig = {}) {\n    this.config = {\n      enabled: config.enabled ?? true,\n      ttl: config.ttl ?? 300000, // 默认 5 分钟\n      keyGenerator: config.keyGenerator ?? this.defaultKeyGenerator,\n      storage: config.storage ?? new MemoryCacheStorage(),\n    }\n\n    this.storage = this.config?.storage\n  }\n\n  /**\n   * 获取缓存\n   */\n  async get<T = unknown>(config: RequestConfig): Promise<ResponseData<T> | null> {\n    if (!this.config?.enabled) {\n      return null\n    }\n\n    const key = this.getCachedKey(config)\n    const result = await this.storage.get(key)\n\n    // 更新统计信息\n    if (result) {\n      this.stats.hits++\n    }\n    else {\n      this.stats.misses++\n    }\n\n    // 更新命中率\n    const total = this.stats.hits + this.stats.misses\n    this.stats.hitRate = total > 0 ? this.stats.hits / total : 0\n\n    return result as ResponseData<T> | null\n  }\n\n  /**\n   * 设置缓存\n   */\n  async set<T = unknown>(\n    config: RequestConfig,\n    response: ResponseData<T>,\n  ): Promise<void> {\n    if (!this.config?.enabled) {\n      return\n    }\n\n    // 只缓存成功的 GET 请求\n    if (\n      config.method !== 'GET'\n      || response.status < 200\n      || response.status >= 300\n    ) {\n      return\n    }\n\n    const key = this.getCachedKey(config)\n    await this.storage.set(key, response, this.config?.ttl)\n  }\n\n  /**\n   * 删除缓存\n   */\n  async delete(config: RequestConfig): Promise<void> {\n    const key = this.getCachedKey(config)\n    await this.storage.delete(key)\n  }\n\n  /**\n   * 清空所有缓存\n   */\n  async clear(): Promise<void> {\n    await this.storage.clear()\n  }\n\n  /**\n   * 更新配置\n   */\n  updateConfig(config: Partial<CacheConfig>): void {\n    Object.assign(this.config, config)\n    if (config.storage) {\n      this.storage = config.storage\n    }\n  }\n\n  /**\n   * 获取当前配置\n   */\n  getConfig(): Required<CacheConfig> {\n    return { ...this.config }\n  }\n\n  /**\n   * 获取缓存统计\n   */\n  getStats(): CacheStats {\n    return { ...this.stats }\n  }\n\n  /**\n   * 获取缓存的键（性能优化版本）\n   */\n  protected getCachedKey(config: RequestConfig): string {\n    // 优化：使用更快的配置标识符生成方式，避免 JSON.stringify\n    const method = config.method || 'GET'\n    const url = config.url || ''\n    const paramsStr = config.params ? this.fastStringify(config.params) : ''\n    const dataStr = config.data ? this.fastStringify(config.data) : ''\n    const configId = `${method}:${url}:${paramsStr}:${dataStr}`\n\n    if (this.keyCache.has(configId)) {\n      return this.keyCache.get(configId)!\n    }\n\n    const key = this.config?.keyGenerator(config)\n\n    // 限制缓存大小，避免内存泄漏\n    if (this.keyCache.size > 1000) {\n      const firstKey = this.keyCache.keys().next().value\n      if (firstKey !== undefined) {\n        this.keyCache.delete(firstKey)\n      }\n    }\n\n    this.keyCache.set(configId, key)\n    return key\n  }\n\n  /**\n   * 快速字符串化对象（优化版：小对象直接用JSON.stringify）\n   */\n  private fastStringify(obj: any): string {\n    if (obj === null || obj === undefined) {\n      return ''\n    }\n    if (typeof obj === 'string') {\n      return obj\n    }\n    if (typeof obj === 'number' || typeof obj === 'boolean') {\n      return String(obj)\n    }\n    // 对于对象和数组，直接使用 JSON.stringify（更快且准确）\n    return JSON.stringify(obj)\n  }\n\n  /**\n   * 默认缓存键生成器\n   */\n  private defaultKeyGenerator(config: RequestConfig): string {\n    const { method = 'GET', url = '', params = {}, data } = config\n\n    // 构建基础键\n    let key = `${method}:${url}`\n\n    // 添加查询参数\n    const paramKeys = Object.keys(params).sort()\n    if (paramKeys.length > 0) {\n      const paramString = paramKeys.map(k => `${k}=${params[k]}`).join('&')\n      key += `?${paramString}`\n    }\n\n    // 对于 POST 等请求，添加数据哈希\n    if (data && method !== 'GET') {\n      const dataString = typeof data === 'string' ? data : JSON.stringify(data)\n      key += `:${simpleHash(dataString)}`\n    }\n\n    return key\n  }\n}\n\n/**\n * 增强缓存配置\n */\nexport interface EnhancedCacheConfig extends CacheConfig {\n  /** 缓存策略 */\n  strategy?: 'lru' | 'lfu' | 'fifo' | 'ttl'\n  /** 最大缓存大小（字节） */\n  maxSize?: number\n  /** 是否启用压缩 */\n  compression?: boolean\n  /** 缓存预热配置 */\n  preload?: {\n    enabled: boolean\n    urls: string[]\n  }\n  /** 缓存失效策略 */\n  invalidation?: {\n    /** 基于标签的失效 */\n    tags?: boolean\n    /** 基于依赖的失效 */\n    dependencies?: boolean\n  }\n  /** 缓存统计 */\n  stats?: boolean\n}\n\n/**\n * 缓存统计信息\n */\nexport interface CacheStats {\n  /** 命中次数 */\n  hits: number\n  /** 未命中次数 */\n  misses: number\n  /** 命中率 */\n  hitRate: number\n  /** 缓存大小 */\n  size: number\n  /** 总内存使用量（字节） */\n  memoryUsage: number\n  /** 最近访问的键 */\n  recentKeys: string[]\n  /** 最热门的键 */\n  hotKeys: Array<{ key: string, accessCount: number }>\n}\n\n/**\n * 缓存项元数据\n */\nexport interface CacheItemMetadata {\n  /** 创建时间 */\n  createdAt: number\n  /** 最后访问时间 */\n  lastAccessed: number\n  /** 访问次数 */\n  accessCount: number\n  /** 数据大小（字节） */\n  size: number\n  /** 标签 */\n  tags?: string[]\n  /** 依赖 */\n  dependencies?: string[]\n  /** 是否压缩 */\n  compressed?: boolean\n}\n\n/**\n * 增强的缓存项\n */\nexport interface EnhancedCacheItem extends CacheItem {\n  /** 元数据 */\n  metadata: CacheItemMetadata\n}\n\n/**\n * 增强的缓存管理器\n */\nexport class EnhancedCacheManager extends CacheManager {\n  private enhancedConfig: EnhancedCacheConfig\n  private accessLog = new Map<string, number>() // 访问计数\n  private tagIndex = new Map<string, Set<string>>() // 标签索引\n  private dependencyGraph = new Map<string, Set<string>>() // 依赖图\n\n  constructor(config: EnhancedCacheConfig = {}) {\n    super(config)\n    this.enhancedConfig = {\n      strategy: 'lru',\n      maxSize: 50 * 1024 * 1024, // 50MB\n      compression: false,\n      stats: true,\n      ...config,\n    }\n  }\n\n  /**\n   * 增强的获取方法\n   */\n  async get<T = any>(config: RequestConfig): Promise<ResponseData<T> | null> {\n    if (!this.enhancedConfig.stats) {\n      // 如果统计被禁用，直接从存储获取，不进行任何统计\n      if (!this.config?.enabled) {\n        return null\n      }\n      const key = this.getCachedKey(config)\n      const res = await this.storage.get(key)\n      return res as ResponseData<T> | null\n    }\n\n    // 如果统计启用，调用父类方法（会进行基础统计）\n    const result = await super.get<T>(config)\n\n    // 只做增强功能，不重复统计（父类已经统计了）\n    if (result) {\n      const key = this.getCachedKey(config)\n      this.updateAccessLog(key)\n      this.updateRecentKeys(key)\n    }\n\n    return result\n  }\n\n  /**\n   * 增强的设置方法\n   */\n  async set<T = any>(\n    config: RequestConfig,\n    response: ResponseData<T>,\n    options?: {\n      tags?: string[]\n      dependencies?: string[]\n      compress?: boolean\n    },\n  ): Promise<void> {\n    await super.set(config, response)\n\n    if (this.enhancedConfig.stats) {\n      const key = this.getCachedKey(config)\n\n      // 更新标签索引\n      if (options?.tags) {\n        this.updateTagIndex(key, options.tags)\n      }\n\n      // 更新依赖图\n      if (options?.dependencies) {\n        this.updateDependencyGraph(key, options.dependencies)\n      }\n\n      this.updateStats()\n    }\n  }\n\n  /**\n   * 基于标签失效缓存（批量优化）\n   */\n  async invalidateByTag(tag: string): Promise<number> {\n    const keys = this.tagIndex.get(tag)\n    if (!keys) {\n      return 0\n    }\n\n    const invalidatedCount = keys.size\n\n    // 批量删除优化：如果存储支持批量删除，使用批量操作\n    if (this.storage.deleteBatch) {\n      await this.storage.deleteBatch(Array.from(keys))\n    }\n    else {\n      // 并行删除以提高性能\n      await Promise.all(Array.from(keys).map(key => this.storage.delete(key)))\n    }\n\n    this.tagIndex.delete(tag)\n    this.updateStats()\n\n    return invalidatedCount\n  }\n\n  /**\n   * 基于依赖失效缓存\n   */\n  async invalidateByDependency(dependency: string): Promise<number> {\n    const dependentKeys = this.dependencyGraph.get(dependency)\n    if (!dependentKeys) {\n      return 0\n    }\n\n    let invalidatedCount = 0\n    for (const key of dependentKeys) {\n      await this.storage.delete(key)\n      invalidatedCount++\n    }\n\n    this.dependencyGraph.delete(dependency)\n    this.updateStats()\n\n    return invalidatedCount\n  }\n\n  /**\n   * 缓存预热\n   */\n  async preload(urls: string[]): Promise<void> {\n    if (!this.enhancedConfig.preload?.enabled) {\n      return\n    }\n\n    const preloadPromises = urls.map(async (url) => {\n      try {\n        // 这里应该调用实际的HTTP请求\n        // 为了示例，我们只是模拟\n        const config: RequestConfig = { url, method: 'GET' }\n        const mockResponse: ResponseData = {\n          data: `preloaded-${url}`,\n          status: 200,\n          statusText: 'OK',\n          headers: {},\n          config,\n        }\n\n        await this.set(config, mockResponse)\n      }\n      catch (error) {\n        console.warn(`Failed to preload ${url}:`, error)\n      }\n    })\n\n    await Promise.all(preloadPromises)\n  }\n\n  /**\n   * 获取缓存统计\n   */\n  getStats(): CacheStats {\n    return { ...this.stats }\n  }\n\n  /**\n   * 重置统计\n   */\n  resetStats(): void {\n    this.stats = {\n      hits: 0,\n      misses: 0,\n      hitRate: 0,\n      size: 0,\n      memoryUsage: 0,\n      recentKeys: [],\n      hotKeys: [],\n    }\n    this.accessLog.clear()\n  }\n\n  /**\n   * 获取热门键\n   */\n  getHotKeys(limit: number = 10): Array<{ key: string, accessCount: number }> {\n    return Array.from(this.accessLog.entries())\n      .map(([key, count]) => ({ key, accessCount: count }))\n      .sort((a, b) => b.accessCount - a.accessCount)\n      .slice(0, limit)\n  }\n\n  /**\n   * 清理过期缓存\n   */\n  async cleanup(): Promise<number> {\n    // 这里应该实现清理逻辑\n    // 由于基类已经有清理机制，我们只需要更新统计\n    this.updateStats()\n    return 0\n  }\n\n  /**\n   * 更新访问日志\n   */\n  private updateAccessLog(key: string): void {\n    const currentCount = this.accessLog.get(key) || 0\n    this.accessLog.set(key, currentCount + 1)\n  }\n\n  /**\n   * 更新最近访问的键\n   */\n  private updateRecentKeys(key: string): void {\n    // 移除已存在的键\n    const index = this.stats.recentKeys.indexOf(key)\n    if (index > -1) {\n      this.stats.recentKeys.splice(index, 1)\n    }\n\n    // 添加到开头\n    this.stats.recentKeys.unshift(key)\n\n    // 保持最多10个\n    if (this.stats.recentKeys.length > 10) {\n      this.stats.recentKeys = this.stats.recentKeys.slice(0, 10)\n    }\n  }\n\n  /**\n   * 更新标签索引\n   */\n  private updateTagIndex(key: string, tags: string[]): void {\n    for (const tag of tags) {\n      if (!this.tagIndex.has(tag)) {\n        this.tagIndex.set(tag, new Set())\n      }\n      this.tagIndex.get(tag)!.add(key)\n    }\n  }\n\n  /**\n   * 更新依赖图\n   */\n  private updateDependencyGraph(key: string, dependencies: string[]): void {\n    for (const dependency of dependencies) {\n      if (!this.dependencyGraph.has(dependency)) {\n        this.dependencyGraph.set(dependency, new Set())\n      }\n      this.dependencyGraph.get(dependency)!.add(key)\n    }\n  }\n\n  /**\n   * 更新统计信息\n   */\n  private updateStats(): void {\n    // 更新热门键\n    this.stats.hotKeys = this.getHotKeys()\n\n    // 这里可以添加更多统计更新逻辑\n  }\n}\n\n/**\n * 创建缓存管理器\n */\nexport function createCacheManager(config?: CacheConfig): CacheManager {\n  return new CacheManager(config)\n}\n\n/**\n * 创建增强缓存管理器\n */\nexport function createEnhancedCacheManager(\n  config?: EnhancedCacheConfig,\n): EnhancedCacheManager {\n  return new EnhancedCacheManager(config)\n}\n\n/**\n * 创建内存缓存存储\n */\nexport function createMemoryStorage(): MemoryCacheStorage {\n  return new MemoryCacheStorage()\n}\n\n/**\n * 创建 LocalStorage 缓存存储\n */\nexport function createLocalStorage(prefix?: string): LocalStorageCacheStorage {\n  return new LocalStorageCacheStorage(prefix)\n}\n\n/**\n * 简单哈希函数\n */\nfunction simpleHash(str: string): string {\n  let hash = 0\n  for (let i = 0; i < str.length; i++) {\n    const char = str.charCodeAt(i)\n    hash = (hash << 5) - hash + char\n    hash = hash & hash // 转换为 32 位整数\n  }\n  return Math.abs(hash).toString(36)\n}\n"],"names":["MemoryCacheStorage","constructor","maxSize","this","cache","Map","accessOrder","cleanupInterval","isDestroyed","startCleanup","get","key","item","Date","now","timestamp","ttl","delete","set","data","value","size","evictLRU","clear","cleanupTimer","setInterval","cleanupExpired","unref","keysToDelete","cleanupCount","entries","push","oldestKey","oldestTime","time","keys","Array","from","destroy","clearInterval","LocalStorageCacheStorage","prefix","localStorage","getItem","parsed","JSON","parse","setItem","stringify","removeItem","Object","forEach","startsWith","CacheManager","config","keyCache","stats","hits","misses","hitRate","memoryUsage","recentKeys","hotKeys","enabled","keyGenerator","defaultKeyGenerator","storage","getCachedKey","result","total","response","method","status","updateConfig","assign","getConfig","getStats","configId","url","params","fastStringify","has","firstKey","next","obj","String","paramKeys","sort","length","map","k","join","str","hash","i","charCodeAt","Math","abs","toString","simpleHash","EnhancedCacheManager","super","accessLog","tagIndex","dependencyGraph","enhancedConfig","strategy","compression","updateAccessLog","updateRecentKeys","options","tags","updateTagIndex","dependencies","updateDependencyGraph","updateStats","invalidateByTag","tag","invalidatedCount","deleteBatch","Promise","all","invalidateByDependency","dependency","dependentKeys","preload","urls","preloadPromises","async","mockResponse","statusText","headers","error","resetStats","getHotKeys","limit","count","accessCount","a","b","slice","cleanup","currentCount","index","indexOf","splice","unshift","Set","add"],"mappings":"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"}