{"version":3,"file":"cache-storage.cjs","sources":["../../src/utils/cache-storage.ts"],"sourcesContent":["/**\r\n * 缓存存储实现模块\r\n * \r\n * 提供多种缓存存储后端的实现\r\n */\r\n\r\nimport type { CacheStorage, ResponseData } from '../types'\r\n\r\n/**\r\n * 缓存项接口\r\n */\r\nexport interface CacheItem<T = any> {\r\n  /** 缓存的响应数据 */\r\n  data: ResponseData<T>\r\n  /** 缓存创建时间戳 */\r\n  timestamp: number\r\n  /** 生存时间（毫秒） */\r\n  ttl: number\r\n  /** 元数据 */\r\n  metadata?: CacheItemMetadata\r\n}\r\n\r\n/**\r\n * 缓存项元数据\r\n */\r\nexport interface CacheItemMetadata {\r\n  /** 创建时间 */\r\n  createdAt: number\r\n  /** 最后访问时间 */\r\n  lastAccessed: number\r\n  /** 访问次数 */\r\n  accessCount: number\r\n  /** 数据大小（字节） */\r\n  size: number\r\n  /** 标签 */\r\n  tags?: string[]\r\n  /** 依赖 */\r\n  dependencies?: string[]\r\n}\r\n\r\n/**\r\n * 内存缓存存储实现（优化版）\r\n */\r\nexport class MemoryCacheStorage implements CacheStorage {\r\n  private cache = new Map<string, CacheItem>()\r\n  private cleanupTimer?: NodeJS.Timeout\r\n  private cleanupInterval = 60000 // 每分钟清理一次\r\n\r\n  constructor() {\r\n    this.startCleanup()\r\n  }\r\n\r\n  async get(key: string): Promise<any> {\r\n    const item = this.cache.get(key)\r\n\r\n    if (!item) {\r\n      return null\r\n    }\r\n\r\n    // 检查是否过期（延迟过期检查）\r\n    if (Date.now() - item.timestamp > item.ttl) {\r\n      this.cache.delete(key)\r\n      return null\r\n    }\r\n\r\n    // 更新访问时间和计数\r\n    if (item.metadata) {\r\n      item.metadata.lastAccessed = Date.now()\r\n      item.metadata.accessCount++\r\n    }\r\n\r\n    return item.data\r\n  }\r\n\r\n  async set(key: string, value: any, ttl = 300000): Promise<void> {\r\n    const now = Date.now()\r\n    this.cache.set(key, {\r\n      data: value,\r\n      timestamp: now,\r\n      ttl,\r\n      metadata: {\r\n        createdAt: now,\r\n        lastAccessed: now,\r\n        accessCount: 0,\r\n        size: this.calculateSize(value),\r\n      },\r\n    })\r\n  }\r\n\r\n  async delete(key: string): Promise<void> {\r\n    this.cache.delete(key)\r\n  }\r\n\r\n  async clear(): Promise<void> {\r\n    this.cache.clear()\r\n  }\r\n\r\n  async has(key: string): Promise<boolean> {\r\n    const item = this.cache.get(key)\r\n    if (!item) return false\r\n    \r\n    // 检查是否过期\r\n    if (Date.now() - item.timestamp > item.ttl) {\r\n      this.cache.delete(key)\r\n      return false\r\n    }\r\n    \r\n    return true\r\n  }\r\n\r\n  /**\r\n   * 批量删除\r\n   */\r\n  async deleteBatch(keys: string[]): Promise<void> {\r\n    for (const key of keys) {\r\n      this.cache.delete(key)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 获取缓存大小\r\n   */\r\n  size(): number {\r\n    return this.cache.size\r\n  }\r\n\r\n  /**\r\n   * 获取所有缓存键\r\n   */\r\n  keys(): string[] {\r\n    return Array.from(this.cache.keys())\r\n  }\r\n\r\n  /**\r\n   * 获取缓存元数据\r\n   */\r\n  getMetadata(key: string): CacheItemMetadata | null {\r\n    const item = this.cache.get(key)\r\n    return item?.metadata || null\r\n  }\r\n\r\n  /**\r\n   * 启动定期清理\r\n   */\r\n  private startCleanup(): void {\r\n    this.cleanupTimer = setInterval(() => {\r\n      this.cleanupExpired()\r\n    }, this.cleanupInterval)\r\n  }\r\n\r\n  /**\r\n   * 批量清理过期项\r\n   */\r\n  private cleanupExpired(): void {\r\n    const now = Date.now()\r\n    const keysToDelete: string[] = []\r\n\r\n    for (const [key, item] of this.cache.entries()) {\r\n      if (now - item.timestamp > item.ttl) {\r\n        keysToDelete.push(key)\r\n      }\r\n    }\r\n\r\n    for (const key of keysToDelete) {\r\n      this.cache.delete(key)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 计算数据大小（粗略估计）\r\n   */\r\n  private calculateSize(data: any): number {\r\n    try {\r\n      return JSON.stringify(data).length * 2 // 估算UTF-16字符占用\r\n    } catch {\r\n      return 0\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 销毁缓存\r\n   */\r\n  destroy(): void {\r\n    if (this.cleanupTimer) {\r\n      clearInterval(this.cleanupTimer)\r\n      this.cleanupTimer = undefined\r\n    }\r\n    this.cache.clear()\r\n  }\r\n}\r\n\r\n/**\r\n * LocalStorage 缓存存储实现\r\n */\r\nexport class LocalStorageCacheStorage implements CacheStorage {\r\n  protected prefix: string\r\n\r\n  constructor(prefix = 'http_cache_') {\r\n    this.prefix = prefix\r\n  }\r\n\r\n  async get(key: string): Promise<any> {\r\n    if (typeof localStorage === 'undefined') {\r\n      return null\r\n    }\r\n\r\n    try {\r\n      const item = localStorage.getItem(this.prefix + key)\r\n      if (!item) {\r\n        return null\r\n      }\r\n\r\n      const parsed = JSON.parse(item) as CacheItem\r\n\r\n      // 检查是否过期\r\n      if (Date.now() - parsed.timestamp > parsed.ttl) {\r\n        await this.delete(key)\r\n        return null\r\n      }\r\n\r\n      return parsed.data\r\n    }\r\n    catch {\r\n      return null\r\n    }\r\n  }\r\n\r\n  async set(key: string, value: any, ttl = 300000): Promise<void> {\r\n    if (typeof localStorage === 'undefined') {\r\n      return\r\n    }\r\n\r\n    try {\r\n      const item: CacheItem = {\r\n        data: value,\r\n        timestamp: Date.now(),\r\n        ttl,\r\n      }\r\n\r\n      localStorage.setItem(this.prefix + key, JSON.stringify(item))\r\n    }\r\n    catch {\r\n      // 存储失败，可能是空间不足\r\n      this.handleStorageQuotaExceeded()\r\n    }\r\n  }\r\n\r\n  async delete(key: string): Promise<void> {\r\n    if (typeof localStorage === 'undefined') {\r\n      return\r\n    }\r\n\r\n    localStorage.removeItem(this.prefix + key)\r\n  }\r\n\r\n  async clear(): Promise<void> {\r\n    if (typeof localStorage === 'undefined') {\r\n      return\r\n    }\r\n\r\n    // 只清除带有特定前缀的项\r\n    const keysToRemove: string[] = []\r\n    for (let i = 0; i < localStorage.length; i++) {\r\n      const key = localStorage.key(i)\r\n      if (key?.startsWith(this.prefix)) {\r\n        keysToRemove.push(key)\r\n      }\r\n    }\r\n\r\n    for (const key of keysToRemove) {\r\n      localStorage.removeItem(key)\r\n    }\r\n  }\r\n\r\n  async has(key: string): Promise<boolean> {\r\n    if (typeof localStorage === 'undefined') {\r\n      return false\r\n    }\r\n    return localStorage.getItem(this.prefix + key) !== null\r\n  }\r\n\r\n  /**\r\n   * 处理存储配额超限\r\n   */\r\n  private handleStorageQuotaExceeded(): void {\r\n    // 清理最旧的缓存项\r\n    const items: { key: string; timestamp: number }[] = []\r\n    \r\n    for (let i = 0; i < localStorage.length; i++) {\r\n      const key = localStorage.key(i)\r\n      if (key?.startsWith(this.prefix)) {\r\n        try {\r\n          const item = JSON.parse(localStorage.getItem(key)!) as CacheItem\r\n          items.push({ key, timestamp: item.timestamp })\r\n        } catch {\r\n          // 忽略解析错误的项\r\n        }\r\n      }\r\n    }\r\n\r\n    // 按时间戳排序，删除最旧的10%\r\n    items.sort((a, b) => a.timestamp - b.timestamp)\r\n    const toRemove = Math.ceil(items.length * 0.1)\r\n    \r\n    for (let i = 0; i < toRemove; i++) {\r\n      localStorage.removeItem(items[i].key)\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * SessionStorage 缓存存储实现\r\n */\r\nexport class SessionStorageCacheStorage extends LocalStorageCacheStorage {\r\n  constructor(prefix = 'http_session_cache_') {\r\n    super(prefix)\r\n  }\r\n\r\n  async get(key: string): Promise<any> {\r\n    if (typeof sessionStorage === 'undefined') {\r\n      return null\r\n    }\r\n\r\n    try {\r\n      const item = sessionStorage.getItem(this.prefix + key)\r\n      if (!item) {\r\n        return null\r\n      }\r\n\r\n      const parsed = JSON.parse(item) as CacheItem\r\n\r\n      // 检查是否过期\r\n      if (Date.now() - parsed.timestamp > parsed.ttl) {\r\n        await this.delete(key)\r\n        return null\r\n      }\r\n\r\n      return parsed.data\r\n    }\r\n    catch {\r\n      return null\r\n    }\r\n  }\r\n\r\n  async set(key: string, value: any, ttl = 300000): Promise<void> {\r\n    if (typeof sessionStorage === 'undefined') {\r\n      return\r\n    }\r\n\r\n    try {\r\n      const item: CacheItem = {\r\n        data: value,\r\n        timestamp: Date.now(),\r\n        ttl,\r\n      }\r\n\r\n      sessionStorage.setItem(this.prefix + key, JSON.stringify(item))\r\n    }\r\n    catch {\r\n      // 存储失败\r\n    }\r\n  }\r\n\r\n  async delete(key: string): Promise<void> {\r\n    if (typeof sessionStorage === 'undefined') {\r\n      return\r\n    }\r\n\r\n    sessionStorage.removeItem(this.prefix + key)\r\n  }\r\n\r\n  async clear(): Promise<void> {\r\n    if (typeof sessionStorage === 'undefined') {\r\n      return\r\n    }\r\n\r\n    const keysToRemove: string[] = []\r\n    for (let i = 0; i < sessionStorage.length; i++) {\r\n      const key = sessionStorage.key(i)\r\n      if (key?.startsWith(this.prefix)) {\r\n        keysToRemove.push(key)\r\n      }\r\n    }\r\n\r\n    for (const key of keysToRemove) {\r\n      sessionStorage.removeItem(key)\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * IndexedDB 缓存存储实现\r\n */\r\nexport class IndexedDBCacheStorage implements CacheStorage {\r\n  private dbName: string\r\n  private storeName = 'cache'\r\n  private db: IDBDatabase | null = null\r\n\r\n  constructor(dbName = 'http_cache_db') {\r\n    this.dbName = dbName\r\n    this.init()\r\n  }\r\n\r\n  private async init(): Promise<void> {\r\n    if (typeof indexedDB === 'undefined') {\r\n      return\r\n    }\r\n\r\n    return new Promise((resolve, reject) => {\r\n      const request = indexedDB.open(this.dbName, 1)\r\n\r\n      request.onerror = () => reject(request.error)\r\n      request.onsuccess = () => {\r\n        this.db = request.result\r\n        resolve()\r\n      }\r\n\r\n      request.onupgradeneeded = (event) => {\r\n        const db = (event.target as IDBOpenDBRequest).result\r\n        if (!db.objectStoreNames.contains(this.storeName)) {\r\n          db.createObjectStore(this.storeName, { keyPath: 'key' })\r\n        }\r\n      }\r\n    })\r\n  }\r\n\r\n  async get(key: string): Promise<any> {\r\n    if (!this.db) await this.init()\r\n    if (!this.db) return null\r\n\r\n    return new Promise((resolve, reject) => {\r\n      const transaction = this.db!.transaction([this.storeName], 'readonly')\r\n      const store = transaction.objectStore(this.storeName)\r\n      const request = store.get(key)\r\n\r\n      request.onerror = () => reject(request.error)\r\n      request.onsuccess = () => {\r\n        const result = request.result\r\n        if (!result) {\r\n          resolve(null)\r\n          return\r\n        }\r\n\r\n        // 检查是否过期\r\n        if (Date.now() - result.timestamp > result.ttl) {\r\n          this.delete(key)\r\n          resolve(null)\r\n          return\r\n        }\r\n\r\n        resolve(result.data)\r\n      }\r\n    })\r\n  }\r\n\r\n  async set(key: string, value: any, ttl = 300000): Promise<void> {\r\n    if (!this.db) await this.init()\r\n    if (!this.db) return\r\n\r\n    return new Promise((resolve, reject) => {\r\n      const transaction = this.db!.transaction([this.storeName], 'readwrite')\r\n      const store = transaction.objectStore(this.storeName)\r\n      \r\n      const item = {\r\n        key,\r\n        data: value,\r\n        timestamp: Date.now(),\r\n        ttl,\r\n      }\r\n\r\n      const request = store.put(item)\r\n\r\n      request.onerror = () => reject(request.error)\r\n      request.onsuccess = () => resolve()\r\n    })\r\n  }\r\n\r\n  async delete(key: string): Promise<void> {\r\n    if (!this.db) await this.init()\r\n    if (!this.db) return\r\n\r\n    return new Promise((resolve, reject) => {\r\n      const transaction = this.db!.transaction([this.storeName], 'readwrite')\r\n      const store = transaction.objectStore(this.storeName)\r\n      const request = store.delete(key)\r\n\r\n      request.onerror = () => reject(request.error)\r\n      request.onsuccess = () => resolve()\r\n    })\r\n  }\r\n\r\n  async clear(): Promise<void> {\r\n    if (!this.db) await this.init()\r\n    if (!this.db) return\r\n\r\n    return new Promise((resolve, reject) => {\r\n      const transaction = this.db!.transaction([this.storeName], 'readwrite')\r\n      const store = transaction.objectStore(this.storeName)\r\n      const request = store.clear()\r\n\r\n      request.onerror = () => reject(request.error)\r\n      request.onsuccess = () => resolve()\r\n    })\r\n  }\r\n\r\n  async has(key: string): Promise<boolean> {\r\n    const value = await this.get(key)\r\n    return value !== null\r\n  }\r\n\r\n  destroy(): void {\r\n    if (this.db) {\r\n      this.db.close()\r\n      this.db = null\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * 创建缓存存储\r\n */\r\nexport function createCacheStorage(type: 'memory' | 'local' | 'session' | 'indexeddb' = 'memory'): CacheStorage {\r\n  switch (type) {\r\n    case 'local':\r\n      return new LocalStorageCacheStorage()\r\n    case 'session':\r\n      return new SessionStorageCacheStorage()\r\n    case 'indexeddb':\r\n      return new IndexedDBCacheStorage()\r\n    case 'memory':\r\n    default:\r\n      return new MemoryCacheStorage()\r\n  }\r\n}"],"names":["MemoryCacheStorage","constructor","this","cache","Map","cleanupInterval","startCleanup","get","key","item","Date","now","timestamp","ttl","delete","metadata","lastAccessed","accessCount","data","set","value","createdAt","size","calculateSize","clear","has","deleteBatch","keys","Array","from","getMetadata","cleanupTimer","setInterval","cleanupExpired","keysToDelete","entries","push","JSON","stringify","length","destroy","clearInterval","LocalStorageCacheStorage","prefix","localStorage","getItem","parsed","parse","setItem","handleStorageQuotaExceeded","removeItem","keysToRemove","i","startsWith","items","sort","a","b","toRemove","Math","ceil","SessionStorageCacheStorage","super","sessionStorage","IndexedDBCacheStorage","dbName","storeName","db","init","indexedDB","Promise","resolve","reject","request","open","onerror","error","onsuccess","result","onupgradeneeded","event","target","objectStoreNames","contains","createObjectStore","keyPath","transaction","objectStore","store","put","close","type"],"mappings":"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"}