{"version":3,"file":"middleware.cjs","sources":["../../src/interceptors/middleware.ts"],"sourcesContent":["/**\n * 拦截器中间件系统\n * \n * 提供可组合、可复用的拦截器中间件模式\n */\n\nimport type {\n  ErrorInterceptor,\n  HttpError,\n  RequestConfig,\n  RequestInterceptor,\n  ResponseData,\n  ResponseInterceptor,\n} from '../types'\n\n/**\n * 中间件函数类型\n */\nexport type Middleware<TContext = any> = (\n  context: TContext,\n  next: () => Promise<TContext>,\n) => Promise<TContext>\n\n/**\n * 请求中间件类型\n */\nexport type RequestMiddleware = Middleware<RequestConfig>\n\n/**\n * 响应中间件类型\n */\nexport type ResponseMiddleware<T = any> = Middleware<ResponseData<T>>\n\n/**\n * 错误中间件类型\n */\nexport type ErrorMiddleware = (\n  error: HttpError,\n  next: (error: HttpError) => Promise<HttpError>,\n) => Promise<HttpError>\n\n/**\n * 组合多个请求中间件为一个拦截器\n * \n * @param middlewares - 中间件数组\n * @returns 组合后的请求拦截器\n * \n * @example\n * ```typescript\n * const logRequest: RequestMiddleware = async (config, next) => {\n *   \n *   return next()\n * }\n * \n * const addTimestamp: RequestMiddleware = async (config, next) => {\n *   config.params = { ...config.params, _t: Date.now() }\n *   return next()\n * }\n * \n * const interceptor = composeRequestMiddleware([logRequest, addTimestamp])\n * client.interceptors.request.use(interceptor)\n * ```\n */\nexport function composeRequestMiddleware(\n  middlewares: RequestMiddleware[],\n): RequestInterceptor {\n  if (!Array.isArray(middlewares) || middlewares.length === 0) {\n    return (config: RequestConfig) => config\n  }\n\n  return async (config: RequestConfig): Promise<RequestConfig> => {\n    const index = 0\n\n    async function dispatch(i: number, ctx: RequestConfig): Promise<RequestConfig> {\n      if (i >= middlewares.length) {\n        return ctx\n      }\n\n      const middleware = middlewares[i]!\n\n      return middleware(ctx, () => dispatch(i + 1, ctx))\n    }\n\n    return dispatch(index, config)\n  }\n}\n\n/**\n * 组合多个响应中间件为一个拦截器\n * \n * @param middlewares - 中间件数组\n * @returns 组合后的响应拦截器\n * \n * @example\n * ```typescript\n * const logResponse: ResponseMiddleware = async (response, next) => {\n *   \n *   return next()\n * }\n * \n * const extractData: ResponseMiddleware = async (response, next) => {\n *   // 提取嵌套的数据字段\n *   if (response.data?.result) {\n *     response.data = response.data.result\n *   }\n *   return next()\n * }\n * \n * const interceptor = composeResponseMiddleware([logResponse, extractData])\n * client.interceptors.response.use(interceptor)\n * ```\n */\nexport function composeResponseMiddleware<T = any>(\n  middlewares: ResponseMiddleware<T>[],\n): ResponseInterceptor<T> {\n  if (!Array.isArray(middlewares) || middlewares.length === 0) {\n    return (response: ResponseData<T>) => response\n  }\n\n  return async (response: ResponseData<T>): Promise<ResponseData<T>> => {\n    const index = 0\n\n    async function dispatch(i: number, ctx: ResponseData<T>): Promise<ResponseData<T>> {\n      if (i >= middlewares.length) {\n        return ctx\n      }\n\n      const middleware = middlewares[i]!\n\n      return middleware(ctx, () => dispatch(i + 1, ctx))\n    }\n\n    return dispatch(index, response)\n  }\n}\n\n/**\n * 组合多个错误中间件为一个拦截器\n * \n * @param middlewares - 中间件数组\n * @returns 组合后的错误拦截器\n * \n * @example\n * ```typescript\n * const logError: ErrorMiddleware = async (error, next) => {\n *   console.error('Error:', error.message)\n *   return next(error)\n * }\n * \n * const retryOn5xx: ErrorMiddleware = async (error, next) => {\n *   if (error.response?.status >= 500) {\n *     // 自定义重试逻辑\n *   }\n *   return next(error)\n * }\n * \n * const interceptor = composeErrorMiddleware([logError, retryOn5xx])\n * client.interceptors.error.use(interceptor)\n * ```\n */\nexport function composeErrorMiddleware(\n  middlewares: ErrorMiddleware[],\n): ErrorInterceptor {\n  if (!Array.isArray(middlewares) || middlewares.length === 0) {\n    return (error: HttpError) => error\n  }\n\n  return async (error: HttpError): Promise<HttpError> => {\n    const index = 0\n\n    async function dispatch(i: number, err: HttpError): Promise<HttpError> {\n      if (i >= middlewares.length) {\n        return err\n      }\n\n      const middleware = middlewares[i]!\n\n      return middleware(err, nextError => dispatch(i + 1, nextError))\n    }\n\n    return dispatch(index, error)\n  }\n}\n\n/**\n * 创建条件中间件\n * \n * 只在满足条件时执行中间件\n * \n * @param condition - 条件函数\n * @param middleware - 要执行的中间件\n * @returns 条件中间件\n * \n * @example\n * ```typescript\n * const addAuthToken: RequestMiddleware = async (config, next) => {\n *   config.headers = { ...config.headers, Authorization: 'Bearer token' }\n *   return next()\n * }\n * \n * // 只对 /api 路径的请求添加认证\n * const conditionalAuth = createConditionalMiddleware(\n *   (config) => config.url?.startsWith('/api'),\n *   addAuthToken\n * )\n * ```\n */\nexport function createConditionalMiddleware<TContext>(\n  condition: (context: TContext) => boolean | Promise<boolean>,\n  middleware: Middleware<TContext>,\n): Middleware<TContext> {\n  return async (context: TContext, next: () => Promise<TContext>): Promise<TContext> => {\n    const shouldExecute = await condition(context)\n\n    if (shouldExecute) {\n      return middleware(context, next)\n    }\n\n    return next()\n  }\n}\n\n/**\n * 创建请求路径匹配中间件\n * \n * @param pattern - URL 匹配模式（正则或字符串）\n * @param middleware - 要执行的中间件\n * @returns 路径匹配中间件\n * \n * @example\n * ```typescript\n * const logApiRequests: RequestMiddleware = async (config, next) => {\n *   \n *   return next()\n * }\n * \n * // 只记录 API 请求\n * const apiLogger = createPathMatchMiddleware(/^\\/api\\//, logApiRequests)\n * ```\n */\nexport function createPathMatchMiddleware(\n  pattern: string | RegExp,\n  middleware: RequestMiddleware,\n): RequestMiddleware {\n  const matcher = typeof pattern === 'string'\n    ? (url: string) => url.includes(pattern)\n    : (url: string) => pattern.test(url)\n\n  return createConditionalMiddleware(\n    (config: RequestConfig) => {\n      const url = config.url || ''\n      return matcher(url)\n    },\n    middleware,\n  )\n}\n\n/**\n * 创建方法匹配中间件\n * \n * @param methods - HTTP 方法数组\n * @param middleware - 要执行的中间件\n * @returns 方法匹配中间件\n * \n * @example\n * ```typescript\n * const addCsrfToken: RequestMiddleware = async (config, next) => {\n *   config.headers = { ...config.headers, 'X-CSRF-Token': getCsrfToken() }\n *   return next()\n * }\n * \n * // 只对写操作添加 CSRF token\n * const csrfProtection = createMethodMatchMiddleware(\n *   ['POST', 'PUT', 'PATCH', 'DELETE'],\n *   addCsrfToken\n * )\n * ```\n */\nexport function createMethodMatchMiddleware(\n  methods: string[],\n  middleware: RequestMiddleware,\n): RequestMiddleware {\n  const methodSet = new Set(methods.map(m => m.toUpperCase()))\n\n  return createConditionalMiddleware(\n    (config: RequestConfig) => {\n      const method = (config.method || 'GET').toUpperCase()\n      return methodSet.has(method)\n    },\n    middleware,\n  )\n}\n\n/**\n * 创建计时中间件\n * \n * 自动测量请求执行时间\n * \n * @param onComplete - 完成回调\n * @returns 计时中间件\n * \n * @example\n * ```typescript\n * const timingMiddleware = createTimingMiddleware((duration, config) => {\n *   \n * })\n * ```\n */\nexport function createTimingMiddleware(\n  onComplete?: (duration: number, config: RequestConfig) => void,\n): RequestMiddleware {\n  return async (config: RequestConfig, next: () => Promise<RequestConfig>): Promise<RequestConfig> => {\n    const startTime = Date.now()\n\n    try {\n      return await next()\n    }\n    finally {\n      const duration = Date.now() - startTime\n      onComplete?.(duration, config)\n    }\n  }\n}\n\n/**\n * 创建缓存中间件\n * \n * 缓存中间件执行结果\n * \n * @param options - 缓存选项\n * @param options.ttl - 缓存过期时间（毫秒），默认60000\n * @param options.keyGenerator - 缓存键生成函数\n * @param options.middleware - 要缓存的中间件\n * @returns 缓存中间件\n * \n * @example\n * ```typescript\n * const cachedMiddleware = createCacheMiddleware({\n *   ttl: 60000, // 1分钟\n *   keyGenerator: (config) => config.url,\n *   middleware: expensiveMiddleware\n * })\n * ```\n */\nexport function createCacheMiddleware<TContext>(options: {\n  ttl?: number\n  keyGenerator: (context: TContext) => string\n  middleware: Middleware<TContext>\n}): Middleware<TContext> {\n  const { ttl = 60000, keyGenerator, middleware } = options\n  const cache = new Map<string, { value: TContext, expiry: number }>()\n\n  return async (context: TContext, next: () => Promise<TContext>): Promise<TContext> => {\n    const key = keyGenerator(context)\n    const now = Date.now()\n\n    // 检查缓存\n    const cached = cache.get(key)\n    if (cached && cached.expiry > now) {\n      return cached.value\n    }\n\n    // 执行中间件\n    const result = await middleware(context, next)\n\n    // 存入缓存\n    cache.set(key, {\n      value: result,\n      expiry: now + ttl,\n    })\n\n    return result\n  }\n}\n\n/**\n * 创建重试中间件\n * \n * 自动重试失败的中间件\n * \n * @param options - 重试选项\n * @param options.maxAttempts - 最大重试次数，默认3次\n * @param options.delay - 重试延迟（毫秒），默认1000\n * @param options.shouldRetry - 判断是否应该重试的函数\n * @param options.middleware - 要重试的中间件\n * @returns 重试中间件\n * \n * @example\n * ```typescript\n * const retryMiddleware = createRetryMiddleware({\n *   maxAttempts: 3,\n *   delay: 1000,\n *   shouldRetry: (error) => error.status === 503,\n *   middleware: unstableMiddleware\n * })\n * ```\n */\nexport function createRetryMiddleware<TContext>(options: {\n  maxAttempts?: number\n  delay?: number\n  shouldRetry?: (error: any, attempt: number) => boolean\n  middleware: Middleware<TContext>\n}): Middleware<TContext> {\n  const {\n    maxAttempts = 3,\n    delay = 1000,\n    shouldRetry = () => true,\n    middleware,\n  } = options\n\n  return async (context: TContext, next: () => Promise<TContext>): Promise<TContext> => {\n    let lastError: any\n\n    for (let attempt = 1; attempt <= maxAttempts; attempt++) {\n      try {\n        return await middleware(context, next)\n      }\n      catch (error) {\n        lastError = error\n\n        if (attempt < maxAttempts && shouldRetry(error, attempt)) {\n          await new Promise(resolve => setTimeout(resolve, delay * attempt))\n        }\n        else {\n          throw error\n        }\n      }\n    }\n\n    throw lastError\n  }\n}\n\n/**\n * 创建管道中间件\n * \n * 按顺序执行一系列转换函数\n * \n * @param transforms - 转换函数数组\n * @returns 管道中间件\n * \n * @example\n * ```typescript\n * const pipeline = createPipelineMiddleware([\n *   (config) => ({ ...config, headers: { ...config.headers, 'X-Custom': 'value' } }),\n *   (config) => ({ ...config, timeout: 5000 }),\n *   (config) => ({ ...config, withCredentials: true })\n * ])\n * ```\n */\nexport function createPipelineMiddleware<TContext>(\n  transforms: Array<(context: TContext) => TContext | Promise<TContext>>,\n): Middleware<TContext> {\n  return async (context: TContext, next: () => Promise<TContext>): Promise<TContext> => {\n    let result = context\n\n    for (const transform of transforms) {\n      result = await transform(result)\n    }\n\n    return next()\n  }\n}\n\n/**\n * 中间件构建器\n * \n * 提供流畅的 API 来构建复杂的中间件组合\n * \n * @example\n * ```typescript\n * const middleware = new MiddlewareBuilder<RequestConfig>()\n *   .use(loggingMiddleware)\n *   .when(config => config.url?.includes('/api'), authMiddleware)\n *   .timing((duration, config) => )\n *   .build()\n * ```\n */\nexport class MiddlewareBuilder<TContext> {\n  private middlewares: Array<Middleware<TContext>> = []\n\n  /**\n   * 添加中间件\n   */\n  use(middleware: Middleware<TContext>): this {\n    this.middlewares.push(middleware)\n    return this\n  }\n\n  /**\n   * 添加条件中间件\n   */\n  when(\n    condition: (context: TContext) => boolean | Promise<boolean>,\n    middleware: Middleware<TContext>,\n  ): this {\n    this.middlewares.push(createConditionalMiddleware(condition, middleware))\n    return this\n  }\n\n  /**\n   * 添加计时中间件（仅适用于 RequestConfig）\n   */\n  timing(\n    onComplete: (duration: number, config: any) => void,\n  ): this {\n    this.middlewares.push(createTimingMiddleware(onComplete) as any)\n    return this\n  }\n\n  /**\n   * 添加管道转换\n   */\n  pipe(\n    ...transforms: Array<(context: TContext) => TContext | Promise<TContext>>\n  ): this {\n    this.middlewares.push(createPipelineMiddleware(transforms))\n    return this\n  }\n\n  /**\n   * 构建最终的中间件\n   */\n  build(): Middleware<TContext> {\n    const composed = this.middlewares\n\n    return async (context: TContext, next: () => Promise<TContext>): Promise<TContext> => {\n      const index = 0\n\n      async function dispatch(i: number, ctx: TContext): Promise<TContext> {\n        if (i >= composed.length) {\n          return next()\n        }\n\n        const middleware = composed[i]!\n\n        return middleware(ctx, () => dispatch(i + 1, ctx))\n      }\n\n      return dispatch(index, context)\n    }\n  }\n\n  /**\n   * 清空所有中间件\n   */\n  clear(): this {\n    this.middlewares = []\n    return this\n  }\n\n  /**\n   * 获取中间件数量\n   */\n  get size(): number {\n    return this.middlewares.length\n  }\n}\n"],"names":["createConditionalMiddleware","condition","middleware","async","context","next","createTimingMiddleware","onComplete","config","startTime","Date","now","duration","createPipelineMiddleware","transforms","result","transform","constructor","this","middlewares","use","push","when","timing","pipe","build","composed","dispatch","i","ctx","length","clear","size","Array","isArray","err","nextError","error","response","options","ttl","keyGenerator","cache","Map","key","cached","get","expiry","value","set","methods","methodSet","Set","map","m","toUpperCase","method","has","pattern","matcher","url","includes","test","maxAttempts","delay","shouldRetry","lastError","attempt","Promise","resolve","setTimeout"],"mappings":"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"}