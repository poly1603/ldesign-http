function e(e,r){if(!r(e))throw new TypeError("Type assertion failed")}function r(e){return null!=e}function t(e){return"string"==typeof e}function n(e){return"number"==typeof e&&!Number.isNaN(e)}function s(e){return"object"==typeof e&&null!==e&&!Array.isArray(e)}function u(e){return Array.isArray(e)}function o(e){return"function"==typeof e}function i(e){return Object.keys(e)}function a(e){return Object.values(e)}function c(e){return Object.entries(e)}function f(e){return Object.freeze(e)}function y(e,r){return e.filter(r)}function p(e,r){return{...e,...r}}function l(e){if(null===e||"object"!=typeof e)return e;if(e instanceof Date)return new Date(e.getTime());if(Array.isArray(e))return e.map(e=>l(e));if("object"==typeof e){const r={};for(const t in e)Object.prototype.hasOwnProperty.call(e,t)&&(r[t]=l(e[t]));return r}return e}function b(e){try{return JSON.parse(e)}catch{return null}}function d(e,r){return e?.[r]}function j(e,r){return r.split(".").reduce((e,r)=>e?.[r],e)}function m(e,r,t){const n=new Error(r);return n.type=e,n.cause=t,n}function N(e){let r,t;const n=new Promise((e,n)=>{r=e,t=n});return e.then(r,t),{promise:n,resolve:r,reject:t}}export{e as assertType,f as createEnum,m as createTypedError,l as deepClone,u as isArray,o as isFunction,r as isNonNull,n as isNumber,s as isObject,t as isString,d as safeGet,j as safeGetNested,b as safeJsonParse,c as typedEntries,y as typedFilter,i as typedKeys,p as typedMerge,a as typedValues,N as wrapPromise};
//# sourceMappingURL=utils.js.map
