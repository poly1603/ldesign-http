{"version":3,"file":"utils.js","sources":["../../src/types/utils.ts"],"sourcesContent":["/**\r\n * TypeScript 类型工具集\r\n * 提供高级类型操作和类型安全的工具函数\r\n */\r\n\r\nimport type { HttpError, HttpMethod } from './index'\r\n\r\n/**\r\n * 字面量类型：HTTP 状态码分类\r\n */\r\nexport type SuccessStatusCode = 200 | 201 | 202 | 204\r\nexport type RedirectStatusCode = 300 | 301 | 302 | 303 | 304 | 307 | 308\r\nexport type ClientErrorStatusCode = 400 | 401 | 403 | 404 | 405 | 409 | 422 | 429\r\nexport type ServerErrorStatusCode = 500 | 501 | 502 | 503 | 504 | 505\r\n\r\n/**\r\n * 联合类型：所有状态码\r\n */\r\nexport type AllStatusCode = SuccessStatusCode | RedirectStatusCode | ClientErrorStatusCode | ServerErrorStatusCode\r\n\r\n/**\r\n * 映射类型：状态码到消息的映射\r\n */\r\nexport type StatusCodeMessages = {\r\n  [K in AllStatusCode]: string\r\n}\r\n\r\n/**\r\n * 条件类型：根据 HTTP 方法确定是否允许请求体\r\n */\r\nexport type AllowsRequestBody<T extends HttpMethod> =\r\n  T extends 'GET' | 'HEAD' | 'DELETE' ? false : true\r\n\r\n/**\r\n * 条件类型：根据是否允许请求体确定数据类型\r\n */\r\nexport type RequestBodyType<T extends HttpMethod, TData = any> =\r\n  AllowsRequestBody<T> extends true ? TData : never\r\n\r\n/**\r\n * 模板字面量类型：URL 路径参数提取\r\n */\r\nexport type ExtractPathParams<T extends string> =\r\n  T extends `${infer _Start}:${infer Param}/${infer Rest}`\r\n    ? Param | ExtractPathParams<Rest>\r\n    : T extends `${infer _Start}:${infer Param}`\r\n      ? Param\r\n      : never\r\n\r\n/**\r\n * 模板字面量类型：构建带参数的 URL\r\n */\r\nexport type BuildUrlWithParams<\r\n  TPath extends string,\r\n  TParams extends Record<string, string | number>,\r\n> = TPath extends `${infer Start}:${infer Param}/${infer Rest}`\r\n  ? Param extends keyof TParams\r\n    ? `${Start}${TParams[Param]}/${BuildUrlWithParams<Rest, TParams>}`\r\n    : never\r\n  : TPath extends `${infer Start}:${infer Param}`\r\n    ? Param extends keyof TParams\r\n      ? `${Start}${TParams[Param]}`\r\n      : never\r\n    : TPath\r\n\r\n/**\r\n * 递归类型：深度合并两个对象类型\r\n */\r\nexport type DeepMerge<T, U> = {\r\n  [K in keyof T | keyof U]: K extends keyof U\r\n    ? K extends keyof T\r\n      ? T[K] extends object\r\n        ? U[K] extends object\r\n          ? DeepMerge<T[K], U[K]>\r\n          : U[K]\r\n        : U[K]\r\n      : U[K]\r\n    : K extends keyof T\r\n      ? T[K]\r\n      : never\r\n}\r\n\r\n/**\r\n * 工具类型：提取对象中的函数类型\r\n */\r\nexport type FunctionKeys<T> = {\r\n  [K in keyof T]: T[K] extends (...args: any[]) => any ? K : never\r\n}[keyof T]\r\n\r\n/**\r\n * 工具类型：提取对象中的非函数类型\r\n */\r\nexport type NonFunctionKeys<T> = {\r\n  [K in keyof T]: T[K] extends (...args: any[]) => any ? never : K\r\n}[keyof T]\r\n\r\n/**\r\n * 工具类型：只保留函数属性\r\n */\r\nexport type FunctionsOnly<T> = Pick<T, FunctionKeys<T>>\r\n\r\n/**\r\n * 工具类型：只保留非函数属性\r\n */\r\nexport type PropertiesOnly<T> = Pick<T, NonFunctionKeys<T>>\r\n\r\n/**\r\n * 条件类型：检查类型是否为 Promise\r\n */\r\nexport type IsPromise<T> = T extends Promise<any> ? true : false\r\n\r\n/**\r\n * 条件类型：提取 Promise 的值类型\r\n */\r\nexport type UnwrapPromise<T> = T extends Promise<infer U> ? U : T\r\n\r\n/**\r\n * 工具类型：创建严格的枚举类型\r\n */\r\nexport type StrictEnum<T extends Record<string, string | number>> = T[keyof T]\r\n\r\n/**\r\n * 工具类型：创建只读的元组类型\r\n */\r\nexport type ReadonlyTuple<T extends readonly any[]> = readonly [...T]\r\n\r\n/**\r\n * 工具类型：数组转联合类型\r\n */\r\nexport type ArrayToUnion<T extends readonly any[]> = T[number]\r\n\r\n/**\r\n * 工具类型：联合类型转交叉类型\r\n */\r\nexport type UnionToIntersection<U> =\r\n  (U extends any ? (k: U) => void : never) extends ((k: infer I) => void) ? I : never\r\n\r\n/**\r\n * 高级类型：分布式条件类型示例\r\n */\r\nexport type DistributiveOmit<T, K extends keyof any> = T extends any ? Omit<T, K> : never\r\n\r\n/**\r\n * 类型断言函数：确保值是指定类型\r\n */\r\nexport function assertType<T>(value: unknown, predicate: (value: unknown) => value is T): asserts value is T {\r\n  if (!predicate(value)) {\r\n    throw new TypeError('Type assertion failed')\r\n  }\r\n}\r\n\r\n/**\r\n * 类型守卫：检查值是否为非空\r\n */\r\nexport function isNonNull<T>(value: T | null | undefined): value is T {\r\n  return value !== null && value !== undefined\r\n}\r\n\r\n/**\r\n * 类型守卫：检查值是否为字符串\r\n */\r\nexport function isString(value: unknown): value is string {\r\n  return typeof value === 'string'\r\n}\r\n\r\n/**\r\n * 类型守卫：检查值是否为数字\r\n */\r\nexport function isNumber(value: unknown): value is number {\r\n  return typeof value === 'number' && !Number.isNaN(value)\r\n}\r\n\r\n/**\r\n * 类型守卫：检查值是否为对象\r\n */\r\nexport function isObject(value: unknown): value is Record<string, unknown> {\r\n  return typeof value === 'object' && value !== null && !Array.isArray(value)\r\n}\r\n\r\n/**\r\n * 类型守卫：检查值是否为数组\r\n */\r\nexport function isArray<T>(value: unknown): value is T[] {\r\n  return Array.isArray(value)\r\n}\r\n\r\n/**\r\n * 类型守卫：检查值是否为函数\r\n */\r\nexport function isFunction(value: unknown): value is (...args: any[]) => any {\r\n  return typeof value === 'function'\r\n}\r\n\r\n/**\r\n * 类型安全的对象键遍历\r\n */\r\nexport function typedKeys<T extends Record<string, any>>(obj: T): Array<keyof T> {\r\n  return Object.keys(obj) as Array<keyof T>\r\n}\r\n\r\n/**\r\n * 类型安全的对象值遍历\r\n */\r\nexport function typedValues<T extends Record<string, any>>(obj: T): Array<T[keyof T]> {\r\n  return Object.values(obj)\r\n}\r\n\r\n/**\r\n * 类型安全的对象条目遍历\r\n */\r\nexport function typedEntries<T extends Record<string, any>>(obj: T): Array<[keyof T, T[keyof T]]> {\r\n  return Object.entries(obj) as Array<[keyof T, T[keyof T]]>\r\n}\r\n\r\n/**\r\n * 创建类型安全的枚举\r\n */\r\nexport function createEnum<T extends Record<string, string | number>>(obj: T): Readonly<T> {\r\n  return Object.freeze(obj)\r\n}\r\n\r\n/**\r\n * 类型安全的数组过滤\r\n */\r\nexport function typedFilter<T, U extends T>(\r\n  array: T[],\r\n  predicate: (value: T) => value is U,\r\n): U[] {\r\n  return array.filter(predicate)\r\n}\r\n\r\n/**\r\n * 类型安全的对象合并\r\n */\r\nexport function typedMerge<T extends Record<string, any>, U extends Record<string, any>>(\r\n  target: T,\r\n  source: U,\r\n): T & U {\r\n  return { ...target, ...source }\r\n}\r\n\r\n/**\r\n * 深度克隆（类型安全）\r\n */\r\nexport function deepClone<T>(obj: T): T {\r\n  if (obj === null || typeof obj !== 'object') {\r\n    return obj\r\n  }\r\n\r\n  if (obj instanceof Date) {\r\n    return new Date(obj.getTime()) as T\r\n  }\r\n\r\n  if (Array.isArray(obj)) {\r\n    return obj.map(item => deepClone(item)) as T\r\n  }\r\n\r\n  if (typeof obj === 'object') {\r\n    const cloned = {} as T\r\n    for (const key in obj) {\r\n      if (Object.prototype.hasOwnProperty.call(obj, key)) {\r\n        cloned[key] = deepClone(obj[key])\r\n      }\r\n    }\r\n    return cloned\r\n  }\r\n\r\n  return obj\r\n}\r\n\r\n/**\r\n * 类型安全的 JSON 解析\r\n */\r\nexport function safeJsonParse<T = unknown>(json: string): T | null {\r\n  try {\r\n    return JSON.parse(json) as T\r\n  }\r\n  catch {\r\n    return null\r\n  }\r\n}\r\n\r\n/**\r\n * 类型安全的属性访问\r\n */\r\nexport function safeGet<T, K extends keyof T>(obj: T, key: K): T[K] | undefined {\r\n  return obj?.[key]\r\n}\r\n\r\n/**\r\n * 类型安全的嵌套属性访问\r\n */\r\nexport function safeGetNested<T>(obj: T, path: string): any {\r\n  return path.split('.').reduce((current, key) => current?.[key], obj as any)\r\n}\r\n\r\n/**\r\n * 创建类型化的错误\r\n */\r\nexport function createTypedError<T extends string>(\r\n  type: T,\r\n  message: string,\r\n  cause?: Error,\r\n): HttpError & { type: T } {\r\n  const error = new Error(message) as HttpError & { type: T }\r\n  error.type = type\r\n  error.cause = cause\r\n  return error\r\n}\r\n\r\n/**\r\n * 类型化的 Promise 包装器\r\n */\r\nexport function wrapPromise<T>(promise: Promise<T>): {\r\n  promise: Promise<T>\r\n  resolve: (value: T) => void\r\n  reject: (reason?: any) => void\r\n} {\r\n  let resolve!: (value: T) => void\r\n  let reject!: (reason?: any) => void\r\n\r\n  const wrappedPromise = new Promise<T>((res, rej) => {\r\n    resolve = res\r\n    reject = rej\r\n  })\r\n\r\n  promise.then(resolve, reject)\r\n\r\n  return {\r\n    promise: wrappedPromise,\r\n    resolve,\r\n    reject,\r\n  }\r\n}\r\n"],"names":["assertType","value","predicate","TypeError","isNonNull","isString","isNumber","Number","isNaN","isObject","Array","isArray","isFunction","typedKeys","obj","Object","keys","typedValues","values","typedEntries","entries","createEnum","freeze","typedFilter","array","filter","typedMerge","target","source","deepClone","Date","getTime","map","item","cloned","key","prototype","hasOwnProperty","call","safeJsonParse","json","JSON","parse","safeGet","safeGetNested","path","split","reduce","current","createTypedError","type","message","cause","error","Error","wrapPromise","promise","resolve","reject","wrappedPromise","Promise","res","rej","then","c","m","T","u","p","l","s","a","y","f","A","E","w","j","N","b","O","d","g"],"mappings":"AAiJM,SAAUA,EAAcC,EAAgBC,GAC5C,IAAKA,EAAUD,GACb,MAAM,IAAIE,UAAU,wBAExB,CAKM,SAAUC,EAAaH,GAC3B,OAAiB,MAAVA,CACT,CAKM,SAAUI,EAASJ,GACvB,MAAwB,iBAAVA,CAChB,CAKM,SAAUK,EAASL,GACvB,MAAwB,iBAAVA,IAAuBM,OAAOC,MAAMP,EACpD,CAKM,SAAUQ,EAASR,GACvB,MAAwB,iBAAVA,GAAgC,OAAVA,IAAmBS,MAAMC,QAAQV,EACvE,CAKM,SAAUU,EAAWV,GACzB,OAAOS,MAAMC,QAAQV,EACvB,CAKM,SAAUW,EAAWX,GACzB,MAAwB,mBAAVA,CAChB,CAKM,SAAUY,EAAyCC,GACvD,OAAOC,OAAOC,KAAKF,EACrB,CAKM,SAAUG,EAA2CH,GACzD,OAAOC,OAAOG,OAAOJ,EACvB,CAKM,SAAUK,EAA4CL,GAC1D,OAAOC,OAAOK,QAAQN,EACxB,CAKM,SAAUO,EAAsDP,GACpE,OAAOC,OAAOO,OAAOR,EACvB,CAKM,SAAUS,EACdC,EACAtB,GAEA,OAAOsB,EAAMC,OAAOvB,EACtB,CAKM,SAAUwB,EACdC,EACAC,GAEA,MAAO,IAAKD,KAAWC,EACzB,CAKM,SAAUC,EAAaf,GAC3B,GAAY,OAARA,GAA+B,iBAARA,EACzB,OAAOA,EAGT,GAAIA,aAAegB,KACjB,OAAO,IAAIA,KAAKhB,EAAIiB,WAGtB,GAAIrB,MAAMC,QAAQG,GAChB,OAAOA,EAAIkB,IAAIC,GAAQJ,EAAUI,IAGnC,GAAmB,iBAARnB,EAAkB,CAC3B,MAAMoB,EAAS,GACf,UAAWC,KAAOrB,EACZC,OAAOqB,UAAUC,eAAeC,KAAKxB,EAAKqB,KAC5CD,EAAOC,GAAON,EAAUf,EAAIqB,KAGhC,OAAOD,CACT,CAEA,OAAOpB,CACT,CAKM,SAAUyB,EAA2BC,GACzC,IACE,OAAOC,KAAKC,MAAMF,EACpB,OAEE,OAAO,IACT,CACF,CAKM,SAAUG,EAA8B7B,EAAQqB,GACpD,OAAOrB,IAAMqB,EACf,CAKM,SAAUS,EAAiB9B,EAAQ+B,GACvC,OAAOA,EAAKC,MAAM,KAAKC,OAAO,CAACC,EAASb,IAAQa,IAAUb,GAAMrB,EAClE,UAKgBmC,EACdC,EACAC,EACAC,GAEA,MAAMC,EAAQ,IAAIC,MAAMH,GACxB,OAAAE,EAAMH,KAAOA,EACbG,EAAMD,MAAQA,EACPC,CACT,CAKM,SAAUE,EAAeC,GAK7B,IAAIC,EACAC,EAEJ,MAAMC,EAAiB,IAAIC,QAAW,CAACC,EAAKC,KAC1CL,EAAUI,EACVH,EAASI,IAGX,OAAAN,EAAQO,KAAKN,EAASC,GAEf,CACLF,QAASG,EACTF,QAAAA,EACAC,OAAAA,EAEJ,QAAAM,gBAAAC,gBAAAC,sBAAAC,eAAAC,aAAAC,gBAAAC,eAAAC,cAAAC,cAAAC,cAAAC,aAAAC,mBAAAC,mBAAAC,kBAAAC,iBAAAC,eAAAC,gBAAAC,iBAAAC"}