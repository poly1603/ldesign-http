{"version":3,"file":"pool.js","sources":["../../src/utils/pool.ts"],"sourcesContent":["/**\r\n * 请求池化模块\r\n * 提供连接池管理和请求复用功能\r\n */\r\n\r\nimport type { RequestConfig } from '../types'\r\n\r\n/**\r\n * 连接信息\r\n */\r\nexport interface ConnectionInfo {\r\n  id: string\r\n  host: string\r\n  port: number\r\n  protocol: string\r\n  createdAt: number\r\n  lastUsedAt: number\r\n  useCount: number\r\n  state: 'idle' | 'active' | 'closed'\r\n}\r\n\r\n/**\r\n * 连接池配置\r\n */\r\nexport interface PoolConfig {\r\n  maxConnections?: number // 最大连接数\r\n  maxIdleConnections?: number // 最大空闲连接数\r\n  maxConnectionAge?: number // 连接最大生命周期(ms)\r\n  idleTimeout?: number // 空闲超时时间(ms)\r\n  connectionTimeout?: number // 连接超时时间(ms)\r\n  keepAlive?: boolean // 是否保持连接\r\n  keepAliveTimeout?: number // Keep-Alive超时时间(ms)\r\n  pipelining?: boolean // 是否启用管道化\r\n  maxPipelineLength?: number // 最大管道长度\r\n}\r\n\r\n/**\r\n * 连接池统计\r\n */\r\nexport interface PoolStats {\r\n  totalConnections: number\r\n  activeConnections: number\r\n  idleConnections: number\r\n  totalRequests: number\r\n  connectionReuse: number\r\n  averageRequestsPerConnection: number\r\n  connectionErrors: number\r\n}\r\n\r\n/**\r\n * 等待队列项\r\n */\r\ninterface WaitingRequest {\r\n  resolve: (connection: ConnectionInfo) => void\r\n  reject: (error: Error) => void\r\n  timestamp: number\r\n}\r\n\r\n/**\r\n * 请求连接池（优化版）\r\n *\r\n * 优化点：\r\n * 1. 事件驱动替代轮询，减少 CPU 占用\r\n * 2. 优化连接验证，缓存验证结果\r\n * 3. 合并定时器，减少定时器数量\r\n */\r\nexport class RequestPool {\r\n  private connections = new Map<string, ConnectionInfo[]>()\r\n  private config: Required<PoolConfig>\r\n  private stats = {\r\n    totalRequests: 0,\r\n    connectionReuse: 0,\r\n    connectionErrors: 0,\r\n  }\r\n\r\n  private cleanupTimer?: NodeJS.Timeout\r\n  // 等待队列（事件驱动）\r\n  private waitingQueues = new Map<string, WaitingRequest[]>()\r\n\r\n  constructor(config: PoolConfig = {}) {\r\n    this.config = {\r\n      maxConnections: 10,\r\n      maxIdleConnections: 5,\r\n      maxConnectionAge: 300000, // 5分钟\r\n      idleTimeout: 60000, // 1分钟\r\n      connectionTimeout: 30000, // 30秒\r\n      keepAlive: true,\r\n      keepAliveTimeout: 60000, // 1分钟\r\n      pipelining: false,\r\n      maxPipelineLength: 10,\r\n      ...config,\r\n    }\r\n\r\n    // 启动定期清理\r\n    this.startCleanup()\r\n  }\r\n\r\n  /**\r\n   * 获取或创建连接（优化版）\r\n   */\r\n  async getConnection(config: RequestConfig): Promise<ConnectionInfo> {\r\n    const key = this.getConnectionKey(config)\r\n    const connections = this.connections.get(key)\r\n\r\n    if (connections) {\r\n      // 查找可用的空闲连接（使用for循环优化性能）\r\n      const len = connections.length\r\n      for (let i = 0; i < len; i++) {\r\n        const conn = connections[i]!\r\n        if (conn.state === 'idle' && this.isConnectionValid(conn)) {\r\n          // 复用现有连接\r\n          this.markConnectionActive(conn)\r\n          this.stats.connectionReuse++\r\n          return conn\r\n        }\r\n      }\r\n    }\r\n\r\n    // 检查是否达到最大连接数（优化版：使用计数器而非filter）\r\n    const connectionList = connections || []\r\n    let activeCount = 0\r\n    const len = connectionList.length\r\n    for (let i = 0; i < len; i++) {\r\n      if (connectionList[i]!.state === 'active') {\r\n        activeCount++\r\n      }\r\n    }\r\n\r\n    if (activeCount >= this.config?.maxConnections) {\r\n      // 等待连接释放\r\n      return this.waitForConnection(key, config)\r\n    }\r\n\r\n    // 创建新连接\r\n    const newConnection = await this.createConnection(config)\r\n    connectionList.push(newConnection)\r\n    this.connections.set(key, connectionList)\r\n\r\n    return newConnection\r\n  }\r\n\r\n  /**\r\n   * 释放连接\r\n   */\r\n  releaseConnection(connection: ConnectionInfo): void {\r\n    const key = `${connection.protocol}//${connection.host}:${connection.port}`\r\n    const connections = this.connections.get(key)\r\n\r\n    if (!connections)\r\n      return\r\n\r\n    const conn = connections.find(c => c.id === connection.id)\r\n    if (conn) {\r\n      conn.state = 'idle'\r\n      conn.lastUsedAt = Date.now()\r\n      conn.useCount++\r\n\r\n      // 检查是否超过最大空闲连接数\r\n      this.trimIdleConnections(key)\r\n    }\r\n\r\n    // 通知等待的请求\r\n    this.notifyWaiters(key)\r\n  }\r\n\r\n  /**\r\n   * 创建新连接\r\n   */\r\n  private async createConnection(config: RequestConfig): Promise<ConnectionInfo> {\r\n    const url = new URL(config.url || '')\r\n    const connection: ConnectionInfo = {\r\n      id: this.generateId(),\r\n      host: url.hostname,\r\n      port: Number.parseInt(url.port) || (url.protocol === 'https:' ? 443 : 80),\r\n      protocol: url.protocol,\r\n      createdAt: Date.now(),\r\n      lastUsedAt: Date.now(),\r\n      useCount: 1,\r\n      state: 'active',\r\n    }\r\n\r\n    this.stats.totalRequests++\r\n\r\n    // 设置连接超时\r\n    if (this.config?.connectionTimeout > 0) {\r\n      setTimeout(() => {\r\n        if (connection.state === 'active') {\r\n          this.closeConnection(connection)\r\n        }\r\n      }, this.config?.connectionTimeout)\r\n    }\r\n\r\n    return connection\r\n  }\r\n\r\n  /**\r\n   * 等待可用连接（优化版 - 事件驱动）\r\n   */\r\n  private async waitForConnection(key: string, _config: RequestConfig): Promise<ConnectionInfo> {\r\n    return new Promise((resolve, reject) => {\r\n      const waitingRequest: WaitingRequest = {\r\n        resolve,\r\n        reject,\r\n        timestamp: Date.now(),\r\n      }\r\n\r\n      // 添加到等待队列\r\n      const queue = this.waitingQueues.get(key) || []\r\n      queue.push(waitingRequest)\r\n      this.waitingQueues.set(key, queue)\r\n\r\n      // 设置超时\r\n      const timeout = setTimeout(() => {\r\n        // 从队列中移除\r\n        const index = queue.indexOf(waitingRequest)\r\n        if (index !== -1) {\r\n          queue.splice(index, 1)\r\n        }\r\n        reject(new Error('Connection pool timeout'))\r\n      }, this.config?.connectionTimeout)\r\n\r\n      // 保存超时句柄以便清理\r\n      ;(waitingRequest as any).timeout = timeout\r\n    })\r\n  }\r\n\r\n  /**\r\n   * 标记连接为活跃\r\n   */\r\n  private markConnectionActive(connection: ConnectionInfo): void {\r\n    connection.state = 'active'\r\n    connection.lastUsedAt = Date.now()\r\n  }\r\n\r\n  /**\r\n   * 检查连接是否有效\r\n   */\r\n  private isConnectionValid(connection: ConnectionInfo): boolean {\r\n    const now = Date.now()\r\n\r\n    // 检查连接年龄\r\n    if (now - connection.createdAt > this.config?.maxConnectionAge) {\r\n      return false\r\n    }\r\n\r\n    // 检查空闲时间\r\n    if (connection.state === 'idle'\r\n      && now - connection.lastUsedAt > this.config?.idleTimeout) {\r\n      return false\r\n    }\r\n\r\n    return connection.state !== 'closed'\r\n  }\r\n\r\n  /**\r\n   * 关闭连接\r\n   */\r\n  private closeConnection(connection: ConnectionInfo): void {\r\n    connection.state = 'closed'\r\n\r\n    // 从连接池移除\r\n    const key = `${connection.protocol}//${connection.host}:${connection.port}`\r\n    const connections = this.connections.get(key)\r\n    if (connections) {\r\n      const index = connections.findIndex(c => c.id === connection.id)\r\n      if (index !== -1) {\r\n        connections.splice(index, 1)\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 修剪空闲连接\r\n   */\r\n  private trimIdleConnections(key: string): void {\r\n    const connections = this.connections.get(key)\r\n    if (!connections)\r\n      return\r\n\r\n    const idleConnections = connections.filter(c => c.state === 'idle')\r\n\r\n    if (idleConnections.length > this.config?.maxIdleConnections) {\r\n      // 按最后使用时间排序，关闭最旧的连接\r\n      idleConnections.sort((a, b) => a.lastUsedAt - b.lastUsedAt)\r\n\r\n      const toClose = idleConnections.slice(0, idleConnections.length - this.config?.maxIdleConnections,\r\n      )\r\n\r\n      for (const conn of toClose) {\r\n        this.closeConnection(conn)\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 通知等待者（优化版 - 事件驱动）\r\n   */\r\n  private notifyWaiters(key: string): void {\r\n    const queue = this.waitingQueues.get(key)\r\n    if (!queue || queue.length === 0) {\r\n      return\r\n    }\r\n\r\n    const connections = this.connections.get(key) || []\r\n    const idleConnection = connections.find(conn =>\r\n      conn.state === 'idle' && this.isConnectionValid(conn),\r\n    )\r\n\r\n    if (idleConnection) {\r\n      // 取出第一个等待的请求\r\n      const waitingRequest = queue.shift()\r\n      if (waitingRequest) {\r\n        // 清除超时\r\n        const timeout = (waitingRequest as any).timeout\r\n        if (timeout) {\r\n          clearTimeout(timeout)\r\n        }\r\n\r\n        // 标记连接为活跃并返回\r\n        this.markConnectionActive(idleConnection)\r\n        waitingRequest.resolve(idleConnection)\r\n\r\n        // 如果还有等待的请求，继续通知\r\n        if (queue.length > 0) {\r\n          this.notifyWaiters(key)\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 获取连接键值\r\n   */\r\n  private getConnectionKey(config: RequestConfig): string {\r\n    const url = new URL(config.url || '')\r\n    return `${url.protocol}//${url.hostname}:${url.port || (url.protocol === 'https:' ? 443 : 80)}`\r\n  }\r\n\r\n  /**\r\n   * 启动定期清理\r\n   */\r\n  private startCleanup(): void {\r\n    this.cleanupTimer = setInterval(() => {\r\n      for (const [key, connections] of this.connections.entries()) {\r\n        // 清理无效连接\r\n        const validConnections = connections.filter((conn) => {\r\n          if (!this.isConnectionValid(conn)) {\r\n            this.closeConnection(conn)\r\n            return false\r\n          }\r\n          return true\r\n        })\r\n\r\n        if (validConnections.length === 0) {\r\n          this.connections.delete(key)\r\n        }\r\n        else {\r\n          this.connections.set(key, validConnections)\r\n        }\r\n      }\r\n    }, 10000) // 每10秒清理一次\r\n  }\r\n\r\n  /**\r\n   * 获取统计信息\r\n   */\r\n  getStats(): PoolStats {\r\n    let totalConnections = 0\r\n    let activeConnections = 0\r\n    let idleConnections = 0\r\n\r\n    for (const connections of this.connections.values()) {\r\n      totalConnections += connections.length\r\n      activeConnections += connections.filter(c => c.state === 'active').length\r\n      idleConnections += connections.filter(c => c.state === 'idle').length\r\n    }\r\n\r\n    const avgRequestsPerConnection = totalConnections > 0\r\n      ? this.stats.totalRequests / totalConnections\r\n      : 0\r\n\r\n    return {\r\n      totalConnections,\r\n      activeConnections,\r\n      idleConnections,\r\n      totalRequests: this.stats.totalRequests,\r\n      connectionReuse: this.stats.connectionReuse,\r\n      averageRequestsPerConnection: avgRequestsPerConnection,\r\n      connectionErrors: this.stats.connectionErrors,\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 获取连接详情\r\n   */\r\n  getConnectionDetails(): Map<string, ConnectionInfo[]> {\r\n    return new Map(this.connections)\r\n  }\r\n\r\n  /**\r\n   * 关闭所有连接\r\n   */\r\n  closeAll(): void {\r\n    for (const connections of this.connections.values()) {\r\n      for (const conn of connections) {\r\n        this.closeConnection(conn)\r\n      }\r\n    }\r\n    this.connections.clear()\r\n  }\r\n\r\n  /**\r\n   * 生成唯一ID\r\n   */\r\n  private generateId(): string {\r\n    return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`\r\n  }\r\n\r\n  /**\r\n   * 销毁连接池\r\n   */\r\n  destroy(): void {\r\n    if (this.cleanupTimer) {\r\n      clearInterval(this.cleanupTimer)\r\n    }\r\n    this.closeAll()\r\n  }\r\n}\r\n\r\n/**\r\n * 创建请求池\r\n */\r\nexport function createRequestPool(config?: PoolConfig): RequestPool {\r\n  return new RequestPool(config)\r\n}\r\n\r\n/**\r\n * 默认连接池实例\r\n */\r\nexport const defaultPool = createRequestPool()\r\n"],"names":["RequestPool","constructor","config","this","connections","Map","stats","totalRequests","connectionReuse","connectionErrors","waitingQueues","maxConnections","maxIdleConnections","maxConnectionAge","idleTimeout","connectionTimeout","keepAlive","keepAliveTimeout","pipelining","maxPipelineLength","startCleanup","getConnection","key","getConnectionKey","get","len","length","i","conn","state","isConnectionValid","markConnectionActive","connectionList","activeCount","waitForConnection","newConnection","createConnection","push","set","releaseConnection","connection","protocol","host","port","find","c","id","lastUsedAt","Date","now","useCount","trimIdleConnections","notifyWaiters","url","URL","generateId","hostname","Number","parseInt","createdAt","setTimeout","closeConnection","_config","Promise","resolve","reject","waitingRequest","timestamp","queue","timeout","index","indexOf","splice","Error","findIndex","idleConnections","filter","sort","a","b","toClose","slice","idleConnection","shift","clearTimeout","cleanupTimer","setInterval","entries","validConnections","delete","getStats","totalConnections","activeConnections","values","avgRequestsPerConnection","averageRequestsPerConnection","getConnectionDetails","closeAll","clear","Math","random","toString","substr","destroy","clearInterval","createRequestPool","defaultPool","u","f","d"],"mappings":"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"}