import{DeduplicationManager as e}from"./dedup-manager.js";import{createDeduplicationManager as t}from"./dedup-manager.js";import{DeduplicationKeyGenerator as i}from"./request-dedup.js";import{createDeduplicationKeyGenerator as a}from"./request-dedup.js";import{RateLimitManager as n,createRateLimitManager as r}from"./rate-limit.js";class s{constructor(t={}){this.activeRequests=new Set,this.requestQueue=[],this.requestCounter=0,this.processingQueue=!1,this.config={maxConcurrent:t.maxConcurrent??10,maxQueueSize:t.maxQueueSize??100,deduplication:t.deduplication??!0},this.deduplicationManager=new e,this.keyGenerator=new i({includeMethod:!0,includeUrl:!0,includeParams:!0,includeData:!1})}async execute(e,t){if(this.config?.deduplication){const i=this.keyGenerator.generate(t);return this.deduplicationManager.execute(i,()=>this.executeWithConcurrencyControl(e,t))}return this.executeWithConcurrencyControl(e,t)}async executeWithConcurrencyControl(e,t){return new Promise((i,a)=>{const n={id:this.generateTaskId(),execute:e,resolve:i,reject:a,config:t};this.requestQueue.length>=this.config?.maxQueueSize?a(new Error("Request queue is full")):this.activeRequests.size<this.config?.maxConcurrent?this.executeTask(n):this.requestQueue.push(n)})}async executeTask(e){this.activeRequests.add(e.id);try{const t=await e.execute();e.resolve(t)}catch(t){e.reject(t)}finally{this.activeRequests.delete(e.id),this.processQueue()}}processQueue(){if(!this.processingQueue){this.processingQueue=!0;try{for(;this.requestQueue.length>0&&this.activeRequests.size<this.config?.maxConcurrent;){const e=this.requestQueue.shift();e&&this.executeTask(e)}}finally{this.processingQueue=!1}}}cancelQueue(e="Queue cancelled"){this.requestQueue.splice(0).forEach(t=>{t.reject(new Error(e))})}getStatus(){return{activeCount:this.activeRequests.size,queuedCount:this.requestQueue.length,maxConcurrent:this.config?.maxConcurrent,maxQueueSize:this.config?.maxQueueSize,deduplication:this.deduplicationManager.getStats()}}updateConfig(e){Object.assign(this.config,e),this.processQueue()}getConfig(){return{...this.config}}getDeduplicationStats(){return this.deduplicationManager.getStats()}resetDeduplicationStats(){this.deduplicationManager.resetStats()}isRequestDeduplicating(e){const t=this.keyGenerator.generate(e);return this.deduplicationManager.isRunning(t)}cancelDeduplicatedRequest(e){const t=this.keyGenerator.generate(e);this.deduplicationManager.cancel(t)}async waitForDeduplicatedRequest(e){const t=this.keyGenerator.generate(e);return this.deduplicationManager.waitFor(t)}getDeduplicationTasksInfo(){return this.deduplicationManager.getAllTaskInfo()}cleanupTimeoutDeduplicationTasks(e=3e4){return this.deduplicationManager.cleanupTimeoutTasks(e)}configureDeduplicationKeyGenerator(e){this.keyGenerator=new i(e)}generateTaskId(){return`task_${++this.requestCounter}_${Date.now()}`}}function u(e){return new s(e)}export{s as ConcurrencyManager,i as DeduplicationKeyGenerator,e as DeduplicationManager,n as RateLimitManager,u as createConcurrencyManager,a as createDeduplicationKeyGenerator,t as createDeduplicationManager,r as createRateLimitManager};
//# sourceMappingURL=concurrency.js.map
