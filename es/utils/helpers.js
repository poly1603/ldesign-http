function t(t,e){let n=null;return function(...r){null!==n&&clearTimeout(n),n=setTimeout(()=>{t.apply(this,r),n=null},e)}}function e(t,e){let n,r=!1;return function(...o){return r||(r=!0,n=t.apply(this,o),setTimeout(()=>{r=!1},e)),n}}function n(t){const{maxBatchSize:e=100,delay:n=10,batchFn:r}=t,o=[];let i=null;async function u(){if(0===o.length)return;const t=o.splice(0,e),n=t.map(t=>t.input);try{const e=await r(n);t.forEach((t,n)=>{t.resolve(e[n])})}catch(e){t.forEach(t=>{t.reject(e)})}i=o.length>0?setTimeout(u,0):null}return function(t){return new Promise((r,c)=>{o.push({input:t,resolve:r,reject:c}),o.length>=e?(null!==i&&(clearTimeout(i),i=null),u()):null===i&&(i=setTimeout(u,n))})}}function r(t){let e,n=!1;return function(...r){return n||(n=!0,e=t.apply(this,r)),e}}function o(t,e){const n=new Map,r=function(...r){const o=e?e(...r):JSON.stringify(r);if(n.has(o))return n.get(o);const i=t.apply(this,r);return n.set(o,i),i};return r.cache=n,r.clear=()=>n.clear(),r}async function i(t,e={}){const{maxAttempts:n=3,delay:r=1e3,onRetry:o}=e;let i;for(let e=1;e<=n;e++)try{return await t()}catch(t){i=t instanceof Error?t:new Error(String(t)),e<n&&(o?.(e,i),await new Promise(t=>setTimeout(t,r*e)))}throw i||new Error("Unknown error")}function u(t){let e={...t};return{set(t,n){return e[t]=n,this},merge(t,n){return"object"==typeof e[t]&&"object"==typeof n&&(e[t]={...e[t],...n}),this},reset(){return e={...t},this},build:()=>({...e}),get current(){return e}}}function c(t,e,n){const r=e.split(".");let o=t;for(const t of r){if(null==o)return n;o=o[t]}return void 0!==o?o:n}function s(t,e,n){const r=e.split("."),o=r.pop();let i=t;for(const t of r)(!(t in i)||"object"!=typeof i[t])&&(i[t]={}),i=i[t];i[o]=n}function l(t){return Object.freeze(t),Object.values(t).forEach(t=>{"object"==typeof t&&null!==t&&!Object.isFrozen(t)&&l(t)}),t}function a(t){return new Promise(e=>setTimeout(e,t))}function f(t,e,n=new Error("Timeout")){let r;const o=new Promise((t,o)=>{r=setTimeout(()=>o(n),e)});return Promise.race([t,o]).finally(()=>{clearTimeout(r)})}async function p(t,e){const n=[],r=[];for(let o=0;o<t.length;o++){const i=(0,t[o])().then(t=>{n[o]=t});r.push(i),r.length>=e&&(await Promise.race(r),r.splice(r.findIndex(t=>t===i),1))}return await Promise.all(r),n}export{n as createBatchRequest,u as createChainBuilder,t as debounce,l as deepFreeze,c as get,o as memoize,r as once,p as parallelLimit,i as retry,s as set,a as sleep,e as throttle,f as timeout};
//# sourceMappingURL=helpers.js.map
