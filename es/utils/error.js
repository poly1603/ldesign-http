import{createHttpError as r,delay as t}from"./index.js";var e,s;(s=e||(e={})).NETWORK="NETWORK_ERROR",s.TIMEOUT="TIMEOUT_ERROR",s.CANCEL="CANCEL_ERROR",s.HTTP="HTTP_ERROR",s.PARSE="PARSE_ERROR",s.UNKNOWN="UNKNOWN_ERROR";class o{static createNetworkError(t,s){const o=r(this.ERROR_TEMPLATES[e.NETWORK],t,e.NETWORK);return o.isNetworkError=!0,o.cause=s,o}static createTimeoutError(t,s){const o="function"==typeof this.ERROR_TEMPLATES[e.TIMEOUT]?this.ERROR_TEMPLATES[e.TIMEOUT](s):`Timeout Error: Request timed out after ${s}ms`,a=r(o,t,e.TIMEOUT);return a.isTimeoutError=!0,a}static createCancelError(t){const s=r(this.ERROR_TEMPLATES[e.CANCEL],t,e.CANCEL);return s.isCancelError=!0,s}static createHttpError(t,s,o,a){return r(`HTTP Error: ${t} ${s}`,o,e.HTTP,a)}static createParseError(t,s){const o=r("Parse Error: Failed to parse response data",t,e.PARSE);return o.cause=s,o}static isRetryableError(r){if(r.isNetworkError||r.isTimeoutError)return!0;if(r.response?.status){const t=r.response.status;return t>=500||429===t||408===t}return!1}static getUserFriendlyMessage(r){if(r.isNetworkError)return"网络连接失败，请检查网络设置";if(r.isTimeoutError)return"请求超时，请稍后重试";if(r.isCancelError)return"请求已取消";if(r.response?.status){const t=r.response.status;switch(t){case 400:return"请求参数错误";case 401:return"未授权，请重新登录";case 403:return"权限不足";case 404:return"请求的资源不存在";case 429:return"请求过于频繁，请稍后重试";case 500:return"服务器内部错误";case 502:return"网关错误";case 503:return"服务暂时不可用";default:return`请求失败 (${t})`}}return r.message||"未知错误"}static recordError(r){const t=Date.now();this.errorStats.total++;const e=this.getErrorType(r);if(this.errorStats.byType[e]++,r.response?.status){const t=r.response.status;this.errorStats.byStatus[t]=(this.errorStats.byStatus[t]||0)+1}this.errorStats.recent.unshift(r),this.errorStats.recent.length>10&&(this.errorStats.recent=this.errorStats.recent.slice(0,10)),this.errorHistory.unshift({error:r,timestamp:t,recovered:!1}),this.errorHistory.length>100&&(this.errorHistory=this.errorHistory.slice(0,100)),this.updateErrorRate(),this.updateMostCommonError()}static async tryRecover(r){for(const t of this.recoveryStrategies)if(t.canHandle(r))try{if(await t.recover(r)){const t=this.errorHistory.find(t=>t.error===r);return t&&(t.recovered=!0),!0}}catch(r){}return!1}static addRecoveryStrategy(r){this.recoveryStrategies.push(r),this.recoveryStrategies.sort((r,t)=>(t.priority||0)-(r.priority||0))}static removeRecoveryStrategy(r){const t=this.recoveryStrategies.findIndex(t=>t.name===r);return t>-1&&(this.recoveryStrategies.splice(t,1),!0)}static getRecoveryStrategies(){return[...this.recoveryStrategies]}static getErrorType(r){return r.isNetworkError?e.NETWORK:r.isTimeoutError?e.TIMEOUT:r.isCancelError?e.CANCEL:r.response?e.HTTP:r.code===e.PARSE?e.PARSE:e.UNKNOWN}static updateErrorRate(){const r=Date.now()-36e5,t=this.errorHistory.filter(t=>t.timestamp>r);this.errorStats.errorRate=t.length}static updateMostCommonError(){let r=0,t=null;for(const[e,s]of Object.entries(this.errorStats.byType))s>r&&(r=s,t=e);this.errorStats.mostCommon=t?{type:t,count:r}:null}static getStats(){return{...this.errorStats}}static getErrorHistory(){return[...this.errorHistory]}static resetStats(){this.errorStats={total:0,byType:{[e.NETWORK]:0,[e.TIMEOUT]:0,[e.CANCEL]:0,[e.HTTP]:0,[e.PARSE]:0,[e.UNKNOWN]:0},byStatus:{},recent:[],errorRate:0,mostCommon:null},this.errorHistory=[]}static cleanupOldErrors(r=864e5){const t=Date.now()-r,e=this.errorHistory.length;return this.errorHistory=this.errorHistory.filter(r=>r.timestamp>t),e-this.errorHistory.length}}o.ERROR_TEMPLATES={[e.NETWORK]:"Network Error: Unable to connect to the server",[e.TIMEOUT]:r=>`Timeout Error: Request timed out after ${r}ms`,[e.CANCEL]:"Cancel Error: Request was cancelled",[e.HTTP]:(r,t)=>`HTTP Error ${r}: ${t}`,[e.PARSE]:"Parse Error: Failed to parse response data",[e.UNKNOWN]:"Unknown Error: An unexpected error occurred"},o.errorStats={total:0,byType:{[e.NETWORK]:0,[e.TIMEOUT]:0,[e.CANCEL]:0,[e.HTTP]:0,[e.PARSE]:0,[e.UNKNOWN]:0},byStatus:{},recent:[],errorRate:0,mostCommon:null},o.recoveryStrategies=[],o.errorHistory=[];class a{constructor(r={}){this.config={retries:r.retries??3,retryDelay:r.retryDelay??1e3,retryCondition:r.retryCondition??o.isRetryableError,retryDelayFunction:r.retryDelayFunction??this.defaultRetryDelayFunction}}async executeWithRetry(e,s){let o,a=0;for(;a<=this.config?.retries;)try{return await e()}catch(r){if(o=r,a>=this.config?.retries||!this.config?.retryCondition(o))throw o;const e=this.config?.retryDelayFunction(a,o);await t(e),a++}throw o||r("Retry failed",{url:""})}defaultRetryDelayFunction(r,t){const e=this.config?.retryDelay*2**r,s=.1*Math.random()*e;return Math.min(e+s,3e4)}updateConfig(r){Object.assign(this.config,r)}getConfig(){return{...this.config}}}class n{constructor(){this.timeouts=new Map}createTimeoutController(r,t){const e=new AbortController,s=t||this.generateId(),o=setTimeout(()=>{e.abort(),this.timeouts.delete(s)},r);return this.timeouts.set(s,o),{signal:e.signal,cleanup:()=>{const r=this.timeouts.get(s);r&&(clearTimeout(r),this.timeouts.delete(s))}}}clearAll(){this.timeouts.forEach(r=>{clearTimeout(r)}),this.timeouts.clear()}generateId(){return Math.random().toString(36).substring(2,15)}}const i={networkReconnect:{name:"network-reconnect",priority:10,canHandle:r=>r.isNetworkError,recover:async r=>{try{return(await fetch("/ping",{method:"HEAD",cache:"no-cache",signal:AbortSignal.timeout(5e3)})).ok}catch{return!1}}},authRefresh:{name:"auth-refresh",priority:20,canHandle:r=>401===r.response?.status,recover:async r=>{try{const r=localStorage.getItem("refreshToken");if(!r)return!1;const t=await fetch("/auth/refresh",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({refreshToken:r})});if(t.ok){const r=await t.json();return localStorage.setItem("accessToken",r.accessToken),localStorage.setItem("refreshToken",r.refreshToken),!0}}catch{localStorage.removeItem("accessToken"),localStorage.removeItem("refreshToken")}return!1}},serviceFallback:{name:"service-fallback",priority:5,canHandle:r=>{const t=r.response?.status;return 503===t||502===t||504===t},recover:async r=>{const t=r.config?.url?.replace("/api/","/api-fallback/");if(t&&t!==r.config?.url)try{return(await fetch(t,{method:"HEAD",signal:AbortSignal.timeout(3e3)})).ok}catch{return!1}return!1}},cacheFailback:{name:"cache-fallback",priority:1,canHandle:r=>"GET"===r.config?.method?.toUpperCase(),recover:async r=>{try{const t=`http_cache_${r.config?.url}`,e=localStorage.getItem(t);if(e){const r=JSON.parse(e);if(Date.now()-r.timestamp<864e5)return!0}}catch{}return!1}}};class c{static analyzeErrorPatterns(r){const t={},e=r.length;r.forEach(r=>{r.isNetworkError&&(t.network_errors=(t.network_errors||0)+1),r.isTimeoutError&&(t.timeout_errors=(t.timeout_errors||0)+1),401===r.response?.status&&(t.auth_errors=(t.auth_errors||0)+1),r.response?.status&&r.response.status>=500&&(t.server_errors=(t.server_errors||0)+1),r.response?.status&&r.response.status>=400&&r.response.status<500&&(t.client_errors=(t.client_errors||0)+1)});return{patterns:Object.entries(t).map(([r,t])=>({type:r,count:t,percentage:Math.round(t/e*100),description:this.getPatternDescription(r)})),recommendations:this.generateRecommendations(t,e)}}static getPatternDescription(r){return{network_errors:"网络连接问题，可能是网络不稳定或服务器不可达",timeout_errors:"请求超时，可能是网络延迟高或服务器响应慢",auth_errors:"认证失败，可能是令牌过期或权限不足",server_errors:"服务器内部错误，可能是服务器故障或过载",client_errors:"客户端请求错误，可能是参数错误或请求格式不正确"}[r]||"未知错误模式"}static generateRecommendations(r,t){const e=[];return r.network_errors&&r.network_errors/t>.3&&e.push("考虑添加网络重连机制和离线模式支持"),r.timeout_errors&&r.timeout_errors/t>.2&&e.push("考虑增加请求超时时间或优化服务器响应速度"),r.auth_errors&&r.auth_errors/t>.1&&e.push("考虑实现自动令牌刷新机制"),r.server_errors&&r.server_errors/t>.15&&e.push("考虑添加服务降级和熔断机制"),r.client_errors&&r.client_errors/t>.25&&e.push("考虑加强客户端参数验证和错误提示"),e}}export{c as ErrorAnalyzer,o as ErrorHandler,e as ErrorType,a as RetryManager,n as TimeoutManager,i as builtinRecoveryStrategies};
//# sourceMappingURL=error.js.map
