{"version":3,"file":"throttle-debounce.js","sources":["../../src/utils/throttle-debounce.ts"],"sourcesContent":["/**\n * 防抖节流工具模块\n * \n * 提供防抖、节流等控制函数执行频率的工具\n */\n\n/**\n * 防抖配置\n */\nexport interface DebounceOptions {\n  /** 是否在延迟开始前调用 */\n  leading?: boolean\n  /** 是否在延迟结束后调用 */\n  trailing?: boolean\n  /** 最大等待时间 */\n  maxWait?: number\n}\n\n/**\n * 防抖函数\n * \n * 在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时\n * \n * @param fn - 要防抖的函数\n * @param delay - 延迟时间（毫秒）\n * @param options - 防抖选项\n * @returns 防抖后的函数\n * \n * @example\n * ```typescript\n * const debouncedSearch = debounce((query: string) => {\n *   console.log('Searching:', query)\n * }, 300)\n * \n * // 只有最后一次调用会执行\n * debouncedSearch('a')\n * debouncedSearch('ab')\n * debouncedSearch('abc') // 300ms后执行\n * ```\n */\nexport function debounce<T extends (...args: any[]) => any>(\n  fn: T,\n  delay: number,\n  options: DebounceOptions = {},\n): T & {\n  cancel: () => void\n  flush: () => ReturnType<T> | undefined\n  pending: () => boolean\n} {\n  const { leading = false, trailing = true, maxWait } = options\n  \n  let timeoutId: ReturnType<typeof setTimeout> | null = null\n  let maxTimeoutId: ReturnType<typeof setTimeout> | null = null\n  let lastCallTime: number | null = null\n  let lastInvokeTime = 0\n  let lastArgs: Parameters<T> | null = null\n  let lastThis: any = null\n  let result: ReturnType<T> | undefined\n\n  function invokeFunc(time: number): ReturnType<T> {\n    const args = lastArgs!\n    const thisArg = lastThis\n\n    lastArgs = null\n    lastThis = null\n    lastInvokeTime = time\n    const r = fn.apply(thisArg, args) as ReturnType<T>\n    result = r\n    return r\n  }\n\n  function leadingEdge(time: number): void {\n    lastInvokeTime = time\n    timeoutId = setTimeout(timerExpired, delay)\n    \n    if (leading) {\n      result = invokeFunc(time)\n    }\n  }\n\n  function remainingWait(time: number): number {\n    const timeSinceLastCall = time - (lastCallTime ?? 0)\n    const timeSinceLastInvoke = time - lastInvokeTime\n    const timeWaiting = delay - timeSinceLastCall\n\n    return maxWait !== undefined\n      ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke)\n      : timeWaiting\n  }\n\n  function shouldInvoke(time: number): boolean {\n    const timeSinceLastCall = time - (lastCallTime ?? 0)\n    const timeSinceLastInvoke = time - lastInvokeTime\n\n    return lastCallTime === null ||\n      timeSinceLastCall >= delay ||\n      timeSinceLastCall < 0 ||\n      (maxWait !== undefined && timeSinceLastInvoke >= maxWait)\n  }\n\n  function timerExpired(): void {\n    const time = Date.now()\n    \n    if (shouldInvoke(time)) {\n      trailingEdge(time)\n    } else {\n      timeoutId = setTimeout(timerExpired, remainingWait(time))\n    }\n  }\n\n  function trailingEdge(time: number): void {\n    timeoutId = null\n\n    if (trailing && lastArgs) {\n      result = invokeFunc(time)\n    } else {\n      lastArgs = null\n      lastThis = null\n    }\n  }\n\n  function cancel(): void {\n    if (timeoutId !== null) {\n      clearTimeout(timeoutId)\n    }\n    if (maxTimeoutId !== null) {\n      clearTimeout(maxTimeoutId)\n    }\n    lastInvokeTime = 0\n    lastArgs = null\n    lastCallTime = null\n    lastThis = null\n    timeoutId = null\n    maxTimeoutId = null\n  }\n\n  function flush(): ReturnType<T> | undefined {\n    if (timeoutId === null) {\n      return result\n    }\n    \n    const time = Date.now()\n    trailingEdge(time)\n    return result\n  }\n\n  function pending(): boolean {\n    return timeoutId !== null\n  }\n\n  function debounced(...args: Parameters<T>): ReturnType<T> | undefined {\n    const time = Date.now()\n    const isInvoking = shouldInvoke(time)\n    const context = debounced\n\n    lastArgs = args\n    lastThis = context\n    lastCallTime = time\n\n    if (isInvoking) {\n      if (timeoutId === null) {\n        leadingEdge(lastCallTime)\n      }\n      if (maxWait !== undefined) {\n        if (maxTimeoutId !== null) {\n          clearTimeout(maxTimeoutId)\n        }\n        maxTimeoutId = setTimeout(timerExpired, maxWait)\n      }\n      return result\n    }\n    \n    if (timeoutId === null) {\n      timeoutId = setTimeout(timerExpired, delay)\n    }\n    \n    return result\n  }\n\n  const enhanced = debounced as T & {\n    cancel: () => void\n    flush: () => ReturnType<T> | undefined\n    pending: () => boolean\n  }\n\n  enhanced.cancel = cancel\n  enhanced.flush = flush\n  enhanced.pending = pending\n\n  return enhanced\n}\n\n/**\n * 节流配置\n */\nexport interface ThrottleOptions {\n  /** 是否在延迟开始前调用 */\n  leading?: boolean\n  /** 是否在延迟结束后调用 */\n  trailing?: boolean\n}\n\n/**\n * 节流函数\n * \n * 规定时间内只触发一次函数，适用于高频事件\n * \n * @param fn - 要节流的函数\n * @param limit - 时间间隔（毫秒）\n * @param options - 节流选项\n * @returns 节流后的函数\n * \n * @example\n * ```typescript\n * const throttledScroll = throttle(() => {\n *   console.log('Scrolling...')\n * }, 100)\n * \n * window.addEventListener('scroll', throttledScroll)\n * ```\n */\nexport function throttle<T extends (...args: any[]) => any>(\n  fn: T,\n  limit: number,\n  options: ThrottleOptions = {},\n): T & {\n  cancel: () => void\n  flush: () => ReturnType<T> | undefined\n  pending: () => boolean\n} {\n  const { leading = true, trailing = true } = options\n  \n  return debounce(fn, limit, {\n    leading,\n    trailing,\n    maxWait: limit,\n  })\n}\n\n/**\n * 创建自适应防抖\n * \n * 根据调用频率自动调整防抖延迟\n */\nexport function createAdaptiveDebounce<T extends (...args: any[]) => any>(\n  fn: T,\n  options: {\n    minDelay?: number\n    maxDelay?: number\n    factor?: number\n  } = {},\n): T & { cancel: () => void, reset: () => void } {\n  const { minDelay = 100, maxDelay = 1000, factor = 1.5 } = options\n  \n  let currentDelay = minDelay\n  let lastCallTime = 0\n  let timeoutId: ReturnType<typeof setTimeout> | null = null\n  let callCount = 0\n\n  function adaptDelay(): void {\n    const now = Date.now()\n    const timeSinceLastCall = now - lastCallTime\n    \n    if (timeSinceLastCall < currentDelay * 2) {\n      // 频率增加，增加延迟\n      currentDelay = Math.min(currentDelay * factor, maxDelay)\n      callCount++\n    } else if (callCount > 0) {\n      // 频率降低，减少延迟\n      currentDelay = Math.max(currentDelay / factor, minDelay)\n      callCount = Math.max(0, callCount - 1)\n    }\n    \n    lastCallTime = now\n  }\n\n  function cancel(): void {\n    if (timeoutId !== null) {\n      clearTimeout(timeoutId)\n      timeoutId = null\n    }\n  }\n\n  function reset(): void {\n    cancel()\n    currentDelay = minDelay\n    lastCallTime = 0\n    callCount = 0\n  }\n\n  function debounced(this: any, ...args: Parameters<T>): void {\n    adaptDelay()\n    cancel()\n    \n    timeoutId = setTimeout(() => {\n      fn.apply(this, args)\n      timeoutId = null\n    }, currentDelay)\n  }\n\n  const enhanced = debounced as T & {\n    cancel: () => void\n    reset: () => void\n  }\n\n  enhanced.cancel = cancel\n  enhanced.reset = reset\n\n  return enhanced\n}\n\n/**\n * 创建频率限制器\n * \n * 限制函数在指定时间窗口内的调用次数\n */\nexport class RateLimiter {\n  private calls: number[] = []\n\n  constructor(\n    private maxCalls: number,\n    private timeWindow: number,\n  ) {}\n\n  /**\n   * 检查是否可以执行\n   */\n  canExecute(): boolean {\n    this.cleanup()\n    return this.calls.length < this.maxCalls\n  }\n\n  /**\n   * 记录一次执行\n   */\n  recordExecution(): void {\n    this.calls.push(Date.now())\n  }\n\n  /**\n   * 执行函数（如果未超限）\n   */\n  execute<T>(fn: () => T): T | undefined {\n    if (this.canExecute()) {\n      this.recordExecution()\n      return fn()\n    }\n    return undefined\n  }\n\n  /**\n   * 获取下次可执行时间\n   */\n  getNextAvailableTime(): number | null {\n    this.cleanup()\n    \n    if (this.calls.length < this.maxCalls) {\n      return Date.now()\n    }\n    \n    const oldestCall = this.calls[0]\n    return oldestCall ? oldestCall + this.timeWindow : null\n  }\n\n  /**\n   * 清理过期的调用记录\n   */\n  private cleanup(): void {\n    const now = Date.now()\n    this.calls = this.calls.filter(time => now - time < this.timeWindow)\n  }\n\n  /**\n   * 重置限制器\n   */\n  reset(): void {\n    this.calls = []\n  }\n\n  /**\n   * 获取当前调用次数\n   */\n  getCurrentCalls(): number {\n    this.cleanup()\n    return this.calls.length\n  }\n\n  /**\n   * 获取剩余可调用次数\n   */\n  getRemainingCalls(): number {\n    this.cleanup()\n    return Math.max(0, this.maxCalls - this.calls.length)\n  }\n}\n\n/**\n * 创建带频率限制的函数\n */\nexport function createRateLimitedFunction<T extends (...args: any[]) => any>(\n  fn: T,\n  maxCalls: number,\n  timeWindow: number,\n  options: {\n    onLimit?: () => void\n    queueOverflow?: 'drop' | 'replace'\n  } = {},\n): T & { \n  limiter: RateLimiter\n  queue: Array<() => void>\n} {\n  const limiter = new RateLimiter(maxCalls, timeWindow)\n  const queue: Array<() => void> = []\n  const { onLimit, queueOverflow = 'drop' } = options\n\n  function processQueue(): void {\n    while (queue.length > 0 && limiter.canExecute()) {\n      const task = queue.shift()\n      if (task) {\n        limiter.recordExecution()\n        task()\n      }\n    }\n    \n    if (queue.length > 0) {\n      const nextTime = limiter.getNextAvailableTime()\n      if (nextTime) {\n        const delay = Math.max(0, nextTime - Date.now())\n        setTimeout(processQueue, delay)\n      }\n    }\n  }\n\n  function limited(this: any, ...args: Parameters<T>): void {\n    const task = () => fn.apply(this, args)\n\n    if (limiter.canExecute()) {\n      limiter.recordExecution()\n      task()\n    } else {\n      onLimit?.()\n      \n      if (queueOverflow === 'replace' && queue.length >= maxCalls) {\n        queue.shift()\n      }\n      \n      if (queueOverflow !== 'drop' || queue.length < maxCalls) {\n        queue.push(task)\n        processQueue()\n      }\n    }\n  }\n\n  const enhanced = limited as T & {\n    limiter: RateLimiter\n    queue: Array<() => void>\n  }\n\n  enhanced.limiter = limiter\n  enhanced.queue = queue\n\n  return enhanced\n}"],"names":["debounce","fn","delay","options","leading","trailing","maxWait","result","timeoutId","maxTimeoutId","lastCallTime","lastInvokeTime","lastArgs","lastThis","invokeFunc","time","args","thisArg","r","apply","shouldInvoke","timeSinceLastCall","timerExpired","Date","now","trailingEdge","setTimeout","timeSinceLastInvoke","timeWaiting","Math","min","remainingWait","enhanced","debounced","isInvoking","leadingEdge","clearTimeout","cancel","flush","pending","throttle","limit","createAdaptiveDebounce","minDelay","maxDelay","factor","currentDelay","callCount","max","adaptDelay","this","reset","RateLimiter","constructor","maxCalls","timeWindow","calls","canExecute","cleanup","length","recordExecution","push","execute","getNextAvailableTime","oldestCall","filter","getCurrentCalls","getRemainingCalls","createRateLimitedFunction","limiter","queue","onLimit","queueOverflow","processQueue","task","shift","nextTime","W","q","N","M","R"],"mappings":"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"}