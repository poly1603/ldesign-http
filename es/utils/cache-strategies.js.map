{"version":3,"file":"cache-strategies.js","sources":["../../src/utils/cache-strategies.ts"],"sourcesContent":["/**\r\n * 缓存策略模块\r\n * \r\n * 提供各种缓存策略和统计功能\r\n */\r\n\r\nimport type { RequestConfig, ResponseData } from '../types'\r\n\r\n/**\r\n * 缓存统计信息\r\n */\r\nexport interface CacheStats {\r\n  /** 命中次数 */\r\n  hits: number\r\n  /** 未命中次数 */\r\n  misses: number\r\n  /** 命中率 */\r\n  hitRate: number\r\n  /** 缓存大小 */\r\n  size: number\r\n  /** 总内存使用量（字节） */\r\n  memoryUsage: number\r\n  /** 最近访问的键 */\r\n  recentKeys: string[]\r\n  /** 最热门的键 */\r\n  hotKeys: Array<{ key: string; accessCount: number }>\r\n}\r\n\r\n/**\r\n * 缓存策略接口\r\n */\r\nexport interface CacheStrategy {\r\n  /** 策略名称 */\r\n  name: string\r\n  /** 是否应该缓存该响应 */\r\n  shouldCache: (config: RequestConfig, response: ResponseData) => boolean\r\n  /** 获取缓存TTL */\r\n  getTTL: (config: RequestConfig, response: ResponseData) => number\r\n  /** 生成缓存键 */\r\n  generateKey: (config: RequestConfig) => string\r\n}\r\n\r\n/**\r\n * LRU缓存策略\r\n */\r\nexport class LRUCacheStrategy implements CacheStrategy {\r\n  name = 'lru'\r\n  private maxSize: number\r\n  private accessOrder = new Map<string, number>()\r\n  private counter = 0\r\n\r\n  constructor(maxSize = 100) {\r\n    this.maxSize = maxSize\r\n  }\r\n\r\n  shouldCache(config: RequestConfig, response: ResponseData): boolean {\r\n    // 只缓存成功的GET请求\r\n    return config.method === 'GET' && response.status >= 200 && response.status < 300\r\n  }\r\n\r\n  getTTL(_config: RequestConfig, response: ResponseData): number {\r\n    // 根据响应头决定TTL\r\n    const cacheControl = response.headers?.['cache-control']\r\n    if (cacheControl) {\r\n      const maxAge = this.parseMaxAge(cacheControl)\r\n      if (maxAge) {\r\n        return maxAge * 1000\r\n      }\r\n    }\r\n    // 默认5分钟\r\n    return 5 * 60 * 1000\r\n  }\r\n\r\n  generateKey(config: RequestConfig): string {\r\n    const { method = 'GET', url = '', params = {} } = config\r\n    const paramStr = Object.keys(params).sort()\r\n      .map(k => `${k}=${params[k]}`)\r\n      .join('&')\r\n    return `${method}:${url}${paramStr ? `?${paramStr}` : ''}`\r\n  }\r\n\r\n  /**\r\n   * 记录访问顺序\r\n   */\r\n  recordAccess(key: string): void {\r\n    this.accessOrder.set(key, this.counter++)\r\n    // 超过容量则淘汰最久未使用项\r\n    if (this.accessOrder.size > this.maxSize) {\r\n      this.evict()\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 获取最近最少使用的键\r\n   */\r\n  getLRUKey(): string | null {\r\n    if (this.accessOrder.size === 0) return null\r\n    \r\n    let lruKey = ''\r\n    let minCount = Number.MAX_SAFE_INTEGER\r\n    \r\n    for (const [key, count] of this.accessOrder) {\r\n      if (count < minCount) {\r\n        minCount = count\r\n        lruKey = key\r\n      }\r\n    }\r\n    \r\n    return lruKey\r\n  }\r\n\r\n  /**\r\n   * 淘汰LRU项\r\n   */\r\n  evict(): string | null {\r\n    const lruKey = this.getLRUKey()\r\n    if (lruKey) {\r\n      this.accessOrder.delete(lruKey)\r\n    }\r\n    return lruKey\r\n  }\r\n\r\n  private parseMaxAge(cacheControl: string): number | null {\r\n    const match = cacheControl.match(/max-age=(\\d+)/)\r\n    return match ? Number.parseInt(match[1], 10) : null\r\n  }\r\n}\r\n\r\n/**\r\n * LFU缓存策略\r\n */\r\nexport class LFUCacheStrategy implements CacheStrategy {\r\n  name = 'lfu'\r\n  private frequency = new Map<string, number>()\r\n  private maxSize: number\r\n\r\n  constructor(maxSize = 100) {\r\n    this.maxSize = maxSize\r\n  }\r\n\r\n  shouldCache(config: RequestConfig, response: ResponseData): boolean {\r\n    return config.method === 'GET' && response.status >= 200 && response.status < 300\r\n  }\r\n\r\n  getTTL(_config: RequestConfig, _response: ResponseData): number {\r\n    return 10 * 60 * 1000 // 10分钟\r\n  }\r\n\r\n  generateKey(config: RequestConfig): string {\r\n    const { method = 'GET', url = '', params = {} } = config\r\n    const paramStr = JSON.stringify(params)\r\n    return `${method}:${url}:${paramStr}`\r\n  }\r\n\r\n  /**\r\n   * 记录访问频率\r\n   */\r\n  recordAccess(key: string): void {\r\n    const count = this.frequency.get(key) || 0\r\n    this.frequency.set(key, count + 1)\r\n    // 超过容量则淘汰最少使用项\r\n    if (this.frequency.size > this.maxSize) {\r\n      this.evict()\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 获取最少使用的键\r\n   */\r\n  getLFUKey(): string | null {\r\n    if (this.frequency.size === 0) return null\r\n    \r\n    let lfuKey = ''\r\n    let minFreq = Number.MAX_SAFE_INTEGER\r\n    \r\n    for (const [key, freq] of this.frequency) {\r\n      if (freq < minFreq) {\r\n        minFreq = freq\r\n        lfuKey = key\r\n      }\r\n    }\r\n    \r\n    return lfuKey\r\n  }\r\n\r\n  /**\r\n   * 淘汰LFU项\r\n   */\r\n  evict(): string | null {\r\n    const lfuKey = this.getLFUKey()\r\n    if (lfuKey) {\r\n      this.frequency.delete(lfuKey)\r\n    }\r\n    return lfuKey\r\n  }\r\n}\r\n\r\n/**\r\n * TTL缓存策略\r\n */\r\nexport class TTLCacheStrategy implements CacheStrategy {\r\n  name = 'ttl'\r\n  private defaultTTL: number\r\n\r\n  constructor(defaultTTL = 5 * 60 * 1000) {\r\n    this.defaultTTL = defaultTTL\r\n  }\r\n\r\n  shouldCache(_config: RequestConfig, response: ResponseData): boolean {\r\n    // 不缓存错误响应\r\n    return response.status >= 200 && response.status < 400\r\n  }\r\n\r\n  getTTL(config: RequestConfig, response: ResponseData): number {\r\n    // 优先使用配置中的TTL\r\n    const ttl = (config as any)?.cache?.ttl as number | undefined\r\n    if (ttl) {\r\n      return ttl\r\n    }\r\n\r\n    // 然后使用响应头中的缓存控制\r\n    const cacheControl = response.headers?.['cache-control']\r\n    if (cacheControl) {\r\n      if (cacheControl.includes('no-cache') || cacheControl.includes('no-store')) {\r\n        return 0\r\n      }\r\n      const maxAge = this.parseMaxAge(cacheControl)\r\n      if (maxAge) {\r\n        return maxAge * 1000\r\n      }\r\n    }\r\n\r\n    // 使用默认TTL\r\n    return this.defaultTTL\r\n  }\r\n\r\n  generateKey(config: RequestConfig): string {\r\n    return `${config.method}:${config.url}:${Date.now()}`\r\n  }\r\n\r\n  private parseMaxAge(cacheControl: string): number | null {\r\n    const match = cacheControl.match(/max-age=(\\d+)/)\r\n    return match ? Number.parseInt(match[1], 10) : null\r\n  }\r\n}\r\n\r\n/**\r\n * 智能缓存策略（基于机器学习预测）\r\n */\r\nexport class SmartCacheStrategy implements CacheStrategy {\r\n  name = 'smart'\r\n  private accessHistory = new Map<string, number[]>()\r\n  private hitRates = new Map<string, number>()\r\n\r\n  shouldCache(config: RequestConfig, response: ResponseData): boolean {\r\n    // 基于历史命中率决定是否缓存\r\n    const key = this.generateKey(config)\r\n    const hitRate = this.hitRates.get(key) || 0\r\n\r\n    // 如果命中率高于30%，则缓存\r\n    if (hitRate > 0.3) {\r\n      return true\r\n    }\r\n\r\n    // 对于新请求，默认缓存GET请求\r\n    return config.method === 'GET' && response.status === 200\r\n  }\r\n\r\n  getTTL(config: RequestConfig, _response: ResponseData): number {\r\n    // 基于访问模式预测TTL\r\n    const key = this.generateKey(config)\r\n    const history = this.accessHistory.get(key) || []\r\n\r\n    if (history.length >= 2) {\r\n      // 计算平均访问间隔\r\n      const intervals: number[] = []\r\n      for (let i = 1; i < history.length; i++) {\r\n        intervals.push(history[i] - history[i - 1])\r\n      }\r\n      const avgInterval = intervals.reduce((a, b) => a + b, 0) / intervals.length\r\n\r\n      // TTL设置为平均间隔的2倍\r\n      return Math.min(avgInterval * 2, 30 * 60 * 1000) // 最长30分钟\r\n    }\r\n\r\n    // 默认5分钟\r\n    return 5 * 60 * 1000\r\n  }\r\n\r\n  generateKey(config: RequestConfig): string {\r\n    const { method = 'GET', url = '' } = config\r\n    // 忽略查询参数，只关注端点\r\n    const baseUrl = url.split('?')[0]\r\n    return `${method}:${baseUrl}`\r\n  }\r\n\r\n  /**\r\n   * 记录访问历史\r\n   */\r\n  recordAccess(key: string, hit: boolean): void {\r\n    // 更新访问历史\r\n    const history = this.accessHistory.get(key) || []\r\n    history.push(Date.now())\r\n    \r\n    // 只保留最近10次访问\r\n    if (history.length > 10) {\r\n      history.shift()\r\n    }\r\n    \r\n    this.accessHistory.set(key, history)\r\n\r\n    // 更新命中率\r\n    const currentRate = this.hitRates.get(key) || 0\r\n    const newRate = hit \r\n      ? currentRate * 0.9 + 0.1  // 命中时增加\r\n      : currentRate * 0.9         // 未命中时衰减\r\n    this.hitRates.set(key, newRate)\r\n  }\r\n}\r\n\r\n/**\r\n * 缓存统计收集器\r\n */\r\nexport class CacheStatsCollector {\r\n  private stats: CacheStats = {\r\n    hits: 0,\r\n    misses: 0,\r\n    hitRate: 0,\r\n    size: 0,\r\n    memoryUsage: 0,\r\n    recentKeys: [],\r\n    hotKeys: [],\r\n  }\r\n\r\n  private accessLog = new Map<string, number>()\r\n  private maxRecentKeys = 10\r\n  private maxHotKeys = 10\r\n\r\n  /**\r\n   * 记录缓存命中\r\n   */\r\n  recordHit(key: string): void {\r\n    this.stats.hits++\r\n    this.updateHitRate()\r\n    this.recordAccess(key)\r\n  }\r\n\r\n  /**\r\n   * 记录缓存未命中\r\n   */\r\n  recordMiss(key: string): void {\r\n    this.stats.misses++\r\n    this.updateHitRate()\r\n    this.updateRecentKeys(key)\r\n  }\r\n\r\n  /**\r\n   * 记录缓存访问\r\n   */\r\n  private recordAccess(key: string): void {\r\n    const count = this.accessLog.get(key) || 0\r\n    this.accessLog.set(key, count + 1)\r\n    \r\n    this.updateRecentKeys(key)\r\n    this.updateHotKeys()\r\n  }\r\n\r\n  /**\r\n   * 更新命中率\r\n   */\r\n  private updateHitRate(): void {\r\n    const total = this.stats.hits + this.stats.misses\r\n    this.stats.hitRate = total > 0 ? this.stats.hits / total : 0\r\n  }\r\n\r\n  /**\r\n   * 更新最近访问的键\r\n   */\r\n  private updateRecentKeys(key: string): void {\r\n    // 移除已存在的键\r\n    const index = this.stats.recentKeys.indexOf(key)\r\n    if (index > -1) {\r\n      this.stats.recentKeys.splice(index, 1)\r\n    }\r\n\r\n    // 添加到开头\r\n    this.stats.recentKeys.unshift(key)\r\n\r\n    // 限制数量\r\n    if (this.stats.recentKeys.length > this.maxRecentKeys) {\r\n      this.stats.recentKeys = this.stats.recentKeys.slice(0, this.maxRecentKeys)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 更新热门键\r\n   */\r\n  private updateHotKeys(): void {\r\n    this.stats.hotKeys = Array.from(this.accessLog.entries())\r\n      .map(([key, count]) => ({ key, accessCount: count }))\r\n      .sort((a, b) => b.accessCount - a.accessCount)\r\n      .slice(0, this.maxHotKeys)\r\n  }\r\n\r\n  /**\r\n   * 更新缓存大小\r\n   */\r\n  updateSize(size: number): void {\r\n    this.stats.size = size\r\n  }\r\n\r\n  /**\r\n   * 更新内存使用量\r\n   */\r\n  updateMemoryUsage(bytes: number): void {\r\n    this.stats.memoryUsage = bytes\r\n  }\r\n\r\n  /**\r\n   * 获取统计信息\r\n   */\r\n  getStats(): CacheStats {\r\n    return { ...this.stats }\r\n  }\r\n\r\n  /**\r\n   * 重置统计\r\n   */\r\n  reset(): void {\r\n    this.stats = {\r\n      hits: 0,\r\n      misses: 0,\r\n      hitRate: 0,\r\n      size: 0,\r\n      memoryUsage: 0,\r\n      recentKeys: [],\r\n      hotKeys: [],\r\n    }\r\n    this.accessLog.clear()\r\n  }\r\n}\r\n\r\n/**\r\n * 创建缓存策略\r\n */\r\nexport function createCacheStrategy(\r\n  type: 'lru' | 'lfu' | 'ttl' | 'smart' = 'lru',\r\n  options?: any\r\n): CacheStrategy {\r\n  switch (type) {\r\n    case 'lfu':\r\n      return new LFUCacheStrategy(options?.maxSize)\r\n    case 'ttl':\r\n      return new TTLCacheStrategy(options?.defaultTTL)\r\n    case 'smart':\r\n      return new SmartCacheStrategy()\r\n    case 'lru':\r\n    default:\r\n      return new LRUCacheStrategy(options?.maxSize)\r\n  }\r\n}"],"names":["LRUCacheStrategy","constructor","maxSize","this","name","accessOrder","Map","counter","shouldCache","config","response","method","status","getTTL","_config","cacheControl","headers","maxAge","parseMaxAge","generateKey","url","params","paramStr","Object","keys","sort","map","k","join","recordAccess","key","set","size","evict","getLRUKey","lruKey","minCount","Number","MAX_SAFE_INTEGER","count","delete","match","parseInt","LFUCacheStrategy","frequency","_response","JSON","stringify","get","getLFUKey","lfuKey","minFreq","freq","TTLCacheStrategy","defaultTTL","ttl","cache","includes","Date","now","SmartCacheStrategy","accessHistory","hitRates","history","length","intervals","i","push","avgInterval","reduce","a","b","Math","min","split","hit","shift","currentRate","newRate","CacheStatsCollector","stats","hits","misses","hitRate","memoryUsage","recentKeys","hotKeys","accessLog","maxRecentKeys","maxHotKeys","recordHit","updateHitRate","recordMiss","updateRecentKeys","updateHotKeys","total","index","indexOf","splice","unshift","slice","Array","from","entries","accessCount","updateSize","updateMemoryUsage","bytes","getStats","reset","clear","createCacheStrategy","type","options","m","o","h","y","u","d"],"mappings":"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"}