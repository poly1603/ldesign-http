function e(e){let t,n=!1;const r=function(...r){return n||(n=!0,t=e.apply(this,r)),t};return Object.defineProperty(r,"called",{get:()=>n}),r.clear=function(){n=!1,t=void 0},r}function t(e,t={}){const{maxSize:n=1/0,ttl:r,keyFn:i=(...e)=>JSON.stringify(e)}=t,u=new Map;function a(e){return!(!r||!e)&&Date.now()-e>r}const c=function(...t){const c=i(...t);if(u.has(c)){const e=u.get(c);if(!a(e.timestamp))return u.delete(c),u.set(c,e),e.value;u.delete(c)}const o=e.apply(this,t);if(u.size>=n){const e=u.keys().next().value;void 0!==e&&u.delete(e)}return u.set(c,{value:o,timestamp:r?Date.now():void 0}),o};return c.cache=u,c.clear=()=>u.clear(),c.delete=e=>u.delete(e),c.has=e=>{if(!u.has(e))return!1;return!a(u.get(e).timestamp)||(u.delete(e),!1)},c}async function n(e,t={}){const{maxAttempts:n=3,delay:r=1e3,factor:i=2,maxDelay:u=3e4,jitter:a=!0,retryCondition:c=()=>!0,onRetry:o}=t;let s,l=r;for(let t=1;t<=n;t++)try{return await e()}catch(e){if(s=e,!(t<n&&c(e)))break;if(o?.(t,e),a){const e=.75+.5*Math.random();l=Math.min(l*e,u)}await new Promise(e=>setTimeout(e,l)),l=Math.min(l*i,u)}throw s}function r(e,t={}){return function(...r){return n(()=>e.apply(this,r),t)}}function i(e){return new Promise(t=>setTimeout(t,e))}function u(e,t,n={}){const{message:r="Timeout",error:i=new Error(r),cancellable:u=!1}=n;let a,c=!1;const o=new Promise((e,n)=>{a=setTimeout(()=>{c||n(i)},t)}),s=Promise.race([e,o]).finally(()=>{clearTimeout(a)});return u&&(s.cancel=()=>{c=!0,clearTimeout(a)}),s}class a{constructor(e){this.maxConcurrency=e,this.running=0,this.queue=[]}async execute(e){for(;this.running>=this.maxConcurrency;)await new Promise(e=>{this.queue.push(e)});this.running++;try{return await e()}finally{this.running--;const e=this.queue.shift();e&&e()}}async executeAll(e){return Promise.all(e.map(e=>this.execute(e)))}getRunning(){return this.running}getQueueLength(){return this.queue.length}}async function c(e,t){return new a(t).executeAll(e)}function o(){let e=Promise.resolve();return function(t,...n){const r=e.then(()=>t(...n));return e=r.catch(()=>{}),r}}function s(e=10){const t=new a(e);return function(e){return t.executeAll(e)}}function l(e,t=0){return async function(...n){return await i(t),e(...n)}}function f(e,t,n){return function(...r){return e(...r)?t.apply(this,r):n?n.apply(this,r):void 0}}export{a as ConcurrencyController,c as concurrent,f as conditional,s as createParallelExecutor,r as createRetryableFunction,o as createSerialExecutor,l as defer,t as memoize,e as once,n as retry,i as sleep,u as timeout};
//# sourceMappingURL=function-utils.js.map
