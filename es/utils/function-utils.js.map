{"version":3,"file":"function-utils.js","sources":["../../src/utils/function-utils.ts"],"sourcesContent":["/**\r\n * 函数工具模块\r\n * \r\n * 提供内存化、重试、一次性函数等功能\r\n */\r\n\r\n/**\r\n * 创建一次性函数\r\n * \r\n * 确保函数只被执行一次，后续调用返回第一次的结果\r\n * \r\n * @param fn - 要执行的函数\r\n * @returns 只执行一次的函数\r\n * \r\n * @example\r\n * ```typescript\r\n * const initialize = once(() => {\r\n *   console.log('Initializing...')\r\n *   return { initialized: true }\r\n * })\r\n * \r\n * initialize() // 输出: \"Initializing...\"\r\n * initialize() // 不输出，返回缓存的结果\r\n * ```\r\n */\r\nexport function once<T extends (...args: any[]) => any>(\r\n  fn: T,\r\n): T & { \r\n  called: boolean\r\n  clear: () => void \r\n} {\r\n  let called = false\r\n  let result: ReturnType<T>\r\n\r\n  function onceFunc(this: any, ...args: Parameters<T>): ReturnType<T> {\r\n    if (!called) {\r\n      called = true\r\n      result = fn.apply(this, args)\r\n    }\r\n    return result\r\n  }\r\n\r\n  function clear(): void {\r\n    called = false\r\n    result = undefined as any\r\n  }\r\n\r\n  const enhanced = onceFunc as T & {\r\n    called: boolean\r\n    clear: () => void\r\n  }\r\n\r\n  Object.defineProperty(enhanced, 'called', {\r\n    get: () => called,\r\n  })\r\n\r\n  enhanced.clear = clear\r\n\r\n  return enhanced\r\n}\r\n\r\n/**\r\n * 内存化配置\r\n */\r\nexport interface MemoizeOptions {\r\n  /** 最大缓存数量 */\r\n  maxSize?: number\r\n  /** 缓存过期时间（毫秒） */\r\n  ttl?: number\r\n  /** 是否使用WeakMap（仅对象类型参数） */\r\n  weak?: boolean\r\n  /** 自定义键生成函数 */\r\n  keyFn?: (...args: any[]) => string\r\n  /** 自定义相等比较函数 */\r\n  equalFn?: (a: any, b: any) => boolean\r\n}\r\n\r\n/**\r\n * 内存化函数\r\n * \r\n * 缓存函数的执行结果，相同输入返回缓存值\r\n * \r\n * @param fn - 要内存化的函数\r\n * @param options - 内存化选项\r\n * @returns 内存化后的函数\r\n * \r\n * @example\r\n * ```typescript\r\n * const expensiveCalculation = memoize((a: number, b: number) => {\r\n *   console.log('Calculating...')\r\n *   return a * b\r\n * })\r\n * \r\n * expensiveCalculation(2, 3) // 输出: \"Calculating...\" 返回: 6\r\n * expensiveCalculation(2, 3) // 不输出，直接返回: 6\r\n * ```\r\n */\r\nexport function memoize<T extends (...args: any[]) => any>(\r\n  fn: T,\r\n  options: MemoizeOptions = {},\r\n): T & { \r\n  cache: Map<string, any>\r\n  clear: () => void\r\n  delete: (key: string) => boolean\r\n  has: (key: string) => boolean\r\n} {\r\n  const {\r\n    maxSize = Infinity,\r\n    ttl,\r\n    keyFn = (...args) => JSON.stringify(args),\r\n  } = options\r\n\r\n  const cache = new Map<string, { value: ReturnType<T>, timestamp?: number }>()\r\n\r\n  function isExpired(timestamp?: number): boolean {\r\n    if (!ttl || !timestamp) return false\r\n    return Date.now() - timestamp > ttl\r\n  }\r\n\r\n  function memoized(this: any, ...args: Parameters<T>): ReturnType<T> {\r\n    const key = keyFn(...args)\r\n\r\n    if (cache.has(key)) {\r\n      const cached = cache.get(key)!\r\n      if (!isExpired(cached.timestamp)) {\r\n        // 移到最前面（LRU）\r\n        cache.delete(key)\r\n        cache.set(key, cached)\r\n        return cached.value\r\n      } else {\r\n        cache.delete(key)\r\n      }\r\n    }\r\n\r\n    const result = fn.apply(this, args)\r\n    \r\n    // 限制缓存大小\r\n    if (cache.size >= maxSize) {\r\n      // 删除最旧的（第一个）\r\n      const firstKey = cache.keys().next().value as string | undefined\r\n      if (firstKey !== undefined) {\r\n        cache.delete(firstKey)\r\n      }\r\n    }\r\n\r\n    cache.set(key, {\r\n      value: result,\r\n      timestamp: ttl ? Date.now() : undefined,\r\n    })\r\n\r\n    return result\r\n  }\r\n\r\n  const enhanced = memoized as T & {\r\n    cache: Map<string, any>\r\n    clear: () => void\r\n    delete: (key: string) => boolean\r\n    has: (key: string) => boolean\r\n  }\r\n\r\n  enhanced.cache = cache as any\r\n  enhanced.clear = () => cache.clear()\r\n  enhanced.delete = (key: string) => cache.delete(key)\r\n  enhanced.has = (key: string) => {\r\n    if (!cache.has(key)) return false\r\n    const cached = cache.get(key)!\r\n    if (isExpired(cached.timestamp)) {\r\n      cache.delete(key)\r\n      return false\r\n    }\r\n    return true\r\n  }\r\n\r\n  return enhanced\r\n}\r\n\r\n/**\r\n * 重试配置\r\n */\r\nexport interface RetryOptions {\r\n  /** 最大重试次数 */\r\n  maxAttempts?: number\r\n  /** 初始延迟（毫秒） */\r\n  delay?: number\r\n  /** 延迟增长因子 */\r\n  factor?: number\r\n  /** 最大延迟（毫秒） */\r\n  maxDelay?: number\r\n  /** 抖动 */\r\n  jitter?: boolean\r\n  /** 重试条件 */\r\n  retryCondition?: (error: any) => boolean\r\n  /** 重试回调 */\r\n  onRetry?: (attempt: number, error: any) => void\r\n}\r\n\r\n/**\r\n * 重试函数\r\n * \r\n * 在失败时自动重试函数执行\r\n * \r\n * @param fn - 要执行的函数\r\n * @param options - 重试选项\r\n * @returns Promise\r\n * \r\n * @example\r\n * ```typescript\r\n * const result = await retry(\r\n *   () => fetch('/api/data'),\r\n *   { maxAttempts: 3, delay: 1000 }\r\n * )\r\n * ```\r\n */\r\nexport async function retry<T>(\r\n  fn: () => Promise<T>,\r\n  options: RetryOptions = {},\r\n): Promise<T> {\r\n  const {\r\n    maxAttempts = 3,\r\n    delay = 1000,\r\n    factor = 2,\r\n    maxDelay = 30000,\r\n    jitter = true,\r\n    retryCondition = () => true,\r\n    onRetry,\r\n  } = options\r\n\r\n  let lastError: any\r\n  let currentDelay = delay\r\n\r\n  for (let attempt = 1; attempt <= maxAttempts; attempt++) {\r\n    try {\r\n      return await fn()\r\n    } catch (error) {\r\n      lastError = error\r\n\r\n      if (attempt < maxAttempts && retryCondition(error)) {\r\n        onRetry?.(attempt, error)\r\n        \r\n        // 计算延迟\r\n        if (jitter) {\r\n          // 添加随机抖动（±25%）\r\n          const jitterFactor = 0.75 + Math.random() * 0.5\r\n          currentDelay = Math.min(currentDelay * jitterFactor, maxDelay)\r\n        }\r\n        \r\n        await new Promise(resolve => setTimeout(resolve, currentDelay))\r\n        \r\n        // 增加延迟\r\n        currentDelay = Math.min(currentDelay * factor, maxDelay)\r\n      } else {\r\n        break\r\n      }\r\n    }\r\n  }\r\n\r\n  throw lastError\r\n}\r\n\r\n/**\r\n * 创建可重试函数\r\n */\r\nexport function createRetryableFunction<T extends (...args: any[]) => Promise<any>>(\r\n  fn: T,\r\n  options: RetryOptions = {},\r\n): T {\r\n  function retryable(this: any, ...args: Parameters<T>): ReturnType<T> {\r\n    return retry(() => fn.apply(this, args), options) as ReturnType<T>\r\n  }\r\n\r\n  return retryable as unknown as T\r\n}\r\n\r\n/**\r\n * 延迟执行\r\n * \r\n * @param ms - 延迟时间（毫秒）\r\n * @returns Promise\r\n */\r\nexport function sleep(ms: number): Promise<void> {\r\n  return new Promise(resolve => setTimeout(resolve, ms))\r\n}\r\n\r\n/**\r\n * 超时配置\r\n */\r\nexport interface TimeoutOptions {\r\n  /** 超时错误信息 */\r\n  message?: string\r\n  /** 超时错误 */\r\n  error?: Error\r\n  /** 是否可取消 */\r\n  cancellable?: boolean\r\n}\r\n\r\n/**\r\n * 超时Promise包装器\r\n * \r\n * 为Promise添加超时限制\r\n * \r\n * @param promise - 原始Promise\r\n * @param ms - 超时时间（毫秒）\r\n * @param options - 超时选项\r\n * @returns 带超时的Promise\r\n * \r\n * @example\r\n * ```typescript\r\n * const result = await timeout(\r\n *   fetch('/api/data'),\r\n *   5000,\r\n *   { message: 'Request timeout' }\r\n * )\r\n * ```\r\n */\r\nexport function timeout<T>(\r\n  promise: Promise<T>,\r\n  ms: number,\r\n  options: TimeoutOptions = {},\r\n): Promise<T> & { cancel?: () => void } {\r\n  const {\r\n    message = 'Timeout',\r\n    error = new Error(message),\r\n    cancellable = false,\r\n  } = options\r\n\r\n  let timeoutId: ReturnType<typeof setTimeout>\r\n  let cancelled = false\r\n\r\n  const timeoutPromise = new Promise<never>((_, reject) => {\r\n    timeoutId = setTimeout(() => {\r\n      if (!cancelled) {\r\n        reject(error)\r\n      }\r\n    }, ms)\r\n  })\r\n\r\n  const result = Promise.race([\r\n    promise,\r\n    timeoutPromise,\r\n  ]).finally(() => {\r\n    clearTimeout(timeoutId)\r\n  }) as Promise<T> & { cancel?: () => void }\r\n\r\n  if (cancellable) {\r\n    result.cancel = () => {\r\n      cancelled = true\r\n      clearTimeout(timeoutId)\r\n    }\r\n  }\r\n\r\n  return result\r\n}\r\n\r\n/**\r\n * 并发控制器\r\n */\r\nexport class ConcurrencyController {\r\n  private running = 0\r\n  private queue: Array<() => void> = []\r\n\r\n  constructor(private maxConcurrency: number) {}\r\n\r\n  /**\r\n   * 执行任务\r\n   */\r\n  async execute<T>(fn: () => Promise<T>): Promise<T> {\r\n    while (this.running >= this.maxConcurrency) {\r\n      await new Promise<void>(resolve => {\r\n        this.queue.push(resolve)\r\n      })\r\n    }\r\n\r\n    this.running++\r\n    \r\n    try {\r\n      return await fn()\r\n    } finally {\r\n      this.running--\r\n      const next = this.queue.shift()\r\n      if (next) {\r\n        next()\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 并发执行多个任务\r\n   */\r\n  async executeAll<T>(\r\n    tasks: Array<() => Promise<T>>,\r\n  ): Promise<T[]> {\r\n    return Promise.all(\r\n      tasks.map(task => this.execute(task)),\r\n    )\r\n  }\r\n\r\n  /**\r\n   * 获取当前运行数量\r\n   */\r\n  getRunning(): number {\r\n    return this.running\r\n  }\r\n\r\n  /**\r\n   * 获取队列长度\r\n   */\r\n  getQueueLength(): number {\r\n    return this.queue.length\r\n  }\r\n}\r\n\r\n/**\r\n * 并发执行\r\n * \r\n * 限制并发执行的任务数量\r\n * \r\n * @param tasks - 任务列表\r\n * @param limit - 并发限制\r\n * @returns 结果数组\r\n * \r\n * @example\r\n * ```typescript\r\n * const results = await concurrent(\r\n *   urls.map(url => () => fetch(url)),\r\n *   3 // 最多3个并发请求\r\n * )\r\n * ```\r\n */\r\nexport async function concurrent<T>(\r\n  tasks: Array<() => Promise<T>>,\r\n  limit: number,\r\n): Promise<T[]> {\r\n  const controller = new ConcurrencyController(limit)\r\n  return controller.executeAll(tasks)\r\n}\r\n\r\n/**\r\n * 创建串行执行器\r\n * \r\n * 确保异步函数按顺序执行\r\n */\r\nexport function createSerialExecutor<T extends (...args: any[]) => Promise<any>>(): \r\n  (fn: T, ...args: Parameters<T>) => ReturnType<T> {\r\n  let queue = Promise.resolve()\r\n\r\n  return function execute(fn: T, ...args: Parameters<T>): ReturnType<T> {\r\n    const result = queue.then(() => fn(...args))\r\n    queue = result.catch(() => {}) // 忽略错误，继续队列\r\n    return result as ReturnType<T>\r\n  }\r\n}\r\n\r\n/**\r\n * 创建并行执行器\r\n * \r\n * 批量并行执行函数\r\n */\r\nexport function createParallelExecutor(\r\n  maxConcurrency = 10,\r\n): <T>(tasks: Array<() => Promise<T>>) => Promise<T[]> {\r\n  const controller = new ConcurrencyController(maxConcurrency)\r\n  \r\n  return function execute<T>(tasks: Array<() => Promise<T>>): Promise<T[]> {\r\n    return controller.executeAll(tasks)\r\n  }\r\n}\r\n\r\n/**\r\n * 创建延迟执行器\r\n */\r\nexport function defer<T extends (...args: any[]) => any>(\r\n  fn: T,\r\n  delay = 0,\r\n): (...args: Parameters<T>) => Promise<ReturnType<T>> {\r\n  return async function(...args: Parameters<T>): Promise<ReturnType<T>> {\r\n    await sleep(delay)\r\n    return fn(...args)\r\n  }\r\n}\r\n\r\n/**\r\n * 创建条件执行器\r\n */\r\nexport function conditional<T extends (...args: any[]) => any>(\r\n  condition: (...args: Parameters<T>) => boolean,\r\n  trueFn: T,\r\n  falseFn?: T,\r\n): T {\r\n  return function(this: any, ...args: Parameters<T>): ReturnType<T> {\r\n    if (condition(...args)) {\r\n      return trueFn.apply(this, args)\r\n    } else if (falseFn) {\r\n      return falseFn.apply(this, args)\r\n    }\r\n    return undefined as any\r\n  } as T\r\n}"],"names":["once","fn","result","called","enhanced","args","apply","this","Object","defineProperty","get","clear","memoize","options","maxSize","ttl","keyFn","JSON","stringify","cache","Map","isExpired","timestamp","Date","now","key","has","cached","delete","set","value","size","firstKey","keys","next","async","retry","maxAttempts","delay","factor","maxDelay","jitter","retryCondition","onRetry","lastError","currentDelay","attempt","error","jitterFactor","Math","random","min","Promise","resolve","setTimeout","createRetryableFunction","sleep","ms","timeout","promise","message","Error","cancellable","timeoutId","cancelled","timeoutPromise","_","reject","race","finally","clearTimeout","cancel","ConcurrencyController","constructor","maxConcurrency","running","queue","execute","push","shift","executeAll","tasks","all","map","task","getRunning","getQueueLength","length","concurrent","limit","createSerialExecutor","then","catch","createParallelExecutor","controller","defer","conditional","condition","trueFn","falseFn","y","v","q","C","x","T","b","g","w","p","d","P"],"mappings":"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"}