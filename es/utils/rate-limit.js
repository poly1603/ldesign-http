class t{constructor(t={}){this.requests=[],this.config={maxRequests:t.maxRequests??100,timeWindow:t.timeWindow??6e4,allowBurst:t.allowBurst??!1,burstSize:t.burstSize??10},this.burstTokens=this.config.burstSize}canMakeRequest(){const t=Date.now();return this.requests=this.requests.filter(e=>t-e<this.config.timeWindow),!!(this.requests.length<this.config.maxRequests||this.config.allowBurst&&this.burstTokens>0)}recordRequest(){const t=Date.now();this.requests=this.requests.filter(e=>t-e<this.config.timeWindow),this.requests.length>=this.config.maxRequests&&this.config.allowBurst&&this.burstTokens>0&&this.burstTokens--,this.requests.push(t),this.scheduleBurstTokenRestore()}scheduleBurstTokenRestore(){this.config.allowBurst&&this.burstTokens<this.config.burstSize&&setTimeout(()=>{this.burstTokens=Math.min(this.burstTokens+1,this.config.burstSize)},1e3)}getNextAvailableTime(){return this.canMakeRequest()||0===this.requests.length?0:Math.min(...this.requests)+this.config.timeWindow-Date.now()}async waitForAvailability(){const t=this.getNextAvailableTime();t>0&&await new Promise(e=>setTimeout(e,t))}async waitWithBackoff(t=0){const e=this.getNextAvailableTime();if(e<=0)return;const s=Math.min(e*2**t,3e4);await new Promise(t=>setTimeout(t,s))}reset(){this.requests=[],this.burstTokens=this.config.burstSize}getStatus(){const t=Date.now();return this.requests=this.requests.filter(e=>t-e<this.config.timeWindow),{currentRequests:this.requests.length,maxRequests:this.config.maxRequests,timeWindow:this.config.timeWindow,nextAvailableTime:this.getNextAvailableTime(),isLimited:!this.canMakeRequest()}}updateConfig(t){Object.assign(this.config,t),void 0!==t.burstSize&&(this.burstTokens=Math.min(this.burstTokens,t.burstSize))}getRequestHistory(){const t=Date.now();return this.requests.filter(e=>t-e<this.config.timeWindow)}getCurrentRate(){const t=Date.now();return this.requests.filter(e=>t-e<1e3).length}predictAvailabilityForBatch(t){const e=this.requests.length,s=this.config.maxRequests-e;if(s>=t)return 0;const i=t-s;return i>this.requests.length?this.config.timeWindow:[...this.requests].sort()[i-1]+this.config.timeWindow-Date.now()}}function e(e){return new t(e)}function s(e){const s=new t(e);return function(t){return async(...e)=>(await s.waitForAvailability(),s.recordRequest(),t(...e))}}const i=new t;export{t as RateLimitManager,e as createRateLimitManager,i as globalRateLimitManager,s as rateLimit};
//# sourceMappingURL=rate-limit.js.map
