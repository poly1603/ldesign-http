{"version":3,"file":"dedup-manager.js","sources":["../../src/utils/dedup-manager.ts"],"sourcesContent":["/**\r\n * 请求去重管理器\r\n * \r\n * 防止相同请求重复发送，自动合并处理\r\n */\r\n\r\nimport type { ResponseData } from '../types'\r\n\r\n/**\r\n * 去重任务信息\r\n */\r\ninterface DeduplicationTask<T = unknown> {\r\n  /** 任务 Promise */\r\n  promise: Promise<ResponseData<T>>\r\n  /** 创建时间 */\r\n  createdAt: number\r\n  /** 引用计数 */\r\n  refCount: number\r\n  /** 任务键 */\r\n  key: string\r\n}\r\n\r\n/**\r\n * 去重统计信息\r\n */\r\nexport interface DeduplicationStats {\r\n  /** 执行的请求数 */\r\n  executions: number\r\n  /** 去重的请求数 */\r\n  duplications: number\r\n  /** 节省的请求数 */\r\n  savedRequests: number\r\n  /** 去重率 */\r\n  deduplicationRate: number\r\n  /** 当前待处理请求数 */\r\n  pendingCount: number\r\n}\r\n\r\n/**\r\n * 去重管理器配置\r\n */\r\nexport interface DeduplicationManagerConfig {\r\n  /** 最大待处理请求数 */\r\n  maxPendingRequests?: number\r\n  /** 清理间隔（毫秒） */\r\n  cleanupInterval?: number\r\n  /** 请求超时时间（毫秒） */\r\n  requestTimeout?: number\r\n  /** 是否启用自动清理 */\r\n  autoCleanup?: boolean\r\n}\r\n\r\n/**\r\n * 请求去重管理器\r\n * \r\n * 特性：\r\n * - 自动合并相同请求\r\n * - LRU 缓存策略\r\n * - 自动清理过期请求\r\n * - 统计信息跟踪\r\n */\r\nexport class DeduplicationManager {\r\n  private pendingRequests = new Map<string, DeduplicationTask>()\r\n  private stats = {\r\n    executions: 0,\r\n    duplications: 0,\r\n    savedRequests: 0,\r\n  }\r\n  private config: Required<DeduplicationManagerConfig>\r\n  private cleanupTimer?: ReturnType<typeof setTimeout>\r\n\r\n  constructor(config: DeduplicationManagerConfig = {}) {\r\n    this.config = {\r\n      maxPendingRequests: config.maxPendingRequests ?? 1000,\r\n      cleanupInterval: config.cleanupInterval ?? 30000,\r\n      requestTimeout: config.requestTimeout ?? 60000,\r\n      autoCleanup: config.autoCleanup ?? true,\r\n    }\r\n\r\n    if (this.config.autoCleanup) {\r\n      this.startAutoCleanup()\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 执行请求（带去重，性能优化）\r\n   */\r\n  async execute<T = unknown>(\r\n    key: string,\r\n    requestFn: () => Promise<ResponseData<T>>,\r\n  ): Promise<ResponseData<T>> {\r\n    // 检查是否有相同的请求正在进行（使用Map.has更快）\r\n    if (this.pendingRequests.has(key)) {\r\n      const existingTask = this.pendingRequests.get(key)!\r\n      // 增加引用计数\r\n      existingTask.refCount++\r\n      this.stats.duplications++\r\n      this.stats.savedRequests++\r\n\r\n      return existingTask.promise as Promise<ResponseData<T>>\r\n    }\r\n\r\n    // 检查是否达到最大待处理请求数\r\n    if (this.pendingRequests.size >= this.config.maxPendingRequests) {\r\n      this.cleanupOldestRequest()\r\n    }\r\n\r\n    // 创建新的请求\r\n    const requestPromise = requestFn().finally(() => {\r\n      // 请求完成后清理\r\n      this.pendingRequests.delete(key)\r\n    })\r\n\r\n    const task: DeduplicationTask<T> = {\r\n      promise: requestPromise,\r\n      createdAt: Date.now(),\r\n      refCount: 1,\r\n      key,\r\n    }\r\n\r\n    this.pendingRequests.set(key, task)\r\n    this.stats.executions++\r\n\r\n    return requestPromise\r\n  }\r\n\r\n  /**\r\n   * 启动自动清理\r\n   */\r\n  private startAutoCleanup(): void {\r\n    this.cleanupTimer = setInterval(() => {\r\n      this.cleanupTimeoutTasks(this.config.requestTimeout)\r\n    }, this.config.cleanupInterval)\r\n  }\r\n\r\n  /**\r\n   * 停止自动清理\r\n   */\r\n  stopAutoCleanup(): void {\r\n    if (this.cleanupTimer) {\r\n      clearInterval(this.cleanupTimer)\r\n      this.cleanupTimer = undefined\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 清理最旧的请求（LRU）\r\n   */\r\n  private cleanupOldestRequest(): void {\r\n    let oldestKey: string | null = null\r\n    let oldestTime = Number.POSITIVE_INFINITY\r\n\r\n    for (const [key, task] of this.pendingRequests) {\r\n      if (task.createdAt < oldestTime) {\r\n        oldestTime = task.createdAt\r\n        oldestKey = key\r\n      }\r\n    }\r\n\r\n    if (oldestKey) {\r\n      this.pendingRequests.delete(oldestKey)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 清理超时的请求\r\n   */\r\n  cleanupTimeoutTasks(timeoutMs: number): number {\r\n    const now = Date.now()\r\n    let cleanedCount = 0\r\n\r\n    for (const [key, task] of this.pendingRequests) {\r\n      if (now - task.createdAt > timeoutMs) {\r\n        this.pendingRequests.delete(key)\r\n        cleanedCount++\r\n      }\r\n    }\r\n\r\n    return cleanedCount\r\n  }\r\n\r\n  /**\r\n   * 取消指定请求\r\n   */\r\n  cancel(key: string): boolean {\r\n    return this.pendingRequests.delete(key)\r\n  }\r\n\r\n  /**\r\n   * 取消所有请求\r\n   */\r\n  cancelAll(): void {\r\n    this.pendingRequests.clear()\r\n  }\r\n\r\n  /**\r\n   * 检查请求是否正在进行\r\n   */\r\n  isRunning(key: string): boolean {\r\n    return this.pendingRequests.has(key)\r\n  }\r\n\r\n  /**\r\n   * 等待指定请求完成\r\n   */\r\n  async waitFor<T = unknown>(key: string): Promise<ResponseData<T> | null> {\r\n    const task = this.pendingRequests.get(key)\r\n    if (!task) {\r\n      return null\r\n    }\r\n\r\n    try {\r\n      return await task.promise as ResponseData<T>\r\n    } catch {\r\n      return null\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 等待所有请求完成\r\n   */\r\n  async waitForAll(): Promise<void> {\r\n    const promises = Array.from(this.pendingRequests.values()).map(\r\n      task => task.promise.catch(() => {}), // 忽略错误\r\n    )\r\n\r\n    await Promise.all(promises)\r\n  }\r\n\r\n  /**\r\n   * 获取任务信息\r\n   */\r\n  getTaskInfo(key: string): {\r\n    key: string\r\n    createdAt: number\r\n    refCount: number\r\n    duration: number\r\n  } | null {\r\n    const task = this.pendingRequests.get(key)\r\n    if (!task) {\r\n      return null\r\n    }\r\n\r\n    return {\r\n      key: task.key,\r\n      createdAt: task.createdAt,\r\n      refCount: task.refCount,\r\n      duration: Date.now() - task.createdAt,\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 获取所有任务信息\r\n   */\r\n  getAllTaskInfo(): Array<{\r\n    key: string\r\n    createdAt: number\r\n    refCount: number\r\n    duration: number\r\n  }> {\r\n    return Array.from(this.pendingRequests.values()).map(task => ({\r\n      key: task.key,\r\n      createdAt: task.createdAt,\r\n      refCount: task.refCount,\r\n      duration: Date.now() - task.createdAt,\r\n    }))\r\n  }\r\n\r\n  /**\r\n   * 获取统计信息\r\n   */\r\n  getStats(): DeduplicationStats {\r\n    const totalRequests = this.stats.executions + this.stats.duplications\r\n    return {\r\n      executions: this.stats.executions,\r\n      duplications: this.stats.duplications,\r\n      savedRequests: this.stats.savedRequests,\r\n      deduplicationRate: totalRequests > 0 ? this.stats.duplications / totalRequests : 0,\r\n      pendingCount: this.pendingRequests.size,\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 重置统计信息\r\n   */\r\n  resetStats(): void {\r\n    this.stats = {\r\n      executions: 0,\r\n      duplications: 0,\r\n      savedRequests: 0,\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 获取待处理请求数量\r\n   */\r\n  getPendingCount(): number {\r\n    return this.pendingRequests.size\r\n  }\r\n\r\n  /**\r\n   * 获取所有待处理请求的键\r\n   */\r\n  getPendingKeys(): string[] {\r\n    return Array.from(this.pendingRequests.keys())\r\n  }\r\n\r\n  /**\r\n   * 获取引用计数最高的请求\r\n   */\r\n  getMostReferencedTask(): {\r\n    key: string\r\n    refCount: number\r\n  } | null {\r\n    let maxRefCount = 0\r\n    let mostReferencedKey = ''\r\n\r\n    for (const [key, task] of this.pendingRequests) {\r\n      if (task.refCount > maxRefCount) {\r\n        maxRefCount = task.refCount\r\n        mostReferencedKey = key\r\n      }\r\n    }\r\n\r\n    return maxRefCount > 0 ? { key: mostReferencedKey, refCount: maxRefCount } : null\r\n  }\r\n\r\n  /**\r\n   * 获取运行时间最长的请求\r\n   */\r\n  getLongestRunningTask(): {\r\n    key: string\r\n    duration: number\r\n  } | null {\r\n    let maxDuration = 0\r\n    let longestKey = ''\r\n\r\n    const now = Date.now()\r\n    for (const [key, task] of this.pendingRequests) {\r\n      const duration = now - task.createdAt\r\n      if (duration > maxDuration) {\r\n        maxDuration = duration\r\n        longestKey = key\r\n      }\r\n    }\r\n\r\n    return maxDuration > 0 ? { key: longestKey, duration: maxDuration } : null\r\n  }\r\n\r\n  /**\r\n   * 更新配置\r\n   */\r\n  updateConfig(config: Partial<DeduplicationManagerConfig>): void {\r\n    Object.assign(this.config, config)\r\n    \r\n    // 如果改变了自动清理设置\r\n    if (config.autoCleanup !== undefined) {\r\n      if (config.autoCleanup && !this.cleanupTimer) {\r\n        this.startAutoCleanup()\r\n      } else if (!config.autoCleanup && this.cleanupTimer) {\r\n        this.stopAutoCleanup()\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 销毁管理器\r\n   */\r\n  destroy(): void {\r\n    this.stopAutoCleanup()\r\n    this.pendingRequests.clear()\r\n    this.resetStats()\r\n  }\r\n}\r\n\r\n/**\r\n * 创建去重管理器\r\n */\r\nexport function createDeduplicationManager(\r\n  config?: DeduplicationManagerConfig,\r\n): DeduplicationManager {\r\n  return new DeduplicationManager(config)\r\n}\r\n\r\n/**\r\n * 全局去重管理器实例\r\n */\r\nexport const globalDeduplicationManager = new DeduplicationManager()"],"names":["DeduplicationManager","constructor","config","this","pendingRequests","Map","stats","executions","duplications","savedRequests","maxPendingRequests","cleanupInterval","requestTimeout","autoCleanup","startAutoCleanup","execute","key","requestFn","has","existingTask","get","refCount","promise","size","cleanupOldestRequest","requestPromise","finally","delete","task","createdAt","Date","now","set","cleanupTimer","setInterval","cleanupTimeoutTasks","stopAutoCleanup","clearInterval","oldestKey","oldestTime","Number","POSITIVE_INFINITY","timeoutMs","cleanedCount","cancel","cancelAll","clear","isRunning","waitFor","waitForAll","promises","Array","from","values","map","catch","Promise","all","getTaskInfo","duration","getAllTaskInfo","getStats","totalRequests","deduplicationRate","pendingCount","resetStats","getPendingCount","getPendingKeys","keys","getMostReferencedTask","maxRefCount","mostReferencedKey","getLongestRunningTask","maxDuration","longestKey","updateConfig","Object","assign","destroy","createDeduplicationManager","globalDeduplicationManager"],"mappings":"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"}