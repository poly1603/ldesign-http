{"version":3,"file":"helpers.js","sources":["../../src/utils/helpers.ts"],"sourcesContent":["/**\n * 实用工具函数模块\n * \n * 提供防抖、节流、请求合并等常用功能\n */\n\n/**\n * 防抖函数\n * \n * 在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时\n * \n * @param fn - 要防抖的函数\n * @param delay - 延迟时间（毫秒）\n * @returns 防抖后的函数\n * \n * @example\n * ```typescript\n * const debouncedSearch = debounce((query: string) => {\n *   \n * }, 300)\n * \n * // 只有最后一次调用会执行\n * debouncedSearch('a')\n * debouncedSearch('ab')\n * debouncedSearch('abc') // 300ms后执行\n * ```\n */\nexport function debounce<T extends (...args: any[]) => any>(\n  fn: T,\n  delay: number,\n): (...args: Parameters<T>) => void {\n  let timeoutId: ReturnType<typeof setTimeout> | null = null\n\n  return function (this: unknown, ...args: Parameters<T>) {\n    if (timeoutId !== null) {\n      clearTimeout(timeoutId)\n    }\n\n    timeoutId = setTimeout(() => {\n      fn.apply(this, args)\n      timeoutId = null\n    }, delay)\n  }\n}\n\n/**\n * 节流函数\n * \n * 规定时间内只触发一次函数，适用于高频事件\n * \n * @param fn - 要节流的函数\n * @param limit - 时间间隔（毫秒）\n * @returns 节流后的函数\n * \n * @example\n * ```typescript\n * const throttledScroll = throttle(() => {\n *   \n * }, 100)\n * \n * window.addEventListener('scroll', throttledScroll)\n * ```\n */\nexport function throttle<T extends (...args: any[]) => any>(\n  fn: T,\n  limit: number,\n): (...args: Parameters<T>) => void {\n  let inThrottle = false\n  let lastResult: ReturnType<T>\n\n  return function (this: unknown, ...args: Parameters<T>) {\n    if (!inThrottle) {\n      inThrottle = true\n      lastResult = fn.apply(this, args)\n\n      setTimeout(() => {\n        inThrottle = false\n      }, limit)\n    }\n\n    return lastResult\n  }\n}\n\n/**\n * 请求合并器配置\n */\nexport interface BatchRequestConfig<TInput = unknown, TOutput = unknown> {\n  /** 最大批量大小 */\n  maxBatchSize?: number\n  /** 等待时间（毫秒） */\n  delay?: number\n  /** 批量请求执行器 */\n  batchFn: (items: TInput[]) => Promise<TOutput[]>\n}\n\n/**\n * 创建请求合并器\n * \n * 将多个单独的请求合并为一个批量请求，减少网络往返\n * \n * @param config - 批量请求配置\n * @returns 合并后的请求函数\n * \n * @example\n * ```typescript\n * const getUsersBatch = createBatchRequest({\n *   maxBatchSize: 100,\n *   delay: 10,\n *   batchFn: async (userIds) => {\n *     return fetch('/api/users/batch', {\n *       method: 'POST',\n *       body: JSON.stringify({ ids: userIds })\n *     }).then(r => r.json())\n *   }\n * })\n * \n * // 这些调用会被合并成一个批量请求\n * const user1 = await getUsersBatch(1)\n * const user2 = await getUsersBatch(2)\n * const user3 = await getUsersBatch(3)\n * ```\n */\nexport function createBatchRequest<TInput, TOutput>(\n  config: BatchRequestConfig<TInput, TOutput>,\n): (input: TInput) => Promise<TOutput> {\n  const {\n    maxBatchSize = 100,\n    delay = 10,\n    batchFn,\n  } = config\n\n  const queue: Array<{\n    input: TInput\n    resolve: (value: TOutput) => void\n    reject: (error: any) => void\n  }> = []\n  let timeoutId: ReturnType<typeof setTimeout> | null = null\n\n  async function processBatch() {\n    if (queue.length === 0) return\n\n    const batch = queue.splice(0, maxBatchSize)\n    const inputs = batch.map(item => item.input)\n\n    try {\n      const results = await batchFn(inputs)\n\n      batch.forEach((item, index) => {\n        item.resolve(results[index])\n      })\n    }\n    catch (error) {\n      batch.forEach((item) => {\n        item.reject(error)\n      })\n    }\n\n    // 如果还有剩余项，继续处理\n    if (queue.length > 0) {\n      timeoutId = setTimeout(processBatch, 0)\n    }\n    else {\n      timeoutId = null\n    }\n  }\n\n  function scheduleBatch() {\n    if (timeoutId !== null) return\n\n    timeoutId = setTimeout(processBatch, delay)\n  }\n\n  return function (input: TInput): Promise<TOutput> {\n    return new Promise((resolve, reject) => {\n      queue.push({ input, resolve, reject })\n\n      if (queue.length >= maxBatchSize) {\n        if (timeoutId !== null) {\n          clearTimeout(timeoutId)\n          timeoutId = null\n        }\n        processBatch()\n      }\n      else {\n        scheduleBatch()\n      }\n    })\n  }\n}\n\n/**\n * 创建一次性函数\n * \n * 确保函数只被执行一次，后续调用返回第一次的结果\n * \n * @param fn - 要执行的函数\n * @returns 只执行一次的函数\n * \n * @example\n * ```typescript\n * const initialize = once(() => {\n *   \n *   return { initialized: true }\n * })\n * \n * initialize() // 输出: \"Initializing...\"\n * initialize() // 不输出，返回缓存的结果\n * ```\n */\nexport function once<T extends (...args: any[]) => any>(\n  fn: T,\n): (...args: Parameters<T>) => ReturnType<T> {\n  let called = false\n  let result: ReturnType<T>\n\n  return function (this: unknown, ...args: Parameters<T>): ReturnType<T> {\n    if (!called) {\n      called = true\n      result = fn.apply(this, args)\n    }\n    return result\n  }\n}\n\n/**\n * 内存化函数\n * \n * 缓存函数的执行结果，相同输入返回缓存值\n * \n * @param fn - 要内存化的函数\n * @param keyFn - 生成缓存键的函数，默认使用JSON.stringify\n * @returns 内存化后的函数\n * \n * @example\n * ```typescript\n * const expensiveCalculation = memoize((a: number, b: number) => {\n *   \n *   return a * b\n * })\n * \n * expensiveCalculation(2, 3) // 输出: \"Calculating...\" 返回: 6\n * expensiveCalculation(2, 3) // 不输出，直接返回: 6\n * ```\n */\nexport function memoize<T extends (...args: any[]) => any>(\n  fn: T,\n  keyFn?: (...args: Parameters<T>) => string,\n): T & { cache: Map<string, ReturnType<T>>, clear: () => void } {\n  const cache = new Map<string, ReturnType<T>>()\n\n  const memoized = function (this: unknown, ...args: Parameters<T>): ReturnType<T> {\n    const key = keyFn ? keyFn(...args) : JSON.stringify(args)\n\n    if (cache.has(key)) {\n      return cache.get(key)!\n    }\n\n    const result = fn.apply(this, args)\n    cache.set(key, result)\n    return result\n  } as T & { cache: Map<string, ReturnType<T>>, clear: () => void }\n\n  memoized.cache = cache\n  memoized.clear = () => cache.clear()\n\n  return memoized\n}\n\n/**\n * 重试函数\n * \n * 在失败时自动重试函数执行\n * \n * @param fn - 要执行的函数\n * @param options - 重试选项\n * @param options.maxAttempts - 最大尝试次数，默认3\n * @param options.delay - 重试延迟基数（毫秒），默认1000\n * @param options.onRetry - 重试回调函数\n * @returns Promise\n * \n * @example\n * ```typescript\n * const result = await retry(\n *   () => fetch('/api/data'),\n *   { maxAttempts: 3, delay: 1000 }\n * )\n * ```\n */\nexport async function retry<T>(\n  fn: () => Promise<T>,\n  options: {\n    maxAttempts?: number\n    delay?: number\n    onRetry?: (attempt: number, error: Error) => void\n  } = {},\n): Promise<T> {\n  const { maxAttempts = 3, delay = 1000, onRetry } = options\n  let lastError: Error | undefined\n\n  for (let attempt = 1; attempt <= maxAttempts; attempt++) {\n    try {\n      return await fn()\n    }\n    catch (error) {\n      lastError = error instanceof Error ? error : new Error(String(error))\n\n      if (attempt < maxAttempts) {\n        onRetry?.(attempt, lastError)\n        await new Promise(resolve => setTimeout(resolve, delay * attempt))\n      }\n    }\n  }\n\n  throw lastError || new Error('Unknown error')\n}\n\n/**\n * 链式调用构建器\n * \n * 创建支持链式调用的配置构建器\n * \n * @example\n * ```typescript\n * interface Config {\n *   url: string\n *   method: string\n *   headers: Record<string, string>\n * }\n * \n * const builder = createChainBuilder<Config>({\n *   url: '',\n *   method: 'GET',\n *   headers: {}\n * })\n * \n * const config = builder\n *   .set('url', '/api/users')\n *   .set('method', 'POST')\n *   .merge('headers', { 'Content-Type': 'application/json' })\n *   .build()\n * ```\n */\nexport function createChainBuilder<T extends Record<string, unknown>>(\n  initial: T,\n) {\n  let config = { ...initial }\n\n  return {\n    set<K extends keyof T>(key: K, value: T[K]) {\n      config[key] = value\n      return this\n    },\n    merge<K extends keyof T>(key: K, value: Partial<T[K]>) {\n      if (typeof config[key] === 'object' && typeof value === 'object') {\n        config[key] = { ...config[key], ...value }\n      }\n      return this\n    },\n    reset() {\n      config = { ...initial }\n      return this\n    },\n    build(): T {\n      return { ...config }\n    },\n    get current(): Readonly<T> {\n      return config\n    },\n  }\n}\n\n/**\n * 对象键值对安全访问\n * \n * 安全获取嵌套对象的值，避免 undefined 错误\n * \n * @param obj - 目标对象\n * @param path - 属性路径\n * @param defaultValue - 默认值\n * @returns 属性值或默认值\n * \n * @example\n * ```typescript\n * const obj = { user: { profile: { name: 'John' } } }\n * \n * get(obj, 'user.profile.name') // 'John'\n * get(obj, 'user.profile.age', 18) // 18\n * get(obj, 'user.settings.theme') // undefined\n * ```\n */\nexport function get<T = unknown>(\n  obj: unknown,\n  path: string,\n  defaultValue?: T,\n): T | undefined {\n  const keys = path.split('.')\n  let result: any = obj\n\n  for (const key of keys) {\n    if (result === null || result === undefined) {\n      return defaultValue\n    }\n    result = result[key]\n  }\n\n  return result !== undefined ? result : defaultValue\n}\n\n/**\n * 安全地设置嵌套对象的值\n * \n * @param obj - 目标对象\n * @param path - 属性路径\n * @param value - 要设置的值\n * \n * @example\n * ```typescript\n * const obj = {}\n * set(obj, 'user.profile.name', 'John')\n * // obj 变为: { user: { profile: { name: 'John' } } }\n * ```\n */\nexport function set(obj: Record<string, any>, path: string, value: unknown): void {\n  const keys = path.split('.')\n  const lastKey = keys.pop()!\n  let current = obj\n\n  for (const key of keys) {\n    if (!(key in current) || typeof current[key] !== 'object') {\n      current[key] = {}\n    }\n    current = current[key]\n  }\n\n  current[lastKey] = value\n}\n\n/**\n * 深度冻结对象\n * \n * 递归冻结对象及其所有嵌套对象\n * \n * @param obj - 要冻结的对象\n * @returns 冻结后的对象\n */\nexport function deepFreeze<T>(obj: T): Readonly<T> {\n  Object.freeze(obj)\n\n  Object.values(obj as any).forEach((value) => {\n    if (typeof value === 'object' && value !== null && !Object.isFrozen(value)) {\n      deepFreeze(value)\n    }\n  })\n\n  return obj\n}\n\n/**\n * 延迟执行\n * \n * @param ms - 延迟时间（毫秒）\n * @returns Promise\n */\nexport function sleep(ms: number): Promise<void> {\n  return new Promise(resolve => setTimeout(resolve, ms))\n}\n\n/**\n * 超时Promise包装器\n * \n * 为Promise添加超时限制\n * \n * @param promise - 原始Promise\n * @param ms - 超时时间（毫秒）\n * @param timeoutError - 超时错误\n * @returns 带超时的Promise\n * \n * @example\n * ```typescript\n * const result = await timeout(\n *   fetch('/api/data'),\n *   5000,\n *   new Error('Request timeout')\n * )\n * ```\n */\nexport function timeout<T>(\n  promise: Promise<T>,\n  ms: number,\n  timeoutError: Error = new Error('Timeout'),\n): Promise<T> {\n  let timeoutId: ReturnType<typeof setTimeout>\n\n  const timeoutPromise = new Promise<never>((_, reject) => {\n    timeoutId = setTimeout(() => reject(timeoutError), ms)\n  })\n\n  return Promise.race([promise, timeoutPromise]).finally(() => {\n    clearTimeout(timeoutId)\n  })\n}\n\n/**\n * 批量并行执行Promise（带并发控制）\n * \n * @param tasks - 任务数组\n * @param limit - 并发限制\n * @returns Promise数组结果\n * \n * @example\n * ```typescript\n * const tasks = urls.map(url => () => fetch(url))\n * const results = await parallelLimit(tasks, 3) // 最多3个并发\n * ```\n */\nexport async function parallelLimit<T>(\n  tasks: Array<() => Promise<T>>,\n  limit: number,\n): Promise<T[]> {\n  const results: T[] = []\n  const executing: Promise<void>[] = []\n\n  for (let i = 0; i < tasks.length; i++) {\n    const task = tasks[i]!\n    const promise = task().then(result => {\n      results[i] = result\n    })\n\n    executing.push(promise)\n\n    if (executing.length >= limit) {\n      await Promise.race(executing)\n      executing.splice(\n        executing.findIndex(p => p === promise),\n        1,\n      )\n    }\n  }\n\n  await Promise.all(executing)\n  return results\n}\n"],"names":["debounce","fn","delay","timeoutId","args","clearTimeout","setTimeout","apply","this","throttle","limit","lastResult","inThrottle","createBatchRequest","config","maxBatchSize","batchFn","queue","async","processBatch","length","batch","splice","inputs","map","item","input","results","forEach","index","resolve","error","reject","Promise","push","once","result","called","memoize","keyFn","cache","Map","memoized","key","JSON","stringify","has","get","set","clear","retry","options","maxAttempts","onRetry","lastError","attempt","Error","String","createChainBuilder","initial","value","merge","reset","build","current","obj","path","defaultValue","keys","split","lastKey","pop","deepFreeze","Object","freeze","values","isFrozen","sleep","ms","timeout","promise","timeoutError","timeoutPromise","_","race","finally","parallelLimit","tasks","executing","i","task","then","findIndex","p","all","w","d","m","j","T","g","v","b","E","P","y","z"],"mappings":"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"}