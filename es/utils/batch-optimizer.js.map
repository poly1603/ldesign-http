{"version":3,"file":"batch-optimizer.js","sources":["../../src/utils/batch-optimizer.ts"],"sourcesContent":["/**\r\n * 请求批处理优化器\r\n * \r\n * 功能：\r\n * 1. 自动合并相同端点的请求\r\n * 2. 智能分组批处理\r\n * 3. 请求去重和合并\r\n * 4. 动态批次大小调整\r\n */\r\n\r\nimport type { RequestConfig, ResponseData } from '../types'\r\n\r\n/**\r\n * 批处理配置\r\n */\r\nexport interface BatchOptimizerConfig {\r\n  /** 是否启用批处理 */\r\n  enabled?: boolean\r\n  /** 最大批次大小 */\r\n  maxBatchSize?: number\r\n  /** 批处理等待时间（ms） */\r\n  batchWindow?: number\r\n  /** 是否自动合并相同请求 */\r\n  mergeDuplicates?: boolean\r\n  /** 是否启用智能分组 */\r\n  smartGrouping?: boolean\r\n  /** 动态调整批次大小 */\r\n  dynamicBatching?: boolean\r\n}\r\n\r\n/**\r\n * 批处理请求项\r\n */\r\ninterface BatchRequest<T = any> {\r\n  id: string\r\n  config: RequestConfig\r\n  resolve: (value: ResponseData<T>) => void\r\n  reject: (error: Error) => void\r\n  timestamp: number\r\n}\r\n\r\n/**\r\n * 批处理组\r\n */\r\ninterface BatchGroup {\r\n  endpoint: string\r\n  method: string\r\n  requests: BatchRequest[]\r\n  timer?: NodeJS.Timeout\r\n}\r\n\r\n/**\r\n * 批处理统计\r\n */\r\nexport interface BatchStats {\r\n  totalBatches: number\r\n  totalRequests: number\r\n  mergedRequests: number\r\n  averageBatchSize: number\r\n  totalSavedRequests: number\r\n  compressionRatio: number\r\n}\r\n\r\n/**\r\n * 请求批处理优化器\r\n * \r\n * 优化策略：\r\n * 1. 使用时间窗口收集请求\r\n * 2. 智能分组相似请求\r\n * 3. 合并重复请求\r\n * 4. 动态调整批次大小\r\n */\r\nexport class BatchOptimizer {\r\n  private config: Required<BatchOptimizerConfig>\r\n  private groups = new Map<string, BatchGroup>()\r\n  private stats: BatchStats = {\r\n    totalBatches: 0,\r\n    totalRequests: 0,\r\n    mergedRequests: 0,\r\n    averageBatchSize: 0,\r\n    totalSavedRequests: 0,\r\n    compressionRatio: 1,\r\n  }\r\n  \r\n  // 动态批处理参数\r\n  private currentBatchSize: number\r\n  private successRate = 1.0\r\n  private latencyHistory: number[] = []\r\n  \r\n  // 请求签名缓存\r\n  private signatureCache = new Map<string, string>()\r\n  private readonly MAX_CACHE_SIZE = 1000\r\n\r\n  constructor(config: BatchOptimizerConfig = {}) {\r\n    this.config = {\r\n      enabled: config.enabled ?? true,\r\n      maxBatchSize: config.maxBatchSize ?? 10,\r\n      batchWindow: config.batchWindow ?? 50, // 50ms 窗口\r\n      mergeDuplicates: config.mergeDuplicates ?? true,\r\n      smartGrouping: config.smartGrouping ?? true,\r\n      dynamicBatching: config.dynamicBatching ?? true,\r\n    }\r\n    \r\n    this.currentBatchSize = this.config.maxBatchSize\r\n  }\r\n\r\n  /**\r\n   * 添加请求到批处理队列\r\n   */\r\n  async addRequest<T = any>(\r\n    config: RequestConfig,\r\n    executor: (config: RequestConfig) => Promise<ResponseData<T>>\r\n  ): Promise<ResponseData<T>> {\r\n    if (!this.config.enabled) {\r\n      return executor(config)\r\n    }\r\n\r\n    return new Promise((resolve, reject) => {\r\n      const request: BatchRequest<T> = {\r\n        id: this.generateId(),\r\n        config,\r\n        resolve,\r\n        reject,\r\n        timestamp: Date.now(),\r\n      }\r\n\r\n      // 获取或创建批处理组\r\n      const groupKey = this.getGroupKey(config)\r\n      let group = this.groups.get(groupKey)\r\n      \r\n      if (!group) {\r\n        group = this.createGroup(config)\r\n        this.groups.set(groupKey, group)\r\n      }\r\n\r\n      // 检查是否可以合并重复请求\r\n      if (this.config.mergeDuplicates) {\r\n        const duplicate = this.findDuplicate(group, config)\r\n        if (duplicate) {\r\n          // 共享结果\r\n          this.shareDuplicateResult(duplicate, request)\r\n          this.stats.mergedRequests++\r\n          this.stats.totalSavedRequests++\r\n          return\r\n        }\r\n      }\r\n\r\n      // 添加到组\r\n      group.requests.push(request)\r\n      this.stats.totalRequests++\r\n\r\n      // 检查是否应该立即执行\r\n      if (this.shouldExecuteNow(group)) {\r\n        this.executeBatch(group, executor)\r\n      } else {\r\n        // 设置延迟执行\r\n        this.scheduleExecution(group, executor)\r\n      }\r\n    })\r\n  }\r\n\r\n  /**\r\n   * 创建批处理组\r\n   */\r\n  private createGroup(config: RequestConfig): BatchGroup {\r\n    const url = new URL(config.url || '')\r\n    return {\r\n      endpoint: `${url.protocol}//${url.host}${url.pathname}`,\r\n      method: config.method || 'GET',\r\n      requests: [],\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 获取组键\r\n   */\r\n  private getGroupKey(config: RequestConfig): string {\r\n    if (!this.config.smartGrouping) {\r\n      return 'default'\r\n    }\r\n\r\n    const url = new URL(config.url || '')\r\n    const endpoint = `${url.protocol}//${url.host}${url.pathname}`\r\n    const method = config.method || 'GET'\r\n    \r\n    return `${method}:${endpoint}`\r\n  }\r\n\r\n  /**\r\n   * 查找重复请求\r\n   */\r\n  private findDuplicate(group: BatchGroup, config: RequestConfig): BatchRequest | null {\r\n    const signature = this.getRequestSignature(config)\r\n    \r\n    for (const request of group.requests) {\r\n      if (this.getRequestSignature(request.config) === signature) {\r\n        return request\r\n      }\r\n    }\r\n    \r\n    return null\r\n  }\r\n\r\n  /**\r\n   * 获取请求签名（使用缓存优化）\r\n   */\r\n  private getRequestSignature(config: RequestConfig): string {\r\n    const key = `${config.method}:${config.url}:${JSON.stringify(config.params)}:${JSON.stringify(config.data)}`\r\n    \r\n    let signature = this.signatureCache.get(key)\r\n    if (!signature) {\r\n      signature = this.computeSignature(config)\r\n      \r\n      // 限制缓存大小\r\n      if (this.signatureCache.size >= this.MAX_CACHE_SIZE) {\r\n        const firstKey = this.signatureCache.keys().next().value\r\n        if (firstKey) {\r\n          this.signatureCache.delete(firstKey)\r\n        }\r\n      }\r\n      \r\n      this.signatureCache.set(key, signature)\r\n    }\r\n    \r\n    return signature\r\n  }\r\n\r\n  /**\r\n   * 计算请求签名\r\n   */\r\n  private computeSignature(config: RequestConfig): string {\r\n    const parts = [\r\n      config.method || 'GET',\r\n      config.url || '',\r\n      JSON.stringify(config.params || {}),\r\n      JSON.stringify(config.data || {}),\r\n      JSON.stringify(config.headers || {}),\r\n    ]\r\n    \r\n    return parts.join('|')\r\n  }\r\n\r\n  /**\r\n   * 共享重复请求结果\r\n   */\r\n  private shareDuplicateResult<T>(\r\n    original: BatchRequest,\r\n    duplicate: BatchRequest<T>\r\n  ): void {\r\n    // 监听原始请求完成\r\n    const originalPromise = new Promise<ResponseData<T>>((resolve, reject) => {\r\n      const originalResolve = original.resolve\r\n      const originalReject = original.reject\r\n      \r\n      original.resolve = (result) => {\r\n        originalResolve(result)\r\n        resolve(result as ResponseData<T>)\r\n      }\r\n      \r\n      original.reject = (error) => {\r\n        originalReject(error)\r\n        reject(error)\r\n      }\r\n    })\r\n    \r\n    originalPromise.then(duplicate.resolve, duplicate.reject)\r\n  }\r\n\r\n  /**\r\n   * 判断是否应该立即执行\r\n   */\r\n  private shouldExecuteNow(group: BatchGroup): boolean {\r\n    // 达到最大批次大小\r\n    if (group.requests.length >= this.currentBatchSize) {\r\n      return true\r\n    }\r\n    \r\n    // 第一个请求等待时间过长\r\n    if (group.requests.length > 0) {\r\n      const firstRequest = group.requests[0]\r\n      if (Date.now() - firstRequest.timestamp > this.config.batchWindow * 2) {\r\n        return true\r\n      }\r\n    }\r\n    \r\n    return false\r\n  }\r\n\r\n  /**\r\n   * 调度批处理执行\r\n   */\r\n  private scheduleExecution<T>(\r\n    group: BatchGroup,\r\n    executor: (config: RequestConfig) => Promise<ResponseData<T>>\r\n  ): void {\r\n    if (group.timer) {\r\n      return // 已经调度\r\n    }\r\n    \r\n    group.timer = setTimeout(() => {\r\n      this.executeBatch(group, executor)\r\n    }, this.config.batchWindow)\r\n  }\r\n\r\n  /**\r\n   * 执行批处理\r\n   */\r\n  private async executeBatch<T>(\r\n    group: BatchGroup,\r\n    executor: (config: RequestConfig) => Promise<ResponseData<T>>\r\n  ): Promise<void> {\r\n    // 清除定时器\r\n    if (group.timer) {\r\n      clearTimeout(group.timer)\r\n      group.timer = undefined\r\n    }\r\n    \r\n    // 取出所有请求\r\n    const requests = group.requests.splice(0)\r\n    if (requests.length === 0) {\r\n      return\r\n    }\r\n    \r\n    // 更新统计\r\n    this.stats.totalBatches++\r\n    const batchStartTime = Date.now()\r\n    \r\n    // 并行执行所有请求\r\n    const promises = requests.map(async (request) => {\r\n      try {\r\n        const result = await executor(request.config)\r\n        request.resolve(result)\r\n        return { success: true }\r\n      } catch (error) {\r\n        request.reject(error as Error)\r\n        return { success: false }\r\n      }\r\n    })\r\n    \r\n    const results = await Promise.all(promises)\r\n    \r\n    // 更新性能指标\r\n    const batchDuration = Date.now() - batchStartTime\r\n    this.updateMetrics(requests.length, batchDuration, results)\r\n    \r\n    // 动态调整批次大小\r\n    if (this.config.dynamicBatching) {\r\n      this.adjustBatchSize()\r\n    }\r\n    \r\n    // 清理空组\r\n    const groupKey = this.getGroupKey(requests[0].config)\r\n    if (group.requests.length === 0) {\r\n      this.groups.delete(groupKey)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 更新性能指标\r\n   */\r\n  private updateMetrics(\r\n    batchSize: number,\r\n    duration: number,\r\n    results: Array<{ success: boolean }>\r\n  ): void {\r\n    // 更新延迟历史\r\n    this.latencyHistory.push(duration / batchSize)\r\n    if (this.latencyHistory.length > 100) {\r\n      this.latencyHistory.shift()\r\n    }\r\n    \r\n    // 计算成功率\r\n    const successCount = results.filter(r => r.success).length\r\n    const currentRate = successCount / results.length\r\n    this.successRate = this.successRate * 0.9 + currentRate * 0.1 // 指数移动平均\r\n    \r\n    // 更新平均批次大小\r\n    const totalBatches = this.stats.totalBatches\r\n    this.stats.averageBatchSize = \r\n      (this.stats.averageBatchSize * (totalBatches - 1) + batchSize) / totalBatches\r\n    \r\n    // 计算压缩率\r\n    this.stats.compressionRatio = \r\n      this.stats.totalRequests / (this.stats.totalRequests - this.stats.totalSavedRequests)\r\n  }\r\n\r\n  /**\r\n   * 动态调整批次大小\r\n   */\r\n  private adjustBatchSize(): void {\r\n    // 基于成功率调整\r\n    if (this.successRate < 0.8) {\r\n      // 成功率低，减小批次\r\n      this.currentBatchSize = Math.max(1, Math.floor(this.currentBatchSize * 0.8))\r\n    } else if (this.successRate > 0.95) {\r\n      // 成功率高，增大批次\r\n      this.currentBatchSize = Math.min(\r\n        this.config.maxBatchSize,\r\n        Math.floor(this.currentBatchSize * 1.2)\r\n      )\r\n    }\r\n    \r\n    // 基于延迟调整\r\n    if (this.latencyHistory.length > 10) {\r\n      const avgLatency = this.latencyHistory.reduce((a, b) => a + b, 0) / this.latencyHistory.length\r\n      const recentLatency = this.latencyHistory.slice(-10).reduce((a, b) => a + b, 0) / 10\r\n      \r\n      if (recentLatency > avgLatency * 1.5) {\r\n        // 延迟增加，减小批次\r\n        this.currentBatchSize = Math.max(1, Math.floor(this.currentBatchSize * 0.9))\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 获取统计信息\r\n   */\r\n  getStats(): BatchStats {\r\n    return { ...this.stats }\r\n  }\r\n\r\n  /**\r\n   * 重置统计\r\n   */\r\n  resetStats(): void {\r\n    this.stats = {\r\n      totalBatches: 0,\r\n      totalRequests: 0,\r\n      mergedRequests: 0,\r\n      averageBatchSize: 0,\r\n      totalSavedRequests: 0,\r\n      compressionRatio: 1,\r\n    }\r\n    this.latencyHistory = []\r\n    this.successRate = 1.0\r\n  }\r\n\r\n  /**\r\n   * 获取当前批次大小\r\n   */\r\n  getCurrentBatchSize(): number {\r\n    return this.currentBatchSize\r\n  }\r\n\r\n  /**\r\n   * 清理资源\r\n   */\r\n  destroy(): void {\r\n    // 清理所有定时器\r\n    for (const group of this.groups.values()) {\r\n      if (group.timer) {\r\n        clearTimeout(group.timer)\r\n      }\r\n    }\r\n    \r\n    // 拒绝所有待处理请求\r\n    for (const group of this.groups.values()) {\r\n      for (const request of group.requests) {\r\n        request.reject(new Error('BatchOptimizer destroyed'))\r\n      }\r\n    }\r\n    \r\n    this.groups.clear()\r\n    this.signatureCache.clear()\r\n  }\r\n\r\n  /**\r\n   * 生成唯一 ID\r\n   */\r\n  private generateId(): string {\r\n    return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`\r\n  }\r\n}\r\n\r\n/**\r\n * 创建批处理优化器\r\n */\r\nexport function createBatchOptimizer(config?: BatchOptimizerConfig): BatchOptimizer {\r\n  return new BatchOptimizer(config)\r\n}"],"names":["BatchOptimizer","constructor","config","this","groups","Map","stats","totalBatches","totalRequests","mergedRequests","averageBatchSize","totalSavedRequests","compressionRatio","successRate","latencyHistory","signatureCache","MAX_CACHE_SIZE","enabled","maxBatchSize","batchWindow","mergeDuplicates","smartGrouping","dynamicBatching","currentBatchSize","addRequest","executor","Promise","resolve","reject","request","id","generateId","timestamp","Date","now","groupKey","getGroupKey","group","get","createGroup","set","duplicate","findDuplicate","shareDuplicateResult","requests","push","shouldExecuteNow","executeBatch","scheduleExecution","url","URL","endpoint","protocol","host","pathname","method","signature","getRequestSignature","key","JSON","stringify","params","data","computeSignature","size","firstKey","keys","next","value","delete","headers","join","original","originalResolve","originalReject","result","error","then","length","firstRequest","timer","setTimeout","clearTimeout","splice","batchStartTime","promises","map","async","success","results","all","batchDuration","updateMetrics","adjustBatchSize","batchSize","duration","shift","currentRate","filter","r","Math","max","floor","min","avgLatency","reduce","a","b","slice","getStats","resetStats","getCurrentBatchSize","destroy","values","Error","clear","random","toString","substr","createBatchOptimizer","l","g"],"mappings":"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"}