{"version":3,"file":"error-recovery.js","sources":["../../src/utils/error-recovery.ts"],"sourcesContent":["/**\r\n * 错误恢复策略模块\r\n * \r\n * 提供各种错误恢复策略的实现\r\n */\r\n\r\nimport type { HttpError } from '../types'\r\n\r\n/**\r\n * 错误恢复策略接口\r\n */\r\nexport interface ErrorRecoveryStrategy {\r\n  /** 策略名称 */\r\n  name: string\r\n  /** 是否可以处理该错误 */\r\n  canHandle: (error: HttpError) => boolean\r\n  /** 执行恢复策略 */\r\n  recover: (error: HttpError) => Promise<boolean>\r\n  /** 策略优先级（数字越大优先级越高） */\r\n  priority?: number\r\n}\r\n\r\n/**\r\n * 内置恢复策略\r\n */\r\nexport const builtInStrategies = {\r\n  /**\r\n   * 网络重连策略\r\n   */\r\n  networkReconnect: {\r\n    name: 'network-reconnect',\r\n    priority: 10,\r\n    canHandle: (error: HttpError) => error.isNetworkError === true,\r\n    recover: async (_error: HttpError): Promise<boolean> => {\r\n      // 简单的网络连通性检查\r\n      try {\r\n        // 尝试请求一个简单的端点\r\n        const response = await fetch('/ping', {\r\n          method: 'HEAD',\r\n          cache: 'no-cache',\r\n          signal: AbortSignal.timeout(5000),\r\n        })\r\n        return response.ok\r\n      }\r\n      catch {\r\n        return false\r\n      }\r\n    },\r\n  } as ErrorRecoveryStrategy,\r\n\r\n  /**\r\n   * 认证刷新策略\r\n   */\r\n  authRefresh: {\r\n    name: 'auth-refresh',\r\n    priority: 20,\r\n    canHandle: (error: HttpError) => error.response?.status === 401,\r\n    recover: async (_error: HttpError): Promise<boolean> => {\r\n      try {\r\n        // 尝试刷新认证令牌\r\n        const refreshToken = localStorage.getItem('refreshToken')\r\n        if (!refreshToken) {\r\n          return false\r\n        }\r\n\r\n        const response = await fetch('/auth/refresh', {\r\n          method: 'POST',\r\n          headers: {\r\n            'Content-Type': 'application/json',\r\n          },\r\n          body: JSON.stringify({ refreshToken }),\r\n        })\r\n\r\n        if (response.ok) {\r\n          const data = await response.json()\r\n          localStorage.setItem('accessToken', data.accessToken)\r\n          localStorage.setItem('refreshToken', data.refreshToken)\r\n          return true\r\n        }\r\n      }\r\n      catch {\r\n        // 刷新失败，清除所有令牌\r\n        localStorage.removeItem('accessToken')\r\n        localStorage.removeItem('refreshToken')\r\n      }\r\n\r\n      return false\r\n    },\r\n  } as ErrorRecoveryStrategy,\r\n\r\n  /**\r\n   * 服务降级策略\r\n   */\r\n  serviceFallback: {\r\n    name: 'service-fallback',\r\n    priority: 5,\r\n    canHandle: (error: HttpError) => {\r\n      const status = error.response?.status\r\n      return status === 503 || status === 502 || status === 504\r\n    },\r\n    recover: async (error: HttpError): Promise<boolean> => {\r\n      // 检查是否有备用服务端点\r\n      const fallbackUrl = error.config?.url?.replace('/api/', '/api-fallback/')\r\n      if (fallbackUrl && fallbackUrl !== error.config?.url) {\r\n        try {\r\n          const response = await fetch(fallbackUrl, {\r\n            method: 'HEAD',\r\n            signal: AbortSignal.timeout(3000),\r\n          })\r\n          return response.ok\r\n        }\r\n        catch {\r\n          return false\r\n        }\r\n      }\r\n      return false\r\n    },\r\n  } as ErrorRecoveryStrategy,\r\n\r\n  /**\r\n   * 缓存回退策略\r\n   */\r\n  cacheFailback: {\r\n    name: 'cache-fallback',\r\n    priority: 1,\r\n    canHandle: (error: HttpError) => {\r\n      // 只对GET请求使用缓存回退\r\n      return error.config?.method?.toUpperCase() === 'GET'\r\n    },\r\n    recover: async (error: HttpError): Promise<boolean> => {\r\n      try {\r\n        // 尝试从缓存中获取数据\r\n        const cacheKey = `http_cache_${error.config?.url}`\r\n        const cachedData = localStorage.getItem(cacheKey)\r\n\r\n        if (cachedData) {\r\n          const parsed = JSON.parse(cachedData)\r\n          const now = Date.now()\r\n\r\n          // 检查缓存是否过期（24小时）\r\n          if (now - parsed.timestamp < 24 * 60 * 60 * 1000) {\r\n            // 可以使用缓存数据\r\n            return true\r\n          }\r\n        }\r\n      }\r\n      catch {\r\n        // 缓存解析失败\r\n      }\r\n\r\n      return false\r\n    },\r\n  } as ErrorRecoveryStrategy,\r\n}\r\n\r\n/**\r\n * 错误恢复管理器\r\n */\r\nexport class ErrorRecoveryManager {\r\n  private strategies: ErrorRecoveryStrategy[] = []\r\n\r\n  constructor() {\r\n    // 添加内置策略\r\n    this.addStrategy(builtInStrategies.authRefresh)\r\n    this.addStrategy(builtInStrategies.networkReconnect)\r\n    this.addStrategy(builtInStrategies.serviceFallback)\r\n    this.addStrategy(builtInStrategies.cacheFailback)\r\n  }\r\n\r\n  /**\r\n   * 添加恢复策略\r\n   */\r\n  addStrategy(strategy: ErrorRecoveryStrategy): void {\r\n    this.strategies.push(strategy)\r\n    // 按优先级排序\r\n    this.strategies.sort((a, b) => (b.priority || 0) - (a.priority || 0))\r\n  }\r\n\r\n  /**\r\n   * 移除恢复策略\r\n   */\r\n  removeStrategy(name: string): void {\r\n    this.strategies = this.strategies.filter(s => s.name !== name)\r\n  }\r\n\r\n  /**\r\n   * 尝试恢复错误\r\n   */\r\n  async attemptRecovery(error: HttpError): Promise<{\r\n    recovered: boolean\r\n    strategy?: string\r\n  }> {\r\n    for (const strategy of this.strategies) {\r\n      if (strategy.canHandle(error)) {\r\n        try {\r\n          const recovered = await strategy.recover(error)\r\n          if (recovered) {\r\n            return {\r\n              recovered: true,\r\n              strategy: strategy.name,\r\n            }\r\n          }\r\n        }\r\n        catch {\r\n          // 策略执行失败，尝试下一个\r\n          continue\r\n        }\r\n      }\r\n    }\r\n\r\n    return { recovered: false }\r\n  }\r\n\r\n  /**\r\n   * 获取所有策略\r\n   */\r\n  getStrategies(): ErrorRecoveryStrategy[] {\r\n    return [...this.strategies]\r\n  }\r\n\r\n  /**\r\n   * 清除所有策略\r\n   */\r\n  clearStrategies(): void {\r\n    this.strategies = []\r\n  }\r\n\r\n  /**\r\n   * 批量尝试恢复\r\n   */\r\n  async attemptBatchRecovery(errors: HttpError[]): Promise<Map<HttpError, {\r\n    recovered: boolean\r\n    strategy?: string\r\n  }>> {\r\n    const results = new Map<HttpError, { recovered: boolean; strategy?: string }>()\r\n\r\n    await Promise.all(\r\n      errors.map(async (error) => {\r\n        const result = await this.attemptRecovery(error)\r\n        results.set(error, result)\r\n      })\r\n    )\r\n\r\n    return results\r\n  }\r\n}"],"names":["builtInStrategies","networkReconnect","name","priority","canHandle","error","isNetworkError","recover","async","fetch","method","cache","signal","AbortSignal","timeout","ok","authRefresh","response","status","refreshToken","localStorage","getItem","headers","body","JSON","stringify","data","json","setItem","accessToken","removeItem","serviceFallback","fallbackUrl","config","url","replace","cacheFailback","toUpperCase","cacheKey","cachedData","parsed","parse","Date","now","timestamp","ErrorRecoveryManager","constructor","this","strategies","addStrategy","strategy","push","sort","a","b","removeStrategy","filter","s","attemptRecovery","recovered","getStrategies","clearStrategies","attemptBatchRecovery","errors","results","Map","Promise","all","map","result","set","o"],"mappings":"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"}