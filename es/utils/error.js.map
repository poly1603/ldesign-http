{"version":3,"file":"error.js","sources":["../../src/utils/error.ts"],"sourcesContent":["import type {\r\n  HttpError,\r\n  RequestConfig,\r\n  ResponseData,\r\n  RetryConfig,\r\n} from '../types'\r\nimport { createHttpError, delay } from './index'\r\n\r\n/**\r\n * 错误类型枚举\r\n */\r\nexport enum ErrorType {\r\n  NETWORK = 'NETWORK_ERROR',\r\n  TIMEOUT = 'TIMEOUT_ERROR',\r\n  CANCEL = 'CANCEL_ERROR',\r\n  HTTP = 'HTTP_ERROR',\r\n  PARSE = 'PARSE_ERROR',\r\n  UNKNOWN = 'UNKNOWN_ERROR',\r\n}\r\n\r\n/**\r\n * 错误恢复策略\r\n */\r\nexport interface ErrorRecoveryStrategy {\r\n  /** 策略名称 */\r\n  name: string\r\n  /** 是否可以处理该错误 */\r\n  canHandle: (error: HttpError) => boolean\r\n  /** 执行恢复策略 */\r\n  recover: (error: HttpError) => Promise<boolean>\r\n  /** 策略优先级（数字越大优先级越高） */\r\n  priority?: number\r\n}\r\n\r\n/**\r\n * 错误统计信息\r\n */\r\nexport interface ErrorStats {\r\n  /** 总错误数 */\r\n  total: number\r\n  /** 按类型分组的错误数 */\r\n  byType: Record<ErrorType, number>\r\n  /** 按状态码分组的错误数 */\r\n  byStatus: Record<number, number>\r\n  /** 最近的错误 */\r\n  recent: HttpError[]\r\n  /** 错误率（最近1小时） */\r\n  errorRate: number\r\n  /** 最常见的错误 */\r\n  mostCommon: { type: ErrorType, count: number } | null\r\n}\r\n\r\n/**\r\n * 错误处理器类（增强版）\r\n */\r\nexport class ErrorHandler {\r\n  // 缓存常见错误消息模板\r\n  private static readonly ERROR_TEMPLATES = {\r\n    [ErrorType.NETWORK]: 'Network Error: Unable to connect to the server',\r\n    [ErrorType.TIMEOUT]: (timeout: number) =>\r\n      `Timeout Error: Request timed out after ${timeout}ms`,\r\n    [ErrorType.CANCEL]: 'Cancel Error: Request was cancelled',\r\n    [ErrorType.HTTP]: (status: number, statusText: string) =>\r\n      `HTTP Error ${status}: ${statusText}`,\r\n    [ErrorType.PARSE]: 'Parse Error: Failed to parse response data',\r\n    [ErrorType.UNKNOWN]: 'Unknown Error: An unexpected error occurred',\r\n  } as const\r\n\r\n  // 错误统计\r\n  private static errorStats: ErrorStats = {\r\n    total: 0,\r\n    byType: {\r\n      [ErrorType.NETWORK]: 0,\r\n      [ErrorType.TIMEOUT]: 0,\r\n      [ErrorType.CANCEL]: 0,\r\n      [ErrorType.HTTP]: 0,\r\n      [ErrorType.PARSE]: 0,\r\n      [ErrorType.UNKNOWN]: 0,\r\n    },\r\n    byStatus: {},\r\n    recent: [],\r\n    errorRate: 0,\r\n    mostCommon: null,\r\n  }\r\n\r\n  // 恢复策略（按优先级排序）\r\n  private static recoveryStrategies: ErrorRecoveryStrategy[] = []\r\n\r\n  // 错误历史（最近100个错误）\r\n  private static errorHistory: Array<{\r\n    error: HttpError\r\n    timestamp: number\r\n    recovered: boolean\r\n  }> = []\r\n\r\n  /**\r\n   * 创建网络错误（优化版）\r\n   */\r\n  static createNetworkError(\r\n    config: RequestConfig,\r\n    originalError?: any,\r\n  ): HttpError {\r\n    const error = createHttpError(\r\n      this.ERROR_TEMPLATES[ErrorType.NETWORK],\r\n      config,\r\n      ErrorType.NETWORK,\r\n    )\r\n    error.isNetworkError = true\r\n    error.cause = originalError\r\n    return error\r\n  }\r\n\r\n  /**\r\n   * 创建超时错误（优化版）\r\n   */\r\n  static createTimeoutError(config: RequestConfig, timeout: number): HttpError {\r\n    const message\r\n      = typeof this.ERROR_TEMPLATES[ErrorType.TIMEOUT] === 'function'\r\n        ? this.ERROR_TEMPLATES[ErrorType.TIMEOUT](timeout)\r\n        : `Timeout Error: Request timed out after ${timeout}ms`\r\n\r\n    const error = createHttpError(message, config, ErrorType.TIMEOUT)\r\n    error.isTimeoutError = true\r\n    return error\r\n  }\r\n\r\n  /**\r\n   * 创建取消错误（优化版）\r\n   */\r\n  static createCancelError(config: RequestConfig): HttpError {\r\n    const error = createHttpError(\r\n      this.ERROR_TEMPLATES[ErrorType.CANCEL],\r\n      config,\r\n      ErrorType.CANCEL,\r\n    )\r\n    error.isCancelError = true\r\n    return error\r\n  }\r\n\r\n  /**\r\n   * 创建 HTTP 错误\r\n   */\r\n  static createHttpError(\r\n    status: number,\r\n    statusText: string,\r\n    config: RequestConfig,\r\n    response?: ResponseData,\r\n  ): HttpError {\r\n    const error = createHttpError(\r\n      `HTTP Error: ${status} ${statusText}`,\r\n      config,\r\n      ErrorType.HTTP,\r\n      response,\r\n    )\r\n    return error\r\n  }\r\n\r\n  /**\r\n   * 创建解析错误\r\n   */\r\n  static createParseError(\r\n    config: RequestConfig,\r\n    originalError?: any,\r\n  ): HttpError {\r\n    const error = createHttpError(\r\n      'Parse Error: Failed to parse response data',\r\n      config,\r\n      ErrorType.PARSE,\r\n    )\r\n    error.cause = originalError\r\n    return error\r\n  }\r\n\r\n  /**\r\n   * 判断错误是否可重试\r\n   */\r\n  static isRetryableError(error: HttpError): boolean {\r\n    // 网络错误和超时错误通常可以重试\r\n    if (error.isNetworkError || error.isTimeoutError) {\r\n      return true\r\n    }\r\n\r\n    // 某些 HTTP 状态码可以重试\r\n    if (error.response?.status) {\r\n      const status = error.response.status\r\n      // 5xx 服务器错误和 429 限流错误可以重试\r\n      return status >= 500 || status === 429 || status === 408\r\n    }\r\n\r\n    return false\r\n  }\r\n\r\n  /**\r\n   * 获取错误的用户友好消息\r\n   */\r\n  static getUserFriendlyMessage(error: HttpError): string {\r\n    if (error.isNetworkError) {\r\n      return '网络连接失败，请检查网络设置'\r\n    }\r\n\r\n    if (error.isTimeoutError) {\r\n      return '请求超时，请稍后重试'\r\n    }\r\n\r\n    if (error.isCancelError) {\r\n      return '请求已取消'\r\n    }\r\n\r\n    if (error.response?.status) {\r\n      const status = error.response.status\r\n      switch (status) {\r\n        case 400:\r\n          return '请求参数错误'\r\n        case 401:\r\n          return '未授权，请重新登录'\r\n        case 403:\r\n          return '权限不足'\r\n        case 404:\r\n          return '请求的资源不存在'\r\n        case 429:\r\n          return '请求过于频繁，请稍后重试'\r\n        case 500:\r\n          return '服务器内部错误'\r\n        case 502:\r\n          return '网关错误'\r\n        case 503:\r\n          return '服务暂时不可用'\r\n        default:\r\n          return `请求失败 (${status})`\r\n      }\r\n    }\r\n\r\n    return error.message || '未知错误'\r\n  }\r\n\r\n  /**\r\n   * 记录错误统计\r\n   */\r\n  static recordError(error: HttpError): void {\r\n    const now = Date.now()\r\n\r\n    // 更新总数\r\n    this.errorStats.total++\r\n\r\n    // 更新按类型统计\r\n    const errorType = this.getErrorType(error)\r\n    this.errorStats.byType[errorType]++\r\n\r\n    // 更新按状态码统计\r\n    if (error.response?.status) {\r\n      const status = error.response.status\r\n      this.errorStats.byStatus[status] = (this.errorStats.byStatus[status] || 0) + 1\r\n    }\r\n\r\n    // 添加到最近错误列表\r\n    this.errorStats.recent.unshift(error)\r\n    if (this.errorStats.recent.length > 10) {\r\n      this.errorStats.recent = this.errorStats.recent.slice(0, 10)\r\n    }\r\n\r\n    // 添加到错误历史\r\n    this.errorHistory.unshift({\r\n      error,\r\n      timestamp: now,\r\n      recovered: false,\r\n    })\r\n    if (this.errorHistory.length > 100) {\r\n      this.errorHistory = this.errorHistory.slice(0, 100)\r\n    }\r\n\r\n    // 更新错误率（最近1小时）\r\n    this.updateErrorRate()\r\n\r\n    // 更新最常见错误\r\n    this.updateMostCommonError()\r\n  }\r\n\r\n  /**\r\n   * 尝试错误恢复\r\n   */\r\n  static async tryRecover(error: HttpError): Promise<boolean> {\r\n    // 策略已经按优先级排序，直接使用\r\n    for (const strategy of this.recoveryStrategies) {\r\n      if (strategy.canHandle(error)) {\r\n        try {\r\n          const recovered = await strategy.recover(error)\r\n          if (recovered) {\r\n            // 标记为已恢复\r\n            const historyItem = this.errorHistory.find(\r\n              item => item.error === error,\r\n            )\r\n            if (historyItem) {\r\n              historyItem.recovered = true\r\n            }\r\n            return true\r\n          }\r\n        }\r\n        catch (recoveryError) {\r\n          console.warn(`Recovery strategy \"${strategy.name}\" failed:`, recoveryError)\r\n        }\r\n      }\r\n    }\r\n\r\n    return false\r\n  }\r\n\r\n  /**\r\n   * 添加恢复策略（保持优先级排序）\r\n   */\r\n  static addRecoveryStrategy(strategy: ErrorRecoveryStrategy): void {\r\n    this.recoveryStrategies.push(strategy)\r\n    // 保持按优先级排序（高优先级在前）\r\n    this.recoveryStrategies.sort((a, b) => (b.priority || 0) - (a.priority || 0))\r\n  }\r\n\r\n  /**\r\n   * 移除恢复策略\r\n   */\r\n  static removeRecoveryStrategy(strategyName: string): boolean {\r\n    const index = this.recoveryStrategies.findIndex(s => s.name === strategyName)\r\n    if (index > -1) {\r\n      this.recoveryStrategies.splice(index, 1)\r\n      return true\r\n    }\r\n    return false\r\n  }\r\n\r\n  /**\r\n   * 获取所有恢复策略\r\n   */\r\n  static getRecoveryStrategies(): ErrorRecoveryStrategy[] {\r\n    return [...this.recoveryStrategies]\r\n  }\r\n\r\n  /**\r\n   * 获取错误类型\r\n   */\r\n  private static getErrorType(error: HttpError): ErrorType {\r\n    if (error.isNetworkError)\r\n      return ErrorType.NETWORK\r\n    if (error.isTimeoutError)\r\n      return ErrorType.TIMEOUT\r\n    if (error.isCancelError)\r\n      return ErrorType.CANCEL\r\n    if (error.response)\r\n      return ErrorType.HTTP\r\n    if (error.code === ErrorType.PARSE)\r\n      return ErrorType.PARSE\r\n    return ErrorType.UNKNOWN\r\n  }\r\n\r\n  /**\r\n   * 更新错误率\r\n   */\r\n  private static updateErrorRate(): void {\r\n    const oneHourAgo = Date.now() - 60 * 60 * 1000\r\n    const recentErrors = this.errorHistory.filter(\r\n      item => item.timestamp > oneHourAgo,\r\n    )\r\n\r\n    // 简单的错误率计算（错误数/时间）\r\n    this.errorStats.errorRate = recentErrors.length\r\n  }\r\n\r\n  /**\r\n   * 更新最常见错误\r\n   */\r\n  private static updateMostCommonError(): void {\r\n    let maxCount = 0\r\n    let mostCommonType: ErrorType | null = null\r\n\r\n    for (const [type, count] of Object.entries(this.errorStats.byType)) {\r\n      if (count > maxCount) {\r\n        maxCount = count\r\n        mostCommonType = type as ErrorType\r\n      }\r\n    }\r\n\r\n    this.errorStats.mostCommon = mostCommonType\r\n      ? { type: mostCommonType, count: maxCount }\r\n      : null\r\n  }\r\n\r\n  /**\r\n   * 获取错误统计信息\r\n   */\r\n  static getStats(): ErrorStats {\r\n    return { ...this.errorStats }\r\n  }\r\n\r\n  /**\r\n   * 获取错误历史\r\n   */\r\n  static getErrorHistory(): Array<{\r\n    error: HttpError\r\n    timestamp: number\r\n    recovered: boolean\r\n  }> {\r\n    return [...this.errorHistory]\r\n  }\r\n\r\n  /**\r\n   * 重置错误统计\r\n   */\r\n  static resetStats(): void {\r\n    this.errorStats = {\r\n      total: 0,\r\n      byType: {\r\n        [ErrorType.NETWORK]: 0,\r\n        [ErrorType.TIMEOUT]: 0,\r\n        [ErrorType.CANCEL]: 0,\r\n        [ErrorType.HTTP]: 0,\r\n        [ErrorType.PARSE]: 0,\r\n        [ErrorType.UNKNOWN]: 0,\r\n      },\r\n      byStatus: {},\r\n      recent: [],\r\n      errorRate: 0,\r\n      mostCommon: null,\r\n    }\r\n    this.errorHistory = []\r\n  }\r\n\r\n  /**\r\n   * 清理过期的错误历史\r\n   */\r\n  static cleanupOldErrors(maxAge: number = 24 * 60 * 60 * 1000): number {\r\n    const cutoff = Date.now() - maxAge\r\n    const originalLength = this.errorHistory.length\r\n\r\n    this.errorHistory = this.errorHistory.filter(\r\n      item => item.timestamp > cutoff,\r\n    )\r\n\r\n    return originalLength - this.errorHistory.length\r\n  }\r\n}\r\n\r\n/**\r\n * 重试管理器\r\n */\r\nexport class RetryManager {\r\n  private config: Required<RetryConfig>\r\n\r\n  constructor(config: RetryConfig = {}) {\r\n    this.config = {\r\n      retries: config.retries ?? 3,\r\n      retryDelay: config.retryDelay ?? 1000,\r\n      retryCondition: config.retryCondition ?? ErrorHandler.isRetryableError,\r\n      retryDelayFunction:\r\n        config.retryDelayFunction ?? this.defaultRetryDelayFunction,\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 执行带重试的请求\r\n   */\r\n  async executeWithRetry<T>(\r\n    requestFn: () => Promise<T>,\r\n    _requestConfig?: RequestConfig,\r\n  ): Promise<T> {\r\n    let lastError: HttpError | undefined\r\n    let retryCount = 0\r\n\r\n    while (retryCount <= this.config?.retries) {\r\n      try {\r\n        return await requestFn()\r\n      }\r\n      catch (error) {\r\n        lastError = error as HttpError\r\n\r\n        // 检查是否应该重试\r\n        if (\r\n          retryCount >= this.config?.retries\r\n          || !this.config?.retryCondition(lastError)\r\n        ) {\r\n          throw lastError\r\n        }\r\n\r\n        // 计算延迟时间\r\n        const delayTime = this.config?.retryDelayFunction(retryCount, lastError)\r\n\r\n        // 等待重试\r\n        await delay(delayTime)\r\n\r\n        retryCount++\r\n      }\r\n    }\r\n\r\n    throw lastError || createHttpError('Retry failed', { url: '' })\r\n  }\r\n\r\n  /**\r\n   * 默认重试延迟函数（指数退避）\r\n   */\r\n  private defaultRetryDelayFunction(\r\n    retryCount: number,\r\n    _error: HttpError,\r\n  ): number {\r\n    const baseDelay = this.config?.retryDelay\r\n    const exponentialDelay = baseDelay * 2 ** retryCount\r\n\r\n    // 添加随机抖动，避免雷群效应\r\n    const jitter = Math.random() * 0.1 * exponentialDelay\r\n\r\n    return Math.min(exponentialDelay + jitter, 30000) // 最大延迟 30 秒\r\n  }\r\n\r\n  /**\r\n   * 更新重试配置\r\n   */\r\n  updateConfig(config: Partial<RetryConfig>): void {\r\n    Object.assign(this.config, config)\r\n  }\r\n\r\n  /**\r\n   * 获取当前配置\r\n   */\r\n  getConfig(): Required<RetryConfig> {\r\n    return { ...this.config }\r\n  }\r\n}\r\n\r\n/**\r\n * 超时管理器\r\n */\r\nexport class TimeoutManager {\r\n  private timeouts = new Map<string, NodeJS.Timeout>()\r\n\r\n  /**\r\n   * 创建超时控制器\r\n   */\r\n  createTimeoutController(\r\n    timeout: number,\r\n    requestId?: string,\r\n  ): {\r\n      signal: AbortSignal\r\n      cleanup: () => void\r\n    } {\r\n    const controller = new AbortController()\r\n    const id = requestId || this.generateId()\r\n\r\n    const timeoutId = setTimeout(() => {\r\n      controller.abort()\r\n      this.timeouts.delete(id)\r\n    }, timeout)\r\n\r\n    this.timeouts.set(id, timeoutId)\r\n\r\n    return {\r\n      signal: controller.signal,\r\n      cleanup: () => {\r\n        const existingTimeout = this.timeouts.get(id)\r\n        if (existingTimeout) {\r\n          clearTimeout(existingTimeout)\r\n          this.timeouts.delete(id)\r\n        }\r\n      },\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 清理所有超时\r\n   */\r\n  clearAll(): void {\r\n    this.timeouts.forEach((timeoutId) => {\r\n      clearTimeout(timeoutId)\r\n    })\r\n    this.timeouts.clear()\r\n  }\r\n\r\n  /**\r\n   * 生成唯一 ID\r\n   */\r\n  private generateId(): string {\r\n    return Math.random().toString(36).substring(2, 15)\r\n  }\r\n}\r\n\r\n/**\r\n * 内置错误恢复策略\r\n */\r\nexport const builtinRecoveryStrategies = {\r\n  /**\r\n   * 网络重连策略\r\n   */\r\n  networkReconnect: {\r\n    name: 'network-reconnect',\r\n    priority: 10,\r\n    canHandle: (error: HttpError) => error.isNetworkError,\r\n    recover: async (_error: HttpError): Promise<boolean> => {\r\n      // 简单的网络连通性检查\r\n      try {\r\n        // 尝试请求一个简单的端点\r\n        const response = await fetch('/ping', {\r\n          method: 'HEAD',\r\n          cache: 'no-cache',\r\n          signal: AbortSignal.timeout(5000),\r\n        })\r\n        return response.ok\r\n      }\r\n      catch {\r\n        return false\r\n      }\r\n    },\r\n  } as ErrorRecoveryStrategy,\r\n\r\n  /**\r\n   * 认证刷新策略\r\n   */\r\n  authRefresh: {\r\n    name: 'auth-refresh',\r\n    priority: 20,\r\n    canHandle: (error: HttpError) => error.response?.status === 401,\r\n    recover: async (_error: HttpError): Promise<boolean> => {\r\n      try {\r\n        // 尝试刷新认证令牌\r\n        const refreshToken = localStorage.getItem('refreshToken')\r\n        if (!refreshToken) {\r\n          return false\r\n        }\r\n\r\n        const response = await fetch('/auth/refresh', {\r\n          method: 'POST',\r\n          headers: {\r\n            'Content-Type': 'application/json',\r\n          },\r\n          body: JSON.stringify({ refreshToken }),\r\n        })\r\n\r\n        if (response.ok) {\r\n          const data = await response.json()\r\n          localStorage.setItem('accessToken', data.accessToken)\r\n          localStorage.setItem('refreshToken', data.refreshToken)\r\n          return true\r\n        }\r\n      }\r\n      catch {\r\n        // 刷新失败，清除所有令牌\r\n        localStorage.removeItem('accessToken')\r\n        localStorage.removeItem('refreshToken')\r\n      }\r\n\r\n      return false\r\n    },\r\n  } as ErrorRecoveryStrategy,\r\n\r\n  /**\r\n   * 服务降级策略\r\n   */\r\n  serviceFallback: {\r\n    name: 'service-fallback',\r\n    priority: 5,\r\n    canHandle: (error: HttpError) => {\r\n      const status = error.response?.status\r\n      return status === 503 || status === 502 || status === 504\r\n    },\r\n    recover: async (error: HttpError): Promise<boolean> => {\r\n      // 检查是否有备用服务端点\r\n      const fallbackUrl = error.config?.url?.replace('/api/', '/api-fallback/')\r\n      if (fallbackUrl && fallbackUrl !== error.config?.url) {\r\n        try {\r\n          const response = await fetch(fallbackUrl, {\r\n            method: 'HEAD',\r\n            signal: AbortSignal.timeout(3000),\r\n          })\r\n          return response.ok\r\n        }\r\n        catch {\r\n          return false\r\n        }\r\n      }\r\n      return false\r\n    },\r\n  } as ErrorRecoveryStrategy,\r\n\r\n  /**\r\n   * 缓存回退策略\r\n   */\r\n  cacheFailback: {\r\n    name: 'cache-fallback',\r\n    priority: 1,\r\n    canHandle: (error: HttpError) => {\r\n      // 只对GET请求使用缓存回退\r\n      return error.config?.method?.toUpperCase() === 'GET'\r\n    },\r\n    recover: async (error: HttpError): Promise<boolean> => {\r\n      try {\r\n        // 尝试从缓存中获取数据\r\n        const cacheKey = `http_cache_${error.config?.url}`\r\n        const cachedData = localStorage.getItem(cacheKey)\r\n\r\n        if (cachedData) {\r\n          const parsed = JSON.parse(cachedData)\r\n          const now = Date.now()\r\n\r\n          // 检查缓存是否过期（24小时）\r\n          if (now - parsed.timestamp < 24 * 60 * 60 * 1000) {\r\n            // 可以使用缓存数据\r\n            return true\r\n          }\r\n        }\r\n      }\r\n      catch {\r\n        // 缓存解析失败\r\n      }\r\n\r\n      return false\r\n    },\r\n  } as ErrorRecoveryStrategy,\r\n}\r\n\r\n/**\r\n * 错误分析器\r\n */\r\nexport class ErrorAnalyzer {\r\n  /**\r\n   * 分析错误模式\r\n   */\r\n  static analyzeErrorPatterns(errors: HttpError[]): {\r\n    patterns: Array<{\r\n      type: string\r\n      count: number\r\n      percentage: number\r\n      description: string\r\n    }>\r\n    recommendations: string[]\r\n  } {\r\n    const patterns: Record<string, number> = {}\r\n    const total = errors.length\r\n\r\n    // 分析错误模式\r\n    errors.forEach((error) => {\r\n      // 网络错误模式\r\n      if (error.isNetworkError) {\r\n        patterns.network_errors = (patterns.network_errors || 0) + 1\r\n      }\r\n\r\n      // 超时错误模式\r\n      if (error.isTimeoutError) {\r\n        patterns.timeout_errors = (patterns.timeout_errors || 0) + 1\r\n      }\r\n\r\n      // 认证错误模式\r\n      if (error.response?.status === 401) {\r\n        patterns.auth_errors = (patterns.auth_errors || 0) + 1\r\n      }\r\n\r\n      // 服务器错误模式\r\n      if (error.response?.status && error.response.status >= 500) {\r\n        patterns.server_errors = (patterns.server_errors || 0) + 1\r\n      }\r\n\r\n      // 客户端错误模式\r\n      if (error.response?.status && error.response.status >= 400 && error.response.status < 500) {\r\n        patterns.client_errors = (patterns.client_errors || 0) + 1\r\n      }\r\n    })\r\n\r\n    // 转换为分析结果\r\n    const analysisResults = Object.entries(patterns).map(([type, count]) => ({\r\n      type,\r\n      count,\r\n      percentage: Math.round((count / total) * 100),\r\n      description: this.getPatternDescription(type),\r\n    }))\r\n\r\n    // 生成建议\r\n    const recommendations = this.generateRecommendations(patterns, total)\r\n\r\n    return {\r\n      patterns: analysisResults,\r\n      recommendations,\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 获取模式描述\r\n   */\r\n  private static getPatternDescription(type: string): string {\r\n    const descriptions: Record<string, string> = {\r\n      network_errors: '网络连接问题，可能是网络不稳定或服务器不可达',\r\n      timeout_errors: '请求超时，可能是网络延迟高或服务器响应慢',\r\n      auth_errors: '认证失败，可能是令牌过期或权限不足',\r\n      server_errors: '服务器内部错误，可能是服务器故障或过载',\r\n      client_errors: '客户端请求错误，可能是参数错误或请求格式不正确',\r\n    }\r\n\r\n    return descriptions[type] || '未知错误模式'\r\n  }\r\n\r\n  /**\r\n   * 生成建议\r\n   */\r\n  private static generateRecommendations(patterns: Record<string, number>, total: number): string[] {\r\n    const recommendations: string[] = []\r\n\r\n    // 网络错误建议\r\n    if (patterns.network_errors && patterns.network_errors / total > 0.3) {\r\n      recommendations.push('考虑添加网络重连机制和离线模式支持')\r\n    }\r\n\r\n    // 超时错误建议\r\n    if (patterns.timeout_errors && patterns.timeout_errors / total > 0.2) {\r\n      recommendations.push('考虑增加请求超时时间或优化服务器响应速度')\r\n    }\r\n\r\n    // 认证错误建议\r\n    if (patterns.auth_errors && patterns.auth_errors / total > 0.1) {\r\n      recommendations.push('考虑实现自动令牌刷新机制')\r\n    }\r\n\r\n    // 服务器错误建议\r\n    if (patterns.server_errors && patterns.server_errors / total > 0.15) {\r\n      recommendations.push('考虑添加服务降级和熔断机制')\r\n    }\r\n\r\n    // 客户端错误建议\r\n    if (patterns.client_errors && patterns.client_errors / total > 0.25) {\r\n      recommendations.push('考虑加强客户端参数验证和错误提示')\r\n    }\r\n\r\n    return recommendations\r\n  }\r\n}\r\n"],"names":["ErrorType","NETWORK","TIMEOUT","CANCEL","HTTP","PARSE","UNKNOWN","ErrorHandler","createNetworkError","config","originalError","error","createHttpError","this","ERROR_TEMPLATES","isNetworkError","cause","createTimeoutError","timeout","message","isTimeoutError","createCancelError","isCancelError","status","statusText","response","createParseError","isRetryableError","getUserFriendlyMessage","recordError","now","Date","errorStats","total","errorType","getErrorType","byType","byStatus","recent","unshift","length","slice","errorHistory","timestamp","recovered","updateErrorRate","updateMostCommonError","tryRecover","strategy","recoveryStrategies","canHandle","recover","historyItem","find","item","recoveryError","addRecoveryStrategy","push","sort","a","b","priority","removeRecoveryStrategy","strategyName","index","findIndex","s","name","splice","getRecoveryStrategies","code","oneHourAgo","recentErrors","filter","errorRate","maxCount","mostCommonType","type","count","Object","entries","mostCommon","getStats","getErrorHistory","resetStats","cleanupOldErrors","maxAge","cutoff","originalLength","RetryManager","constructor","retries","retryDelay","retryCondition","retryDelayFunction","defaultRetryDelayFunction","executeWithRetry","requestFn","_requestConfig","lastError","retryCount","delayTime","delay","url","_error","exponentialDelay","jitter","Math","random","min","updateConfig","assign","getConfig","TimeoutManager","timeouts","Map","createTimeoutController","requestId","controller","AbortController","id","generateId","timeoutId","setTimeout","abort","delete","set","signal","cleanup","existingTimeout","get","clearTimeout","clearAll","forEach","clear","toString","substring","builtinRecoveryStrategies","networkReconnect","async","fetch","method","cache","AbortSignal","ok","authRefresh","refreshToken","localStorage","getItem","headers","body","JSON","stringify","data","json","setItem","accessToken","removeItem","serviceFallback","fallbackUrl","replace","cacheFailback","toUpperCase","cacheKey","cachedData","parsed","parse","ErrorAnalyzer","analyzeErrorPatterns","errors","patterns","network_errors","timeout_errors","auth_errors","server_errors","client_errors","map","percentage","round","description","getPatternDescription","recommendations","generateRecommendations","T","i","u","h","F","y"],"mappings":"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"}