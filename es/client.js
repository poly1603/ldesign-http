import{InterceptorManagerImpl as e}from"./interceptors/manager.js";import{generateId as t}from"./utils/index.js";import{CacheManager as r}from"./utils/cache.js";import{globalCancelManager as s}from"./utils/cancel.js";import{ConcurrencyManager as o}from"./utils/concurrency.js";import{DownloadProgressCalculator as a,getFilenameFromResponse as n,getFilenameFromURL as i,getMimeTypeFromFilename as c,saveFileToLocal as u}from"./utils/download.js";import{RetryManager as h}from"./utils/error.js";import{RequestMonitor as l}from"./utils/monitor.js";import{RequestPool as d}from"./utils/pool.js";import{PriorityQueue as p,determinePriority as g}from"./utils/priority.js";import{validateFile as y,createUploadFormData as m,ProgressCalculator as f}from"./utils/upload.js";class w{constructor(t={},a){if(this.isDestroyed=!1,this.config={timeout:1e4,headers:{"Content-Type":"application/json",...t.headers},...t},!a)throw new Error("HTTP adapter is required");this.adapter=a,this.retryManager=new h(t.retry),this.cancelManager=s,this.cacheManager=new r(t.cache),this.concurrencyManager=new o(t.concurrency),this.monitor=new l(t.monitor),this.priorityQueue=new p(t.priorityQueue),this.requestPool=new d(t.connectionPool),this.interceptors={request:new e,response:new e,error:new e}}async request(e){this.checkDestroyed();const r=this.optimizedMergeConfig(e),s=t();this.monitor.startRequest(s,r);const o=g(r);if(void 0!==o&&this.priorityQueue)return this.priorityQueue.enqueue(r,async()=>{try{const e=await this.executeRequestWithRetry(r,s);return this.monitor.endRequest(s,r,e),e}catch(e){throw this.monitor.endRequest(s,r,void 0,e),e}},o);try{const e=await this.executeRequestWithRetry(r,s);return this.monitor.endRequest(s,r,e),e}catch(e){throw this.monitor.endRequest(s,r,void 0,e),e}}async executeRequestWithRetry(e,t){const r=e.retry;return r?.retries&&r.retries>0?this.retryManager.executeWithRetry(()=>(this.monitor.recordRetry(t),this.executeRequest(e)),e):this.executeRequest(e)}async executeRequest(e){return await this.cacheManager.get(e)||this.concurrencyManager.execute(()=>this.performRequest(e),e)}async performRequest(e){let t=null;try{t=await this.processRequestInterceptors(e);let r=await this.adapter.request(t);return r=await this.processResponseInterceptors(r),await this.cacheManager.set(t,r),r}catch(e){throw await this.processErrorInterceptors(e)}}get(e,t={}){return this.request({...t,method:"GET",url:e})}post(e,t,r={}){return this.request({...r,method:"POST",url:e,data:t})}put(e,t,r={}){return this.request({...r,method:"PUT",url:e,data:t})}delete(e,t={}){return this.request({...t,method:"DELETE",url:e})}patch(e,t,r={}){return this.request({...r,method:"PATCH",url:e,data:t})}head(e,t={}){return this.request({...t,method:"HEAD",url:e})}options(e,t={}){return this.request({...t,method:"OPTIONS",url:e})}cancelAll(e){this.cancelManager.cancelAll(e)}getActiveRequestCount(){return this.cancelManager.getActiveRequestCount()}updateRetryConfig(e){this.retryManager.updateConfig(e)}setConfig(e){this.config={...this.config,...e,headers:{...this.config?.headers,...e.headers}}}getConfig(){return{...this.config}}addRequestInterceptor(e,t){return this.interceptors.request.use(e,t)}addResponseInterceptor(e,t){return this.interceptors.response.use(e,t)}removeRequestInterceptor(e){this.interceptors.request.eject(e)}removeResponseInterceptor(e){this.interceptors.response.eject(e)}clearCache(){return this.cacheManager.clear()}getConcurrencyStatus(){return this.concurrencyManager.getStatus()}cancelQueue(e){this.concurrencyManager.cancelQueue(e)}async processRequestInterceptors(e){let t=e;const r=this.interceptors.request.getInterceptors();for(const e of r)try{t=await e.fulfilled(t)}catch(t){throw e.rejected?await e.rejected(t):t}return t}async processResponseInterceptors(e){let t=e;const r=this.interceptors.response.getInterceptors();for(const e of r)try{t=await e.fulfilled(t)}catch(t){throw e.rejected?await e.rejected(t):t}return t}async processErrorInterceptors(e){let t=e;const r=this.interceptors.error.getInterceptors();for(const e of r)try{t=await e.fulfilled(t)}catch(e){t=e}return t}optimizedMergeConfig(e){if(!e||0===Object.keys(e).length)return{...this.config};const t={...this.config,...e};return this.config?.headers&&e.headers&&(t.headers={...this.config.headers,...e.headers}),this.config?.params&&e.params&&(t.params={...this.config.params,...e.params}),t}async upload(e,t,r={}){this.checkDestroyed();const s=Array.isArray(t)?t:[t];return 1===s.length?this.uploadSingleFile(e,s[0],r):this.uploadMultipleFiles(e,s,r)}async uploadSingleFile(e,t,r){y(t,r);const s=Date.now(),o=new f,a={method:"POST",url:e,data:m(t,r),headers:{...r.headers||{}},...r||{},onUploadProgress:r.onProgress?e=>{const s=o.calculate(e.loaded,e.total||0,t);r.onProgress?.(s)}:void 0};return{...await this.request(a),file:t,duration:Date.now()-s}}async uploadMultipleFiles(e,t,r){t.forEach(e=>y(e,r));const s=Date.now(),o=new f,a=new FormData,n=r.fileField||"files";t.forEach((e,t)=>{a.append(`${n}[${t}]`,e)}),r.formData&&Object.entries(r.formData).forEach(([e,t])=>{a.append(e,t)});const i={method:"POST",url:e,data:a,headers:{...r.headers||{}},...r||{},onUploadProgress:r.onProgress?e=>{const t=o.calculate(e.loaded,e.total||0);r.onProgress?.(t)}:void 0};return{...await this.request(i),file:t[0],duration:Date.now()-s}}async download(e,t={}){this.checkDestroyed();const r=Date.now(),s=new a,o={method:"GET",url:e,responseType:"blob",...t||{},onDownloadProgress:t.onProgress?e=>{const r=s.calculate(e.loaded,e.total||0,t.filename);t.onProgress?.(r)}:void 0},h=await this.request(o);let l=t.filename;l||(l=n(h.headers)||i(h.config.url||e)||"download");const d=h.data?.type||c(l);let p;return!1!==t.autoSave&&typeof window<"u"&&(u(h.data,l),p=URL.createObjectURL(h.data)),{data:h.data,filename:l,size:h.data.size,type:d,duration:Date.now()-r,url:p}}getPerformanceStats(){return this.monitor.getStats()}getRecentMetrics(e){return this.monitor.getRecentMetrics(e)}getSlowRequests(){return this.monitor.getSlowRequests()}getFailedRequests(){return this.monitor.getFailedRequests()}enableMonitoring(){this.monitor.enable()}disableMonitoring(){this.monitor.disable()}getPriorityQueueStats(){return this.priorityQueue.getStats()}getConnectionPoolStats(){return this.requestPool.getStats()}getConnectionDetails(){return this.requestPool.getConnectionDetails()}exportMetrics(){return{performance:this.monitor.exportMetrics(),priorityQueue:this.priorityQueue.getStats(),connectionPool:this.requestPool.getStats(),concurrency:this.concurrencyManager.getStatus(),cache:this.cacheManager.getStats?this.cacheManager.getStats():null}}setPriority(e,t){return{...e,priority:t}}destroy(){if(this.isDestroyed)return;this.isDestroyed=!0,this.cancelManager.cancelAll("Client destroyed"),this.cacheManager.clear(),this.concurrencyManager.cancelQueue("Client destroyed"),this.priorityQueue.destroy(),this.requestPool.destroy(),this.monitor.clear(),this.interceptors.request.clear(),this.interceptors.response.clear(),this.interceptors.error.clear();const e=this.cacheManager;e&&"function"==typeof e.destroy&&e.destroy(),this.adapter=null,this.retryManager=null,this.cancelManager=null,this.cacheManager=null,this.concurrencyManager=null,this.monitor=null,this.priorityQueue=null,this.requestPool=null}checkDestroyed(){if(this.isDestroyed)throw new Error("HttpClient has been destroyed")}}export{w as HttpClientImpl};
//# sourceMappingURL=client.js.map
