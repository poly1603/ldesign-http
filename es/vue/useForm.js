import{reactive as e,ref as a,computed as r,onUnmounted as t}from"vue";import{createHttpClient as n}from"../factory.js";function l(l={}){const i=n(l.clientConfig),s=e({...l.initialData}),o=a(!1),u=a(null),v=a({}),c=a({}),m=r(()=>null!==u.value),d=r(()=>Object.keys(v.value).length>0),g=r(()=>m.value||d.value),f=r(()=>!d.value);let h=null;const b=e=>{const a=c.value[e];if(!a||0===a.length)return!0;const r=s[e];for(const t of a){if(t.required&&(null==r||""===r))return v.value[e]=t.message||`${String(e)} is required`,!1;if(null!=r&&""!==r){if(void 0!==t.min&&String(r).length<t.min)return v.value[e]=t.message||`${String(e)} must be at least ${t.min} characters`,!1;if(void 0!==t.max&&String(r).length>t.max)return v.value[e]=t.message||`${String(e)} must be at most ${t.max} characters`,!1;if(t.pattern&&!t.pattern.test(String(r)))return v.value[e]=t.message||`${String(e)} format is invalid`,!1;if(t.validator){const a=t.validator(r);if(!0!==a)return v.value[e]="string"==typeof a?a:t.message||`${String(e)} is invalid`,!1}}}return delete v.value[e],!0},E=()=>{let e=!0;for(const a in c.value)b(a)||(e=!1);return!e&&l.onValidationError&&l.onValidationError(v.value),e};return!1!==l.cancelOnUnmount&&t(()=>{h&&h.abort()}),{data:s,submitting:o,error:u,errors:v,hasError:m,hasValidationErrors:d,hasAnyError:g,isValid:f,submit:async(e,a)=>{try{if(o.value=!0,u.value=null,!E())return null;h&&h.abort(),h=new AbortController;const r={...a,signal:h.signal},t=await i.post(e,s,r);return l.onSuccess?.(t.data,t),t.data}catch(e){const a=e;throw"AbortError"!==a.name&&(u.value=a,l.onError?.(a)),a}finally{o.value=!1}},validate:E,validateField:b,reset:()=>{Object.assign(s,l.initialData||{}),o.value=!1,u.value=null,v.value={}},clearErrors:()=>{u.value=null},clearValidationErrors:()=>{v.value={}},setField:(e,a)=>{s[e]=a,c.value[e]&&b(e)},setFieldError:(e,a)=>{v.value[e]=a},setValidationRules:e=>{c.value=e}}}export{l as useForm};
//# sourceMappingURL=useForm.js.map
