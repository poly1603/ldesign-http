import{ref as e,computed as a}from"vue";function u(u,t={}){const{concurrency:l=6,autoStart:r=!0,timeout:c=3e4}=t,n=e([]),o=e(new Set),i=e(0),v=e(0),s=e(!r),d=a(()=>n.value.length),f=a(()=>o.value.size),m=a(()=>i.value+v.value+d.value+f.value),p=async e=>{try{if(Date.now()-e.createdAt>c)throw new Error("Request timeout in queue");const a=await u.request(e.config);e.resolve(a.data),i.value++}catch(a){e.reject(a),v.value++}finally{o.value.delete(e.id),s.value||h()}};async function h(){for(;!s.value&&n.value.length>0&&o.value.size<l;){const e=n.value.shift();if(!e)break;o.value.add(e.id),p(e).catch(()=>{})}}return{enqueue:(e,a=0)=>new Promise((u,t)=>{const l={id:`${Date.now()}-${Math.random()}`,config:e,priority:a,resolve:u,reject:t,createdAt:Date.now()},r=n.value.findIndex(e=>e.priority<a);-1===r?n.value.push(l):n.value.splice(r,0,l),s.value||setTimeout(()=>h(),0)}),pause:()=>{s.value=!0},resume:()=>{s.value=!1,h()},clear:()=>{n.value.forEach(e=>{e.reject(new Error("Queue cleared"))}),n.value=[]},cancelAll:()=>{u.cancelAll("Queue cancelled"),o.value.clear()},reset:()=>{i.value=0,v.value=0},pending:d,active:f,total:m,completed:i,failed:v,isPaused:s,queue:n,activeRequests:o}}export{u as useRequestQueue};
//# sourceMappingURL=useRequestQueue.js.map
