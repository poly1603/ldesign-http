import{ref as t}from"vue";function e(e,a,l){const n=t(!1),u=t(null);let i=null,r=!1;return{execute:async(t,c)=>{try{n.value=!0,u.value=null,i=JSON.parse(JSON.stringify(a.value)),r=!0,a.value=l.optimisticUpdate(a.value,c);const o=await e.request(t);return r=!1,o.data&&(a.value=o.data),l.onSuccess?.(o.data),i=null,o.data}catch(t){if(u.value=t,null!==i){const t=i;a.value=t,l.onRollback?.(u.value||new Error("Rollback"),t),i=null}return null}finally{n.value=!1,r=!1}},rollback:()=>{if(null!==i){const t=i;a.value=t,l.onRollback?.(u.value||new Error("Rollback"),t),i=null}},loading:n,error:u,isOptimistic:t(r)}}function a(a,l,n={}){const{idKey:u="id"}=n;return{add:async(t,n)=>{const{execute:u}=e(a,l,{optimisticUpdate:t=>[...t,n]});return await u(t,n),n},update:async(t,n,i)=>{const{execute:r}=e(a,l,{optimisticUpdate:t=>t.map(t=>t[u]===n?{...t,...i}:t)});return await r(t,i)&&l.value.find(t=>t[u]===n)||null},remove:async(t,n)=>{const{execute:i}=e(a,l,{optimisticUpdate:t=>t.filter(t=>t[u]!==n)});return null!==await i(t,n)},loading:t(!1),error:t(null)}}export{a as useOptimisticList,e as useOptimisticUpdate};
//# sourceMappingURL=useOptimisticUpdate.js.map
