import{buildURL as e,createHttpError as r}from"../utils/index.js";class t{processConfig(r){const t={...r};return t.url&&(t.url=e(t.url,t.baseURL,t.params)),t.method||(t.method="GET"),t.headers||(t.headers={}),t}processResponse(e,r,t,o,s,n){return{data:e,status:r,statusText:t,headers:o,config:s,raw:n}}processError(e,t,o){let s,n="Request failed";e instanceof Error?(n=e.message,s=e.code):"string"==typeof e&&(n=e);const a=r(n,t,s,o);return"AbortError"===e.name||n.includes("aborted")?(a.isCancelError=!0,a.code="CANCELED"):"TimeoutError"===e.name||n.includes("timeout")?(a.isTimeoutError=!0,a.code="TIMEOUT"):(n.includes("Network")||n.includes("fetch"))&&(a.isNetworkError=!0,a.code="NETWORK_ERROR"),a}createTimeoutController(e){const r=new AbortController;let t;return e&&e>0&&(t=setTimeout(()=>{r&&"function"==typeof r.abort&&r.abort()},e)),{signal:r.signal,cleanup:()=>{t&&clearTimeout(t)}}}mergeAbortSignals(e){const r=e.filter(e=>void 0!==e);if(0===r.length)return(new AbortController).signal;if(1===r.length)return r[0];const t=new AbortController,o=()=>{t.abort()};return r.forEach(e=>{e.aborted?t.abort():e.addEventListener("abort",o,{once:!0})}),t.signal}parseHeaders(e){const r={};return e instanceof Headers?e.forEach((e,t)=>{r[t.toLowerCase()]=e}):Object.keys(e).forEach(t=>{const o=e[t];void 0!==o&&(r[t.toLowerCase()]=o)}),r}}export{t as BaseAdapter};
//# sourceMappingURL=base.js.map
