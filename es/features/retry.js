const t={maxRetries:3,initialDelay:1e3,maxDelay:3e4,backoffMultiplier:2,enableJitter:!0,shouldRetry:(t,e)=>!!("NETWORK_ERROR"===t.code||"TIMEOUT"===t.code||t.response&&t.response.status>=500)};function e(t,e){if(e.delayCalculator)return e.delayCalculator(t,e);let r=e.initialDelay*e.backoffMultiplier**(t-1);return r=Math.min(r,e.maxDelay),e.enableJitter&&(r*=.5+.5*Math.random()),Math.floor(r)}function r(t){return new Promise(e=>setTimeout(e,t))}class a{constructor(e={}){this.config={...t,...e}}async execute(t){const a={attempt:0,totalDelay:0,errors:[],startTime:Date.now()};for(;a.attempt<=this.config?.maxRetries;){a.attempt++;try{return{success:!0,data:await t(),retryState:a}}catch(t){a.errors.push(t);const s=this.config?.shouldRetry?.(t,a.attempt)??!0;if(a.attempt>this.config?.maxRetries||!s)return{success:!1,error:t,retryState:a};const o=e(a.attempt,this.config);a.totalDelay+=o,await r(o)}}return{success:!1,error:a.errors[a.errors.length-1],retryState:a}}updateConfig(t){this.config={...this.config,...t}}getConfig(){return{...this.config}}}function s(t){return new a(t)}function o(t){return function(e,r,a){const o=a.value,n=s(t);return a.value=async function(...t){const e=await n.execute(()=>o.apply(this,t));if(e.success)return e.data;throw e.error},a}}const n=s();async function l(t,e){const r=await(e?s(e):n).execute(t);if(r.success)return r.data;throw r.error}function i(t={}){const e={enabled:t.enabled??!0,maxAttempts:t.maxAttempts??3,delay:t.delay??1e3,backoffMultiplier:t.backoffMultiplier??2,delayFn:t.delayFn,shouldRetry:t.shouldRetry??t.condition??(t=>!!("NETWORK_ERROR"===t.code||"TIMEOUT"===t.code||"NetworkError"===t.name||t.isNetworkError||t.response?.status>=500&&t.response?.status<600||t.status>=500&&t.status<600))};return async function(t,a){const s=t?.retry||{},o={enabled:s.enabled??e.enabled,maxAttempts:s.maxAttempts??e.maxAttempts,delay:s.delay??e.delay,backoffMultiplier:s.backoffMultiplier??e.backoffMultiplier,delayFn:s.delayFn??e.delayFn,shouldRetry:s.shouldRetry??e.shouldRetry};if(!o.enabled||o.maxAttempts<=0)return a();let n,l=0;for(;l<o.maxAttempts;)try{return l++,await a()}catch(t){n=t;const e=1===o.shouldRetry.length?o.shouldRetry(t):o.shouldRetry(t,l);if(l>=o.maxAttempts||!e)throw t;let a;a=o.delayFn?o.delayFn(l):o.delay*o.backoffMultiplier**(l-1),await r(a)}throw n}}export{t as DEFAULT_RETRY_CONFIG,a as RetryExecutor,e as calculateDelay,s as createRetryExecutor,r as delay,n as globalRetryExecutor,o as retry,l as retryOperation,i as withRetry};
//# sourceMappingURL=retry.js.map
