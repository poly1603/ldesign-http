{"version":3,"file":"middleware.js","sources":["../../src/interceptors/middleware.ts"],"sourcesContent":["/**\n * 拦截器中间件系统\n * \n * 提供可组合、可复用的拦截器中间件模式\n */\n\nimport type {\n  ErrorInterceptor,\n  HttpError,\n  RequestConfig,\n  RequestInterceptor,\n  ResponseData,\n  ResponseInterceptor,\n} from '../types'\n\n/**\n * 中间件函数类型\n */\nexport type Middleware<TContext = any> = (\n  context: TContext,\n  next: () => Promise<TContext>,\n) => Promise<TContext>\n\n/**\n * 请求中间件类型\n */\nexport type RequestMiddleware = Middleware<RequestConfig>\n\n/**\n * 响应中间件类型\n */\nexport type ResponseMiddleware<T = any> = Middleware<ResponseData<T>>\n\n/**\n * 错误中间件类型\n */\nexport type ErrorMiddleware = (\n  error: HttpError,\n  next: (error: HttpError) => Promise<HttpError>,\n) => Promise<HttpError>\n\n/**\n * 组合多个请求中间件为一个拦截器\n * \n * @param middlewares - 中间件数组\n * @returns 组合后的请求拦截器\n * \n * @example\n * ```typescript\n * const logRequest: RequestMiddleware = async (config, next) => {\n *   \n *   return next()\n * }\n * \n * const addTimestamp: RequestMiddleware = async (config, next) => {\n *   config.params = { ...config.params, _t: Date.now() }\n *   return next()\n * }\n * \n * const interceptor = composeRequestMiddleware([logRequest, addTimestamp])\n * client.interceptors.request.use(interceptor)\n * ```\n */\nexport function composeRequestMiddleware(\n  middlewares: RequestMiddleware[],\n): RequestInterceptor {\n  if (!Array.isArray(middlewares) || middlewares.length === 0) {\n    return (config: RequestConfig) => config\n  }\n\n  return async (config: RequestConfig): Promise<RequestConfig> => {\n    const index = 0\n\n    async function dispatch(i: number, ctx: RequestConfig): Promise<RequestConfig> {\n      if (i >= middlewares.length) {\n        return ctx\n      }\n\n      const middleware = middlewares[i]!\n\n      return middleware(ctx, () => dispatch(i + 1, ctx))\n    }\n\n    return dispatch(index, config)\n  }\n}\n\n/**\n * 组合多个响应中间件为一个拦截器\n * \n * @param middlewares - 中间件数组\n * @returns 组合后的响应拦截器\n * \n * @example\n * ```typescript\n * const logResponse: ResponseMiddleware = async (response, next) => {\n *   \n *   return next()\n * }\n * \n * const extractData: ResponseMiddleware = async (response, next) => {\n *   // 提取嵌套的数据字段\n *   if (response.data?.result) {\n *     response.data = response.data.result\n *   }\n *   return next()\n * }\n * \n * const interceptor = composeResponseMiddleware([logResponse, extractData])\n * client.interceptors.response.use(interceptor)\n * ```\n */\nexport function composeResponseMiddleware<T = any>(\n  middlewares: ResponseMiddleware<T>[],\n): ResponseInterceptor<T> {\n  if (!Array.isArray(middlewares) || middlewares.length === 0) {\n    return (response: ResponseData<T>) => response\n  }\n\n  return async (response: ResponseData<T>): Promise<ResponseData<T>> => {\n    const index = 0\n\n    async function dispatch(i: number, ctx: ResponseData<T>): Promise<ResponseData<T>> {\n      if (i >= middlewares.length) {\n        return ctx\n      }\n\n      const middleware = middlewares[i]!\n\n      return middleware(ctx, () => dispatch(i + 1, ctx))\n    }\n\n    return dispatch(index, response)\n  }\n}\n\n/**\n * 组合多个错误中间件为一个拦截器\n * \n * @param middlewares - 中间件数组\n * @returns 组合后的错误拦截器\n * \n * @example\n * ```typescript\n * const logError: ErrorMiddleware = async (error, next) => {\n *   console.error('Error:', error.message)\n *   return next(error)\n * }\n * \n * const retryOn5xx: ErrorMiddleware = async (error, next) => {\n *   if (error.response?.status >= 500) {\n *     // 自定义重试逻辑\n *   }\n *   return next(error)\n * }\n * \n * const interceptor = composeErrorMiddleware([logError, retryOn5xx])\n * client.interceptors.error.use(interceptor)\n * ```\n */\nexport function composeErrorMiddleware(\n  middlewares: ErrorMiddleware[],\n): ErrorInterceptor {\n  if (!Array.isArray(middlewares) || middlewares.length === 0) {\n    return (error: HttpError) => error\n  }\n\n  return async (error: HttpError): Promise<HttpError> => {\n    const index = 0\n\n    async function dispatch(i: number, err: HttpError): Promise<HttpError> {\n      if (i >= middlewares.length) {\n        return err\n      }\n\n      const middleware = middlewares[i]!\n\n      return middleware(err, nextError => dispatch(i + 1, nextError))\n    }\n\n    return dispatch(index, error)\n  }\n}\n\n/**\n * 创建条件中间件\n * \n * 只在满足条件时执行中间件\n * \n * @param condition - 条件函数\n * @param middleware - 要执行的中间件\n * @returns 条件中间件\n * \n * @example\n * ```typescript\n * const addAuthToken: RequestMiddleware = async (config, next) => {\n *   config.headers = { ...config.headers, Authorization: 'Bearer token' }\n *   return next()\n * }\n * \n * // 只对 /api 路径的请求添加认证\n * const conditionalAuth = createConditionalMiddleware(\n *   (config) => config.url?.startsWith('/api'),\n *   addAuthToken\n * )\n * ```\n */\nexport function createConditionalMiddleware<TContext>(\n  condition: (context: TContext) => boolean | Promise<boolean>,\n  middleware: Middleware<TContext>,\n): Middleware<TContext> {\n  return async (context: TContext, next: () => Promise<TContext>): Promise<TContext> => {\n    const shouldExecute = await condition(context)\n\n    if (shouldExecute) {\n      return middleware(context, next)\n    }\n\n    return next()\n  }\n}\n\n/**\n * 创建请求路径匹配中间件\n * \n * @param pattern - URL 匹配模式（正则或字符串）\n * @param middleware - 要执行的中间件\n * @returns 路径匹配中间件\n * \n * @example\n * ```typescript\n * const logApiRequests: RequestMiddleware = async (config, next) => {\n *   \n *   return next()\n * }\n * \n * // 只记录 API 请求\n * const apiLogger = createPathMatchMiddleware(/^\\/api\\//, logApiRequests)\n * ```\n */\nexport function createPathMatchMiddleware(\n  pattern: string | RegExp,\n  middleware: RequestMiddleware,\n): RequestMiddleware {\n  const matcher = typeof pattern === 'string'\n    ? (url: string) => url.includes(pattern)\n    : (url: string) => pattern.test(url)\n\n  return createConditionalMiddleware(\n    (config: RequestConfig) => {\n      const url = config.url || ''\n      return matcher(url)\n    },\n    middleware,\n  )\n}\n\n/**\n * 创建方法匹配中间件\n * \n * @param methods - HTTP 方法数组\n * @param middleware - 要执行的中间件\n * @returns 方法匹配中间件\n * \n * @example\n * ```typescript\n * const addCsrfToken: RequestMiddleware = async (config, next) => {\n *   config.headers = { ...config.headers, 'X-CSRF-Token': getCsrfToken() }\n *   return next()\n * }\n * \n * // 只对写操作添加 CSRF token\n * const csrfProtection = createMethodMatchMiddleware(\n *   ['POST', 'PUT', 'PATCH', 'DELETE'],\n *   addCsrfToken\n * )\n * ```\n */\nexport function createMethodMatchMiddleware(\n  methods: string[],\n  middleware: RequestMiddleware,\n): RequestMiddleware {\n  const methodSet = new Set(methods.map(m => m.toUpperCase()))\n\n  return createConditionalMiddleware(\n    (config: RequestConfig) => {\n      const method = (config.method || 'GET').toUpperCase()\n      return methodSet.has(method)\n    },\n    middleware,\n  )\n}\n\n/**\n * 创建计时中间件\n * \n * 自动测量请求执行时间\n * \n * @param onComplete - 完成回调\n * @returns 计时中间件\n * \n * @example\n * ```typescript\n * const timingMiddleware = createTimingMiddleware((duration, config) => {\n *   \n * })\n * ```\n */\nexport function createTimingMiddleware(\n  onComplete?: (duration: number, config: RequestConfig) => void,\n): RequestMiddleware {\n  return async (config: RequestConfig, next: () => Promise<RequestConfig>): Promise<RequestConfig> => {\n    const startTime = Date.now()\n\n    try {\n      return await next()\n    }\n    finally {\n      const duration = Date.now() - startTime\n      onComplete?.(duration, config)\n    }\n  }\n}\n\n/**\n * 创建缓存中间件\n * \n * 缓存中间件执行结果\n * \n * @param options - 缓存选项\n * @param options.ttl - 缓存过期时间（毫秒），默认60000\n * @param options.keyGenerator - 缓存键生成函数\n * @param options.middleware - 要缓存的中间件\n * @returns 缓存中间件\n * \n * @example\n * ```typescript\n * const cachedMiddleware = createCacheMiddleware({\n *   ttl: 60000, // 1分钟\n *   keyGenerator: (config) => config.url,\n *   middleware: expensiveMiddleware\n * })\n * ```\n */\nexport function createCacheMiddleware<TContext>(options: {\n  ttl?: number\n  keyGenerator: (context: TContext) => string\n  middleware: Middleware<TContext>\n}): Middleware<TContext> {\n  const { ttl = 60000, keyGenerator, middleware } = options\n  const cache = new Map<string, { value: TContext, expiry: number }>()\n\n  return async (context: TContext, next: () => Promise<TContext>): Promise<TContext> => {\n    const key = keyGenerator(context)\n    const now = Date.now()\n\n    // 检查缓存\n    const cached = cache.get(key)\n    if (cached && cached.expiry > now) {\n      return cached.value\n    }\n\n    // 执行中间件\n    const result = await middleware(context, next)\n\n    // 存入缓存\n    cache.set(key, {\n      value: result,\n      expiry: now + ttl,\n    })\n\n    return result\n  }\n}\n\n/**\n * 创建重试中间件\n * \n * 自动重试失败的中间件\n * \n * @param options - 重试选项\n * @param options.maxAttempts - 最大重试次数，默认3次\n * @param options.delay - 重试延迟（毫秒），默认1000\n * @param options.shouldRetry - 判断是否应该重试的函数\n * @param options.middleware - 要重试的中间件\n * @returns 重试中间件\n * \n * @example\n * ```typescript\n * const retryMiddleware = createRetryMiddleware({\n *   maxAttempts: 3,\n *   delay: 1000,\n *   shouldRetry: (error) => error.status === 503,\n *   middleware: unstableMiddleware\n * })\n * ```\n */\nexport function createRetryMiddleware<TContext>(options: {\n  maxAttempts?: number\n  delay?: number\n  shouldRetry?: (error: any, attempt: number) => boolean\n  middleware: Middleware<TContext>\n}): Middleware<TContext> {\n  const {\n    maxAttempts = 3,\n    delay = 1000,\n    shouldRetry = () => true,\n    middleware,\n  } = options\n\n  return async (context: TContext, next: () => Promise<TContext>): Promise<TContext> => {\n    let lastError: any\n\n    for (let attempt = 1; attempt <= maxAttempts; attempt++) {\n      try {\n        return await middleware(context, next)\n      }\n      catch (error) {\n        lastError = error\n\n        if (attempt < maxAttempts && shouldRetry(error, attempt)) {\n          await new Promise(resolve => setTimeout(resolve, delay * attempt))\n        }\n        else {\n          throw error\n        }\n      }\n    }\n\n    throw lastError\n  }\n}\n\n/**\n * 创建管道中间件\n * \n * 按顺序执行一系列转换函数\n * \n * @param transforms - 转换函数数组\n * @returns 管道中间件\n * \n * @example\n * ```typescript\n * const pipeline = createPipelineMiddleware([\n *   (config) => ({ ...config, headers: { ...config.headers, 'X-Custom': 'value' } }),\n *   (config) => ({ ...config, timeout: 5000 }),\n *   (config) => ({ ...config, withCredentials: true })\n * ])\n * ```\n */\nexport function createPipelineMiddleware<TContext>(\n  transforms: Array<(context: TContext) => TContext | Promise<TContext>>,\n): Middleware<TContext> {\n  return async (context: TContext, next: () => Promise<TContext>): Promise<TContext> => {\n    let result = context\n\n    for (const transform of transforms) {\n      result = await transform(result)\n    }\n\n    return next()\n  }\n}\n\n/**\n * 中间件构建器\n * \n * 提供流畅的 API 来构建复杂的中间件组合\n * \n * @example\n * ```typescript\n * const middleware = new MiddlewareBuilder<RequestConfig>()\n *   .use(loggingMiddleware)\n *   .when(config => config.url?.includes('/api'), authMiddleware)\n *   .timing((duration, config) => )\n *   .build()\n * ```\n */\nexport class MiddlewareBuilder<TContext> {\n  private middlewares: Array<Middleware<TContext>> = []\n\n  /**\n   * 添加中间件\n   */\n  use(middleware: Middleware<TContext>): this {\n    this.middlewares.push(middleware)\n    return this\n  }\n\n  /**\n   * 添加条件中间件\n   */\n  when(\n    condition: (context: TContext) => boolean | Promise<boolean>,\n    middleware: Middleware<TContext>,\n  ): this {\n    this.middlewares.push(createConditionalMiddleware(condition, middleware))\n    return this\n  }\n\n  /**\n   * 添加计时中间件（仅适用于 RequestConfig）\n   */\n  timing(\n    onComplete: (duration: number, config: any) => void,\n  ): this {\n    this.middlewares.push(createTimingMiddleware(onComplete) as any)\n    return this\n  }\n\n  /**\n   * 添加管道转换\n   */\n  pipe(\n    ...transforms: Array<(context: TContext) => TContext | Promise<TContext>>\n  ): this {\n    this.middlewares.push(createPipelineMiddleware(transforms))\n    return this\n  }\n\n  /**\n   * 构建最终的中间件\n   */\n  build(): Middleware<TContext> {\n    const composed = this.middlewares\n\n    return async (context: TContext, next: () => Promise<TContext>): Promise<TContext> => {\n      const index = 0\n\n      async function dispatch(i: number, ctx: TContext): Promise<TContext> {\n        if (i >= composed.length) {\n          return next()\n        }\n\n        const middleware = composed[i]!\n\n        return middleware(ctx, () => dispatch(i + 1, ctx))\n      }\n\n      return dispatch(index, context)\n    }\n  }\n\n  /**\n   * 清空所有中间件\n   */\n  clear(): this {\n    this.middlewares = []\n    return this\n  }\n\n  /**\n   * 获取中间件数量\n   */\n  get size(): number {\n    return this.middlewares.length\n  }\n}\n"],"names":["composeRequestMiddleware","middlewares","Array","isArray","length","async","dispatch","i","ctx","middleware","config","composeResponseMiddleware","response","composeErrorMiddleware","err","nextError","error","createConditionalMiddleware","condition","context","next","createPathMatchMiddleware","pattern","matcher","url","includes","test","createMethodMatchMiddleware","methods","methodSet","Set","map","m","toUpperCase","method","has","createTimingMiddleware","onComplete","startTime","Date","now","duration","createCacheMiddleware","options","ttl","keyGenerator","cache","Map","key","cached","get","expiry","value","result","set","createRetryMiddleware","maxAttempts","delay","shouldRetry","lastError","attempt","Promise","resolve","setTimeout","createPipelineMiddleware","transforms","transform","MiddlewareBuilder","constructor","this","use","push","when","timing","pipe","build","composed","clear","size","x","p","y","f","g","l","M","w","A","h"],"mappings":"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"}