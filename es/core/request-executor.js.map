{"version":3,"file":"request-executor.js","sources":["../../src/core/request-executor.ts"],"sourcesContent":["/**\r\n * 请求执行器模块\r\n * \r\n * 负责实际的请求执行逻辑，包括缓存、并发控制、重试等\r\n */\r\n\r\nimport type {\r\n  HttpAdapter,\r\n  RequestConfig,\r\n  ResponseData,\r\n  RetryConfig,\r\n} from '../types'\r\nimport type { CacheManager } from '../utils/cache'\r\nimport type { ConcurrencyManager } from '../utils/concurrency'\r\nimport type { RetryManager } from '../utils/error'\r\nimport type { RequestMonitor } from '../utils/monitor'\r\nimport type { PriorityQueue } from '../utils/priority'\r\nimport { generateId } from '../utils'\r\nimport { determinePriority } from '../utils/priority'\r\n\r\n/**\r\n * 请求执行器配置\r\n */\r\nexport interface RequestExecutorConfig {\r\n  /** HTTP适配器 */\r\n  adapter: HttpAdapter\r\n  /** 缓存管理器 */\r\n  cacheManager: CacheManager\r\n  /** 并发管理器 */\r\n  concurrencyManager: ConcurrencyManager\r\n  /** 重试管理器 */\r\n  retryManager: RetryManager\r\n  /** 监控器 */\r\n  monitor: RequestMonitor\r\n  /** 优先级队列 */\r\n  priorityQueue?: PriorityQueue\r\n}\r\n\r\n/**\r\n * 请求执行器\r\n * \r\n * 封装请求执行的核心逻辑\r\n */\r\nexport class RequestExecutor {\r\n  private config: RequestExecutorConfig\r\n\r\n  constructor(config: RequestExecutorConfig) {\r\n    this.config = config\r\n  }\r\n\r\n  /**\r\n   * 执行请求\r\n   */\r\n  async execute<T = unknown>(\r\n    requestConfig: RequestConfig,\r\n    options?: {\r\n      skipCache?: boolean\r\n      skipRetry?: boolean\r\n      requestId?: string\r\n    },\r\n  ): Promise<ResponseData<T>> {\r\n    const requestId = options?.requestId || generateId()\r\n    \r\n    // 开始监控\r\n    this.config.monitor.startRequest(requestId, requestConfig)\r\n\r\n    try {\r\n      // 判断是否使用优先级队列\r\n      const priority = determinePriority(requestConfig)\r\n      \r\n      if (priority !== undefined && this.config.priorityQueue) {\r\n        return await this.executeWithPriority<T>(\r\n          requestConfig,\r\n          requestId,\r\n          priority,\r\n          options,\r\n        )\r\n      }\r\n\r\n      // 普通执行\r\n      const response = await this.executeWithRetry<T>(\r\n        requestConfig,\r\n        requestId,\r\n        options,\r\n      )\r\n      \r\n      this.config.monitor.endRequest(requestId, requestConfig, response)\r\n      return response\r\n    } catch (error) {\r\n      this.config.monitor.endRequest(\r\n        requestId,\r\n        requestConfig,\r\n        undefined,\r\n        error as Error,\r\n      )\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 使用优先级队列执行\r\n   */\r\n  private async executeWithPriority<T>(\r\n    config: RequestConfig,\r\n    requestId: string,\r\n    priority: number,\r\n    options?: {\r\n      skipCache?: boolean\r\n      skipRetry?: boolean\r\n    },\r\n  ): Promise<ResponseData<T>> {\r\n    return this.config.priorityQueue!.enqueue(\r\n      config,\r\n      async () => {\r\n        const response = await this.executeWithRetry<T>(\r\n          config,\r\n          requestId,\r\n          options,\r\n        )\r\n        this.config.monitor.endRequest(requestId, config, response)\r\n        return response\r\n      },\r\n      priority,\r\n    )\r\n  }\r\n\r\n  /**\r\n   * 执行带重试的请求\r\n   */\r\n  private async executeWithRetry<T>(\r\n    config: RequestConfig,\r\n    requestId: string,\r\n    options?: {\r\n      skipCache?: boolean\r\n      skipRetry?: boolean\r\n    },\r\n  ): Promise<ResponseData<T>> {\r\n    // 如果启用了重试且未跳过\r\n    const retryConfig = config.retry as RetryConfig | undefined\r\n    if (!options?.skipRetry && retryConfig?.retries && retryConfig.retries > 0) {\r\n      return this.config.retryManager.executeWithRetry(\r\n        () => {\r\n          this.config.monitor.recordRetry(requestId)\r\n          return this.executeSingle<T>(config, options)\r\n        },\r\n        config,\r\n      )\r\n    }\r\n\r\n    return this.executeSingle<T>(config, options)\r\n  }\r\n\r\n  /**\r\n   * 执行单次请求\r\n   */\r\n  private async executeSingle<T>(\r\n    config: RequestConfig,\r\n    options?: {\r\n      skipCache?: boolean\r\n    },\r\n  ): Promise<ResponseData<T>> {\r\n    // 检查缓存\r\n    if (!options?.skipCache) {\r\n      const cachedResponse = await this.config.cacheManager.get<T>(config)\r\n      if (cachedResponse) {\r\n        return cachedResponse\r\n      }\r\n    }\r\n\r\n    // 使用并发控制执行请求\r\n    return this.config.concurrencyManager.execute(\r\n      () => this.performRequest<T>(config),\r\n      config,\r\n    )\r\n  }\r\n\r\n  /**\r\n   * 执行实际的请求\r\n   */\r\n  private async performRequest<T>(\r\n    config: RequestConfig,\r\n  ): Promise<ResponseData<T>> {\r\n    // 发送请求\r\n    const response = await this.config.adapter.request<T>(config)\r\n\r\n    // 缓存响应\r\n    await this.config.cacheManager.set(config, response)\r\n\r\n    return response\r\n  }\r\n\r\n  /**\r\n   * 批量执行请求\r\n   */\r\n  async executeBatch<T = unknown>(\r\n    configs: RequestConfig[],\r\n    options?: {\r\n      parallel?: boolean\r\n      maxConcurrency?: number\r\n      continueOnError?: boolean\r\n    },\r\n  ): Promise<Array<{ success: boolean; data?: ResponseData<T>; error?: Error }>> {\r\n    const results: Array<{ success: boolean; data?: ResponseData<T>; error?: Error }> = []\r\n\r\n    if (options?.parallel) {\r\n      // 并行执行\r\n      const promises = configs.map(config =>\r\n        this.execute<T>(config)\r\n          .then(data => ({ success: true, data } as const))\r\n          .catch(error => ({ success: false, error } as const)),\r\n      )\r\n\r\n      const batchResults = await Promise.all(promises)\r\n      results.push(...batchResults)\r\n    } else {\r\n      // 串行执行\r\n      for (const config of configs) {\r\n        try {\r\n          const data = await this.execute<T>(config)\r\n          results.push({ success: true, data })\r\n        } catch (error) {\r\n          results.push({ success: false, error: error as Error })\r\n          \r\n          if (!options?.continueOnError) {\r\n            break\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return results\r\n  }\r\n\r\n  /**\r\n   * 带超时的请求执行\r\n   */\r\n  async executeWithTimeout<T>(\r\n    config: RequestConfig,\r\n    timeout: number,\r\n  ): Promise<ResponseData<T>> {\r\n    const timeoutPromise = new Promise<never>((_, reject) => {\r\n      setTimeout(() => {\r\n        reject(new Error(`Request timeout after ${timeout}ms`))\r\n      }, timeout)\r\n    })\r\n\r\n    return Promise.race([\r\n      this.execute<T>(config),\r\n      timeoutPromise,\r\n    ])\r\n  }\r\n\r\n  /**\r\n   * 带取消令牌的请求执行\r\n   */\r\n  async executeWithCancellation<T>(\r\n    config: RequestConfig,\r\n    signal: AbortSignal,\r\n  ): Promise<ResponseData<T>> {\r\n    return new Promise((resolve, reject) => {\r\n      // 监听取消信号\r\n      const onAbort = () => {\r\n        reject(new Error('Request cancelled'))\r\n      }\r\n\r\n      if (signal.aborted) {\r\n        onAbort()\r\n        return\r\n      }\r\n\r\n      signal.addEventListener('abort', onAbort, { once: true })\r\n\r\n      // 执行请求\r\n      this.execute<T>({ ...config, signal })\r\n        .then(resolve)\r\n        .catch(reject)\r\n        .finally(() => {\r\n          signal.removeEventListener('abort', onAbort)\r\n        })\r\n    })\r\n  }\r\n\r\n  /**\r\n   * 获取执行器状态\r\n   */\r\n  getStatus() {\r\n    return {\r\n      concurrency: this.config.concurrencyManager.getStatus(),\r\n      cache: {\r\n        size: (this.config.cacheManager as any).getSize?.() || 0,\r\n        hits: this.config.cacheManager.getStats?.()?.hits || 0,\r\n        misses: this.config.cacheManager.getStats?.()?.misses || 0,\r\n      },\r\n      monitor: this.config.monitor.getMetrics?.() || [],\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 清理资源\r\n   */\r\n  cleanup() {\r\n    // 清理缓存\r\n    this.config.cacheManager.clear()\r\n    \r\n    // 取消所有等待的请求\r\n    this.config.concurrencyManager.cancelQueue()\r\n    \r\n    // 清理优先级队列\r\n    if (this.config.priorityQueue) {\r\n      (this.config.priorityQueue as any).clear?.()\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * 创建请求执行器\r\n */\r\nexport function createRequestExecutor(\r\n  config: RequestExecutorConfig,\r\n): RequestExecutor {\r\n  return new RequestExecutor(config)\r\n}"],"names":["RequestExecutor","constructor","config","this","execute","requestConfig","options","requestId","generateId","monitor","startRequest","priority","determinePriority","priorityQueue","executeWithPriority","response","executeWithRetry","endRequest","error","enqueue","async","retryConfig","retry","skipRetry","retries","retryManager","recordRetry","executeSingle","skipCache","cachedResponse","cacheManager","get","concurrencyManager","performRequest","adapter","request","set","executeBatch","configs","results","parallel","promises","map","then","data","success","catch","batchResults","Promise","all","push","continueOnError","executeWithTimeout","timeout","timeoutPromise","_","reject","setTimeout","Error","race","executeWithCancellation","signal","resolve","onAbort","aborted","addEventListener","once","finally","removeEventListener","getStatus","concurrency","cache","size","getSize","hits","getStats","misses","getMetrics","cleanup","clear","cancelQueue","createRequestExecutor","o","g"],"mappings":"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"}